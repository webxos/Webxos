<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="GeoDrive by WebXOS is a secure, browser-based storage solution for managing files and data. Create profiles, upload files, and track storage with a powerful console interface. Ideal for developers and secure data management.">
    <meta name="keywords" content="GeoDrive, WebXOS, secure storage, browser storage, file management, data encryption, developer tools, storage console, profile management, file upload">
    <meta name="author" content="WebXOS">
    <meta name="robots" content="index, follow">
    <meta name="title" content="GeoDrive - Secure Storage Console by WebXOS">
    <meta name="application-name" content="GeoDrive">
    <meta property="og:title" content="GeoDrive - Secure Storage Console by WebXOS">
    <meta property="og:description" content="Manage secure, encrypted file storage with GeoDrive by WebXOS. A free, browser-based tool for creating profiles, uploading files, and tracking storage usage.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.webxos.com/geodrive">
    <meta property="og:image" content="https://www.webxos.com/geodrive/preview-image.jpg">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="GeoDrive - Secure Storage Console by WebXOS">
    <meta name="twitter:description" content="GeoDrive by WebXOS provides a secure, front-end solution for encrypted file storage and management in your browser. Perfect for developers and secure data handling.">
    <meta name="twitter:image" content="https://www.webxos.com/geodrive/preview-image.jpg">
    <title>GeoDrive - Secure Storage Console</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/idb/7.1.1/umd.min.js"></script>
    <style>
        body {
            background: #000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .logo {
            font-size: 40pt;
            color: #00ff00;
            text-align: center;
            padding: 10px 0;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff00;
        }

        #console-container {
            flex: 1;
            padding: 10px;
            box-sizing: border-box;
            overflow: hidden;
        }

        #console {
            background: #000;
            height: calc(100% - 10px);
            overflow-y: auto;
            font-size: 12px;
            box-sizing: border-box;
            padding: 5px;
        }

        .bottom-section {
            padding: 10px;
            background: #000;
            width: 100%;
            box-sizing: border-box;
        }

        .input-area {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 10px;
        }

        input, button {
            background: #000;
            color: #00ff00;
            border: 1px solid #00ff00;
            font-family: 'Courier New', monospace;
            padding: 3px;
            font-size: 12px;
            flex: 1;
            min-width: 80px;
        }

        input {
            flex: 2;
        }

        button:hover {
            background: #00ff00;
            color: #000;
            cursor: pointer;
        }

        .entry {
            margin: 3px 0;
            word-wrap: break-word;
        }

        .timestamp {
            color: #008800;
            margin-right: 5px;
        }

        footer {
            text-align: center;
            font-size: 10px;
            color: #00ff00;
            padding: 5px 0;
            width: 100%;
            box-sizing: border-box;
        }

        @media (max-width: 480px) {
            .logo {
                font-size: 24pt;
                padding: 5px 0;
            }

            #console-container {
                max-height: calc(100vh - 50px - 110px);
                padding: 5px;
            }

            #console {
                font-size: 10px;
            }

            .bottom-section {
                padding: 8px 5px;
                min-height: 60px;
            }

            .input-area {
                margin-bottom: 5px;
            }

            input, button {
                font-size: 10px;
                padding: 4px;
                min-width: 70px;
            }

            footer {
                font-size: 8px;
                padding: 8px 0;
            }
        }

        @media (min-width: 481px) {
            #console-container {
                max-height: calc(100vh - 80px - 80px);
            }
        }
    </style>
</head>
<body>
    <div class="logo">GeoDrive</div>
    <div id="console-container">
        <div id="console"></div>
    </div>

    <div class="bottom-section">
        <div class="input-area">
            <input type="text" id="commandInput" placeholder="Enter command..." onkeydown="if(event.key === 'Enter') processCommand()">
            <button onclick="processCommand()">Execute</button>
            <button onclick="clearConsole()">Clear</button>
        </div>
    </div>

    <footer>
        Â© 2025 WebXOS - GeoDrive - All data stored securely in browser
    </footer>

    <script>
        // Initialize IndexedDB
        const dbPromise = idb.openDB('GeoDriveDB', 1, {
            upgrade(db) {
                db.createObjectStore('profiles', { keyPath: 'profileKey' });
                db.createObjectStore('data', { keyPath: 'dataKey' });
            }
        });

        // Browser detection for storage limits
        const ua = navigator.userAgent.toLowerCase();
        const browser = {
            chrome: /chrome|chromium|crios/.test(ua),
            firefox: /firefox|fxios/.test(ua),
            safari: /safari/.test(ua) && !/chrome|chromium|crios/.test(ua),
        };
        const MAX_PER_KEY_MB = browser.chrome || browser.firefox ? 1000 : browser.safari ? 500 : 500;
        const MAX_TOTAL_MB = 1000000; // 1TB

        let totalUsedMB = 0;
        let currentProfileKey = '';
        let deleteConfirmationPending = false;

        // Console output
        const consoleDiv = document.getElementById('console');
        function log(message) {
            const timestamp = new Date().toLocaleString();
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${timestamp}]</span>${message}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        // Display help at startup
        const helpText = `
GeoDrive v1.0 - Secure Storage Console initialized
Available Commands:
PROFILE - Generate a new profile key
DRIVE - Open drive management popup (requires profile key)
DELETE DRIVE - Delete current profile (requires Y/N confirmation)
UPLOAD - Upload a file to the drive
VIEW - List all uploads for the current profile
SPACE - Show storage usage and limits
DELETE [number] - Delete upload by number (e.g., DELETE 1)
DOWNLOAD [number] - Download upload by number (e.g., DOWNLOAD 1)
HELP - Show this help
Type commands below to begin
        `;
        log(helpText);

        // Create profile key
        async function createProfile() {
            try {
                const randomStr = CryptoJS.lib.WordArray.random(16).toString();
                const profileKey = `GEO_${randomStr.slice(0, 8)}-${randomStr.slice(8, 16)}-${randomStr.slice(16, 24)}`;
                const db = await dbPromise;
                await db.put('profiles', { profileKey, size: 0.001 });
                totalUsedMB += 0.001;
                currentProfileKey = profileKey;
                log(`Profile key generated: ${profileKey}`);
            } catch (err) {
                log(`ERROR: ${err.message}`);
            }
        }

        // Delete profile
        async function deleteProfile(confirmed) {
            if (!currentProfileKey) {
                log('ERROR: No profile selected.');
                return false;
            }
            if (!confirmed) {
                log('Are you sure? Type DELETE DRIVE Y to confirm, or DELETE DRIVE N to cancel.');
                deleteConfirmationPending = true;
                return false;
            }
            try {
                const db = await dbPromise;
                const profile = await db.get('profiles', currentProfileKey);
                if (!profile) {
                    log('ERROR: Invalid profile key.');
                    return false;
                }
                const dataItems = await db.getAll('data');
                const userData = dataItems.filter(d => d.profileKey === currentProfileKey);
                for (const item of userData) {
                    totalUsedMB -= item.size;
                    await db.delete('data', item.dataKey);
                }
                totalUsedMB -= 0.001;
                await db.delete('profiles', currentProfileKey);
                log(`Profile ${currentProfileKey} and all associated data deleted.`);
                currentProfileKey = '';
                deleteConfirmationPending = false;
                return true;
            } catch (err) {
                log(`ERROR: ${err.message}`);
                return false;
            }
        }

        // Upload file
        async function uploadFile() {
            if (!currentProfileKey) {
                log('ERROR: No profile selected. Use PROFILE to create one.');
                return;
            }
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '*/*';
            fileInput.onchange = async () => {
                const file = fileInput.files[0];
                if (!file) return;
                try {
                    const db = await dbPromise;
                    const profile = await db.get('profiles', currentProfileKey);
                    if (!profile) {
                        log('ERROR: Invalid profile key.');
                        return;
                    }
                    const data = await file.arrayBuffer();
                    const sizeMB = data.byteLength / (1024 * 1024);
                    if (sizeMB > MAX_PER_KEY_MB) {
                        log(`ERROR: File size (${sizeMB.toFixed(3)} MB) exceeds per-key limit (${MAX_PER_KEY_MB} MB).`);
                        return;
                    }
                    if (totalUsedMB + sizeMB > MAX_TOTAL_MB) {
                        log(`ERROR: Not enough storage (${(MAX_TOTAL_MB - totalUsedMB).toFixed(3)} MB left).`);
                        return;
                    }
                    const aesKey = CryptoJS.SHA256(currentProfileKey).toString();
                    const wordArray = CryptoJS.lib.WordArray.create(data);
                    const encrypted = CryptoJS.AES.encrypt(wordArray, aesKey).toString();
                    const dataHash = CryptoJS.SHA256(encrypted).toString();
                    const dataKey = `GEO_${dataHash.slice(0, 8)}-${dataHash.slice(8, 16)}-${dataHash.slice(16, 24)}`;
                    await db.put('data', {
                        dataKey,
                        profileKey: currentProfileKey,
                        fileName: file.name,
                        size: sizeMB,
                        encryptedData: encrypted,
                        isText: false
                    });
                    totalUsedMB += sizeMB;
                    log(`File "${file.name}" uploaded. Key: ${dataKey}`);
                } catch (err) {
                    log(`ERROR: ${err.message}`);
                }
            };
            fileInput.click();
        }

        // View uploads
        async function viewUploads() {
            if (!currentProfileKey) {
                log('ERROR: No profile selected. Use PROFILE to create one.');
                return;
            }
            try {
                const db = await dbPromise;
                const profile = await db.get('profiles', currentProfileKey);
                if (!profile) {
                    log('ERROR: Invalid profile key.');
                    return;
                }
                const dataItems = await db.getAll('data');
                const userData = dataItems.filter(d => d.profileKey === currentProfileKey);
                if (userData.length === 0) {
                    log('No uploads found.');
                    return;
                }
                log('Uploads:');
                userData.forEach((item, index) => {
                    log(`[${index + 1}] ${item.fileName} (${item.size.toFixed(3)} MB) Key: ${item.dataKey}`);
                });
            } catch (err) {
                log(`ERROR: ${err.message}`);
            }
        }

        // Storage info
        async function storageInfo() {
            if (!currentProfileKey) {
                log('ERROR: No profile selected. Use PROFILE to create one.');
                return;
            }
            try {
                const db = await dbPromise;
                const profile = await db.get('profiles', currentProfileKey);
                if (!profile) {
                    log('ERROR: Invalid profile key.');
                    return;
                }
                const dataItems = await db.getAll('data');
                const userData = dataItems.filter(d => d.profileKey === currentProfileKey);
                totalUsedMB = 0.001; // Profile size
                userData.forEach(d => totalUsedMB += d.size || 0);
                log(`Storage Info:
Browser: ${browser.chrome ? 'Chrome' : browser.firefox ? 'Firefox' : browser.safari ? 'Safari' : 'Unknown'}
Max per key: ${MAX_PER_KEY_MB} MB
Total used: ${totalUsedMB.toFixed(3)} MB
Remaining: ${(MAX_TOTAL_MB - totalUsedMB).toFixed(3)} MB of ${MAX_TOTAL_MB} MB`);
            } catch (err) {
                log(`ERROR: ${err.message}`);
            }
        }

        // Delete upload by number
        async function deleteUpload(number) {
            if (!currentProfileKey) {
                log('ERROR: No profile selected. Use PROFILE to create one.');
                return;
            }
            try {
                const db = await dbPromise;
                const profile = await db.get('profiles', currentProfileKey);
                if (!profile) {
                    log('ERROR: Invalid profile key.');
                    return;
                }
                const dataItems = await db.getAll('data');
                const userData = dataItems.filter(d => d.profileKey === currentProfileKey);
                const index = parseInt(number) - 1;
                if (isNaN(index) || index < 0 || index >= userData.length) {
                    log(`ERROR: Invalid upload number. Use VIEW to see upload numbers.`);
                    return;
                }
                const item = userData[index];
                totalUsedMB -= item.size;
                await db.delete('data', item.dataKey);
                log(`Upload "${item.fileName}" deleted.`);
            } catch (err) {
                log(`ERROR: ${err.message}`);
            }
        }

        // Download upload by number
        async function downloadUpload(number) {
            if (!currentProfileKey) {
                log('ERROR: No profile selected. Use PROFILE to create one.');
                return;
            }
            try {
                const db = await dbPromise;
                const profile = await db.get('profiles', currentProfileKey);
                if (!profile) {
                    log('ERROR: Invalid profile key.');
                    return;
                }
                const dataItems = await db.getAll('data');
                const userData = dataItems.filter(d => d.profileKey === currentProfileKey);
                const index = parseInt(number) - 1;
                if (isNaN(index) || index < 0 || index >= userData.length) {
                    log(`ERROR: Invalid upload number. Use VIEW to see upload numbers.`);
                    return;
                }
                const data = userData[index];
                const aesKey = CryptoJS.SHA256(currentProfileKey).toString();
                const decrypted = CryptoJS.AES.decrypt(data.encryptedData, aesKey);
                const blob = new Blob([decrypted.toString(CryptoJS.enc.Latin1)], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = data.fileName;
                a.click();
                URL.revokeObjectURL(url);
                log(`File "${data.fileName}" downloaded.`);
            } catch (err) {
                log(`ERROR: ${err.message}`);
            }
        }

        // Drive popup
        async function openDrive() {
            const profileKey = prompt('Enter your profile key:');
            if (!profileKey) {
                log('ERROR: Profile key required.');
                return;
            }
            try {
                const db = await dbPromise;
                const profile = await db.get('profiles', profileKey);
                if (!profile) {
                    log('ERROR: Invalid profile key.');
                    return;
                }
                currentProfileKey = profileKey;
                const dataItems = await db.getAll('data');
                const userData = dataItems.filter(d => d.profileKey === profileKey);
                totalUsedMB = 0.001; // Profile size
                userData.forEach(d => totalUsedMB += d.size || 0);

                const popup = window.open('', 'GeoDrive', 'width=600,height=600');
                popup.document.write(`
                    <!DOCTYPE html>
                    <html lang="en">
                    <head>
                        <meta charset="UTF-8">
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                        <title>GeoDrive - Drive Management</title>
                        <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
                        <script src="https://cdnjs.cloudflare.com/ajax/libs/idb/7.1.1/umd.min.js"></script>
                        <style>
                            * {
                                margin: 0;
                                padding: 0;
                                box-sizing: border-box;
                                font-family: 'Courier New', monospace;
                            }
                            body {
                                background: #000;
                                color: #00ff00;
                                padding: 10px;
                                text-align: center;
                            }
                            h1 {
                                font-size: 24pt;
                                text-shadow: 0 0 5px #00ff00;
                                margin-bottom: 10px;
                            }
                            .container {
                                max-width: 500px;
                                margin: auto;
                                padding: 10px;
                                border: 1px solid #00ff00;
                                border-radius: 5px;
                                box-shadow: 0 0 10px #00ff00;
                                background: rgba(0, 255, 0, 0.1);
                            }
                            input, button {
                                width: 100%;
                                margin: 5px 0;
                                padding: 5px;
                                background: #000;
                                color: #00ff00;
                                border: 1px solid #00ff00;
                                border-radius: 3px;
                                font-size: 12px;
                            }
                            button {
                                cursor: pointer;
                                font-weight: bold;
                            }
                            button:hover {
                                background: #00ff00;
                                color: #000;
                            }
                            table {
                                width: 100%;
                                border-collapse: collapse;
                                margin: 10px 0;
                            }
                            th, td {
                                border: 1px solid #00ff00;
                                padding: 5px;
                                text-align: left;
                                font-size: 12px;
                            }
                            th {
                                background: #00ff00;
                                color: #000;
                            }
                            #output {
                                margin-top: 10px;
                                font-size: 12px;
                                word-wrap: break-word;
                            }
                            @media (max-width: 480px) {
                                h1 {
                                    font-size: 18pt;
                                }
                                .container {
                                    padding: 5px;
                                }
                                input, button, th, td {
                                    font-size: 10px;
                                    padding: 3px;
                                }
                            }
                        </style>
                    </head>
                    <body>
                        <h1>GeoDrive - Drive Management</h1>
                        <div class="container">
                            <h2>Upload File</h2>
                            <input type="file" id="fileInput" accept="*/*">
                            <button onclick="storeFile()">Upload</button>
                            <h2>Uploads</h2>
                            <table>
                                <thead>
                                    <tr>
                                        <th>#</th>
                                        <th>File Name</th>
                                        <th>Size (MB)</th>
                                        <th>Action</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${userData.map((d, i) => `
                                        <tr>
                                            <td>${i + 1}</td>
                                            <td>${d.fileName}</td>
                                            <td>${d.size.toFixed(3)}</td>
                                            <td>
                                                <button onclick="downloadFile('${d.dataKey}', '${d.fileName}')">Download</button>
                                                <button onclick="deleteFile('${d.dataKey}', '${d.fileName}')">Delete</button>
                                            </td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                            <h2>Storage Info</h2>
                            <div id="storageInfo">
                                Browser: ${browser.chrome ? 'Chrome' : browser.firefox ? 'Firefox' : browser.safari ? 'Safari' : 'Unknown'}<br>
                                Max per key: ${MAX_PER_KEY_MB} MB<br>
                                Total used: ${totalUsedMB.toFixed(3)} MB<br>
                                Remaining: ${(MAX_TOTAL_MB - totalUsedMB).toFixed(3)} MB of ${MAX_TOTAL_MB} MB
                            </div>
                            <div id="output"></div>
                        </div>
                        <script>
                            const dbPromise = idb.openDB('GeoDriveDB', 1);
                            let totalUsedMB = ${totalUsedMB};

                            async function storeFile() {
                                const fileInput = document.getElementById('fileInput').files[0];
                                const output = document.getElementById('output');
                                if (!fileInput) {
                                    output.textContent = 'ERROR: No file selected.';
                                    return;
                                }
                                try {
                                    const data = await fileInput.arrayBuffer();
                                    const sizeMB = data.byteLength / (1024 * 1024);
                                    if (sizeMB > ${MAX_PER_KEY_MB}) {
                                        output.textContent = \`ERROR: File size (\${sizeMB.toFixed(3)} MB) exceeds limit (${MAX_PER_KEY_MB} MB).\`;
                                        return;
                                    }
                                    if (totalUsedMB + sizeMB > ${MAX_TOTAL_MB}) {
                                        output.textContent = \`ERROR: Not enough storage (\${(${MAX_TOTAL_MB} - totalUsedMB).toFixed(3)} MB left).\`;
                                        return;
                                    }
                                    const aesKey = CryptoJS.SHA256('${profileKey}').toString();
                                    const wordArray = CryptoJS.lib.WordArray.create(data);
                                    const encrypted = CryptoJS.AES.encrypt(wordArray, aesKey).toString();
                                    const dataHash = CryptoJS.SHA256(encrypted).toString();
                                    const dataKey = \`GEO_\${dataHash.slice(0, 8)}-\${dataHash.slice(8, 16)}-\${dataHash.slice(16, 24)}\`;
                                    const db = await dbPromise;
                                    await db.put('data', {
                                        dataKey,
                                        profileKey: '${profileKey}',
                                        fileName: fileInput.name,
                                        size: sizeMB,
                                        encryptedData: encrypted,
                                        isText: false
                                    });
                                    totalUsedMB += sizeMB;
                                    output.textContent = \`File "\${fileInput.name}" uploaded. Key: \${dataKey}\`;
                                    updateTable();
                                } catch (err) {
                                    output.textContent = \`ERROR: \${err.message}\`;
                                }
                            }

                            async function downloadFile(dataKey, fileName) {
                                try {
                                    const db = await dbPromise;
                                    const data = await db.get('data', dataKey);
                                    if (!data) {
                                        document.getElementById('output').textContent = 'ERROR: Invalid data key.';
                                        return;
                                    }
                                    const aesKey = CryptoJS.SHA256('${profileKey}').toString();
                                    const decrypted = CryptoJS.AES.decrypt(data.encryptedData, aesKey);
                                    const blob = new Blob([decrypted.toString(CryptoJS.enc.Latin1)], { type: 'application/octet-stream' });
                                    const url = URL.createObjectURL(blob);
                                    const a = document.createElement('a');
                                    a.href = url;
                                    a.download = fileName;
                                    a.click();
                                    URL.revokeObjectURL(url);
                                    document.getElementById('output').textContent = \`File "\${fileName}" downloaded.\`;
                                } catch (err) {
                                    document.getElementById('output').textContent = \`ERROR: \${err.message}\`;
                                }
                            }

                            async function deleteFile(dataKey, fileName) {
                                try {
                                    const db = await dbPromise;
                                    const data = await db.get('data', dataKey);
                                    if (!data) {
                                        document.getElementById('output').textContent = 'ERROR: Invalid data key.';
                                        return;
                                    }
                                    totalUsedMB -= data.size;
                                    await db.delete('data', dataKey);
                                    document.getElementById('output').textContent = \`File "\${fileName}" deleted.\`;
                                    updateTable();
                                } catch (err) {
                                    document.getElementById('output').textContent = \`ERROR: \${err.message}\`;
                                }
                            }

                            async function updateTable() {
                                const db = await dbPromise;
                                const dataItems = await db.getAll('data');
                                const userData = dataItems.filter(d => d.profileKey === '${profileKey}');
                                totalUsedMB = 0.001;
                                userData.forEach(d => totalUsedMB += d.size || 0);
                                const tbody = document.querySelector('tbody');
                                tbody.innerHTML = userData.map((d, i) => \`
                                    <tr>
                                        <td>\${i + 1}</td>
                                        <td>\${d.fileName}</td>
                                        <td>\${d.size.toFixed(3)}</td>
                                        <td>
                                            <button onclick="downloadFile('\${d.dataKey}', '\${d.fileName}')">Download</button>
                                            <button onclick="deleteFile('\${d.dataKey}', '\${d.fileName}')">Delete</button>
                                        </td>
                                    </tr>
                                \`).join('');
                                document.getElementById('storageInfo').innerHTML = \`
                                    Browser: ${browser.chrome ? 'Chrome' : browser.firefox ? 'Firefox' : browser.safari ? 'Safari' : 'Unknown'}<br>
                                    Max per key: ${MAX_PER_KEY_MB} MB<br>
                                    Total used: \${totalUsedMB.toFixed(3)} MB<br>
                                    Remaining: \${(${MAX_TOTAL_MB} - totalUsedMB).toFixed(3)} MB of ${MAX_TOTAL_MB} MB
                                \`;
                            }
                        </script>
                    </body>
                    </html>
                `);
                log(`Drive opened for profile ${profileKey}.`);
            } catch (err) {
                log(`ERROR: ${err.message}`);
            }
        }

        // Process command
        async function processCommand() {
            const input = document.getElementById('commandInput').value.trim().toUpperCase();
            if (!input) return;
            document.getElementById('commandInput').value = '';

            if (deleteConfirmationPending) {
                if (input === 'DELETE DRIVE Y') {
                    await deleteProfile(true);
                } else if (input === 'DELETE DRIVE N') {
                    log('Profile deletion cancelled.');
                    deleteConfirmationPending = false;
                } else {
                    log('ERROR: Please confirm with DELETE DRIVE Y or DELETE DRIVE N.');
                }
                return;
            }

            const [cmd, arg] = input.split(' ', 2);
            switch (cmd) {
                case 'PROFILE':
                    await createProfile();
                    break;
                case 'DRIVE':
                    await openDrive();
                    break;
                case 'DELETE':
                    if (arg === 'DRIVE') {
                        await deleteProfile(false);
                    } else if (arg && !isNaN(arg)) {
                        await deleteUpload(arg);
                    } else {
                        log('ERROR: Use DELETE DRIVE or DELETE [number].');
                    }
                    break;
                case 'UPLOAD':
                    await uploadFile();
                    break;
                case 'VIEW':
                    await viewUploads();
                    break;
                case 'SPACE':
                    await storageInfo();
                    break;
                case 'DOWNLOAD':
                    if (arg && !isNaN(arg)) {
                        await downloadUpload(arg);
                    } else {
                        log('ERROR: Use DOWNLOAD [number].');
                    }
                    break;
                case 'HELP':
                    log(helpText);
                    break;
                default:
                    log('ERROR: Unknown command. Type HELP for commands.');
            }
        }

        // Clear console
        function clearConsole() {
            consoleDiv.innerHTML = '';
            log(helpText);
        }
    </script>
</body>
</html>
