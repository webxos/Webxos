<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Locker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #000000;
            font-family: 'Courier New', monospace;
            color: #00ff00;
            min-height: 100vh;
        }
        .app-container {
            width: 100%;
            max-width: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 0;
            position: relative;
        }
        .hologram-container {
            width: 220px;
            height: 180px;
            position: relative;
            overflow: hidden;
            z-index: 1;
        }
        canvas {
            width: 220px;
            height: 180px;
        }
        .button-container {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            z-index: 1;
        }
        .btn {
            padding: 8px 14px;
            font-size: 12px;
            color: #000000;
            background: #00ff00;
            border: none;
            cursor: pointer;
        }
        .console-section {
            width: 100%;
            max-width: 200px;
            margin: 10px 0;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 0;
        }
        .console-section textarea {
            width: 180%;
            height: 1200%;
            padding: 10px;
            background: #000000;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            box-sizing: border-box;
            resize: none;
            margin-top: 10px;
            margin-left: -80px;
            margin-right: -80px;
        }
        .console-section button {
            padding: 6px 12px;
            background: #00ff00;
            color: #000000;
            border: none;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
        }
        .console-section #consoleOutput {
            margin-top: 5px;
            font-size: 12px;
            color: #00ff00;
            word-wrap: break-word;
        }
        .file-upload {
            margin-top: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .file-upload input[type="file"] {
            display: none;
        }
        .file-upload label {
            padding: 6px 12px;
            background: #00ff00;
            color: #000000;
            border: none;
            cursor: pointer;
            font-size: 12px;
            display: inline-block;
        }
        .file-upload span {
            font-size: 12px;
            color: #00ff00;
        }
        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 180px;
            padding: 12px;
            background: #000000;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 1000;
        }
        .popup h3 {
            margin: 0 0 10px;
            font-size: 14px;
        }
        .popup input {
            width: 100%;
            padding: 6px;
            background: #000000;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-bottom: 8px;
        }
        .popup .btn {
            width: 100%;
            margin: 5px 0 0;
            padding: 8px 14px;
        }
        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }
        footer {
            width: 100%;
            max-width: 200px;
            text-align: center;
            font-size: 10px;
            color: #00ff00;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="hologram-container">
            <canvas id="hologram"></canvas>
        </div>
        <div class="console-section">
            <textarea id="consoleInput" placeholder="Enter message"></textarea>
            <div class="file-upload">
                <label for="fileInput" class="btn">Upload File</label>
                <input type="file" id="fileInput">
                <span id="fileName"></span>
            </div>
            <button onclick="clearConsole()">Clear</button>
            <div id="consoleOutput"></div>
        </div>
        <div class="button-container">
            <button class="btn" onclick="generateGrid()">Generate</button>
            <button class="btn" onclick="copyCode()">Copy</button>
            <button class="btn" onclick="showExecutePopup()">Execute</button>
        </div>
    </div>

    <div class="popup-overlay" id="executeOverlay"></div>
    <div class="popup" id="executePopup">
        <h3>Execute Grid</h3>
        <input type="text" id="executeInput" placeholder="Enter serial (e.g., HOLO-000001-A7K)">
        <button class="btn" onclick="executeGrid()">Submit</button>
        <button class="btn" onclick="closeExecutePopup()">Cancel</button>
    </div>

    <footer>
        © WebXOS 2025<br>
        Usage: Generate embeds encrypted message and file in grid CSS with 64 neural dots, rotations, and color schemes, regenerable from serial code. Copy saves serial. Execute loads grid and decodes CSS to retrieve data. Use at your own Risk.
    </footer>

    <script>
        const canvas = document.getElementById('hologram');
        const consoleInput = document.getElementById('consoleInput');
        const consoleOutput = document.getElementById('consoleOutput');
        const fileInput = document.getElementById('fileInput');
        const fileNameDisplay = document.getElementById('fileName');
        const executePopup = document.getElementById('executePopup');
        const executeOverlay = document.getElementById('executeOverlay');
        const executeInput = document.getElementById('executeInput');
        let currentSerial = '';
        let currentCode = '';
        let currentFile = null;

        // WebGL Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 220 / 180, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
        renderer.setSize(220, 180);
        camera.position.z = 200;

        function hashCode(str) {
            let hash = 2166136261;
            for (let i = 0; i < str.length; i++) {
                hash ^= str.charCodeAt(i);
                hash = (hash * 16777619) >>> 0;
            }
            return hash;
        }

        function generateCrypticCode() {
            const glyphs = 'ΔΩΨΘΣΦΩΓΛΞΠΩ0123456789#@&%*+-=><';
            let code = '';
            for (let i = 0; i < 9; i++) {
                code += glyphs.charAt(Math.floor(Math.random() * glyphs.length));
            }
            return `Ω-CODE: ${code}`;
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            else if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function sanitizeFileName(name) {
            return name.replace(/[^a-zA-Z0-9._-]/g, '_');
        }

        function encodeDate(date) {
            const dateStr = date.toISOString().slice(0, 10);
            const binary = Array.from(dateStr).map(c => c.charCodeAt(0).toString(2).padStart(8, '0')).join('');
            return binary.padEnd(64, '0').slice(0, 64).split('').map(Number);
        }

        async function encryptData(message, file, serial, date) {
            const datePattern = encodeDate(date);
            const data = { message: message || '', date: datePattern };
            if (file) {
                const maxSize = 12 * 1024 * 1024 * 1024;
                if (file.size > maxSize) throw new Error(`File too large! Max: ${formatFileSize(maxSize)}.`);
                const arrayBuffer = await file.arrayBuffer();
                data.file = {
                    name: sanitizeFileName(file.name),
                    type: file.type,
                    size: file.size,
                    data: Array.from(new Uint8Array(arrayBuffer))
                };
            }
            const jsonString = JSON.stringify(data);
            const encrypted = CryptoJS.AES.encrypt(jsonString, serial).toString();
            const compressed = pako.gzip(encrypted);
            return compressed;
        }

        async function decryptData(compressed, serial) {
            const decompressed = pako.ungzip(compressed);
            const encryptedString = new TextDecoder().decode(decompressed);
            const decrypted = CryptoJS.AES.decrypt(encryptedString, serial);
            const jsonString = decrypted.toString(CryptoJS.enc.Utf8);
            return JSON.parse(jsonString);
        }

        function encodeDataInCSS(compressedData, date, serial) {
            const bytes = Array.from(compressedData);
            const properties = [];
            let byteIndex = 0;
            const datePattern = encodeDate(date);
            const seed = hashCode(serial);
            let hashIndex = 0;

            const rand = (min, max) => {
                const value = min + ((seed + hashIndex++) % 1000000) / 1000000 * (max - min);
                return value;
            };

            for (let i = 0; i < 2000000 && byteIndex < bytes.length; i++) {
                const props = { neuralDots: [], connections: [], rotations: {}, keyframes: [] };
                const system = Math.floor(i / 250000) + 1;
                const type = `grid-system-${system}`;
                const zIndex = (i % 250000) * 0.001 - 125;

                // Grid Properties (100 bytes)
                props.rotateX = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 360 : rand(0, 360);
                props.rotateY = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 360 : rand(0, 360);
                props.rotateZ = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 360 : rand(0, 360);
                props.translateX = byteIndex < bytes.length ? -50 + (bytes[byteIndex++] / 255) * 100 : rand(-50, 50);
                props.translateY = byteIndex < bytes.length ? -50 + (bytes[byteIndex++] / 255) * 100 : rand(-50, 50);
                props.translateZ = byteIndex < bytes.length ? zIndex + (bytes[byteIndex++] / 255) * 5 : zIndex + rand(0, 5);
                props.scale = byteIndex < bytes.length ? 0.5 + (bytes[byteIndex++] / 255) * 1 : rand(0.5, 1.5);
                props.skewX = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 30 : rand(0, 30);
                props.skewY = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 30 : rand(0, 30);
                props.opacity = byteIndex < bytes.length ? bytes[byteIndex++] / 255 : rand(0.1, 1);
                props.colorR = byteIndex < bytes.length ? bytes[byteIndex++] % 50 : rand(0, 50);
                props.colorG = system % 2 === 1 ? (byteIndex < bytes.length ? 200 + (bytes[byteIndex++] % 56) : rand(200, 255)) : (byteIndex < bytes.length ? bytes[byteIndex++] % 50 : rand(0, 50));
                props.colorB = system % 2 === 1 ? (byteIndex < bytes.length ? bytes[byteIndex++] % 50 : rand(0, 50)) : (byteIndex < bytes.length ? 200 + (bytes[byteIndex++] % 56) : rand(200, 255));
                props.borderColorR = byteIndex < bytes.length ? bytes[byteIndex++] % 50 : rand(0, 50);
                props.borderColorG = system % 2 === 1 ? (byteIndex < bytes.length ? 200 + (bytes[byteIndex++] % 56) : rand(200, 255)) : (byteIndex < bytes.length ? bytes[byteIndex++] % 50 : rand(0, 50));
                props.borderColorB = system % 2 === 1 ? (byteIndex < bytes.length ? bytes[byteIndex++] % 50 : rand(0, 50)) : (byteIndex < bytes.length ? 200 + (bytes[byteIndex++] % 56) : rand(200, 255));
                props.width = system === 5 ? (byteIndex < bytes.length ? 20 + (bytes[byteIndex++] % 80) : rand(20, 100)) : 180;
                props.height = system === 5 ? (byteIndex < bytes.length ? 20 + (bytes[byteIndex++] % 80) : rand(20, 100)) : 180;
                props.left = system === 5 ? (byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 100 : rand(0, 100)) : 0;
                props.top = system === 5 ? (byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 100 : rand(0, 100)) : 0;
                props.gradientAngle = (system === 1 || system === 6) ? (byteIndex < bytes.length ? bytes[byteIndex++] % 360 : rand(0, 360)) : 0;
                props.gradientSpacing = (system === 1 || system === 6) ? (byteIndex < bytes.length ? 8 + (bytes[byteIndex++] % 4) : rand(8, 12)) : 0;
                props.borderWidth = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 5 : rand(0, 5);
                props.margin = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 10 : rand(0, 10);
                props.padding = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 10 : rand(0, 10);
                props.animationDelay = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 5 : rand(0, 5);
                props.blur = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 5 : rand(0, 5);
                props.brightness = byteIndex < bytes.length ? 0.8 + (bytes[byteIndex++] / 255) * 0.4 : rand(0.8, 1.2);
                props.contrast = byteIndex < bytes.length ? 0.8 + (bytes[byteIndex++] / 255) * 0.4 : rand(0.8, 1.2);
                props.pseudoBefore = String.fromCharCode(...Array(8).fill().map(() => byteIndex < bytes.length ? 65 + (bytes[byteIndex++] % 26) : rand(65, 90)));
                props.pseudoAfter = String.fromCharCode(...Array(8).fill().map(() => byteIndex < bytes.length ? 65 + (bytes[byteIndex++] % 26) : rand(65, 90)));
                props.className = `data-${Array(10).fill().map(() => (byteIndex < bytes.length ? bytes[byteIndex++] % 16 : rand(0, 15)).toString(16)).join('')}`;

                // Neural Dots (768 bytes)
                for (let j = 0; j < 64; j++) {
                    const dot = {};
                    dot.x = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 180 : ((j % 8) * 22.5);
                    dot.y = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 180 : (Math.floor(j / 8) * 22.5);
                    dot.z = zIndex + (byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 5 : rand(0, 5));
                    dot.colorR = byteIndex < bytes.length ? bytes[byteIndex++] % 50 : rand(0, 50);
                    dot.colorG = system % 2 === 1 ? (byteIndex < bytes.length ? 200 + (bytes[byteIndex++] % 56) : rand(200, 255)) : (byteIndex < bytes.length ? bytes[byteIndex++] % 50 : rand(0, 50));
                    dot.colorB = system % 2 === 1 ? (byteIndex < bytes.length ? bytes[byteIndex++] % 50 : rand(0, 50)) : (byteIndex < bytes.length ? 200 + (bytes[byteIndex++] % 56) : rand(200, 255));
                    dot.opacity = byteIndex < bytes.length ? bytes[byteIndex++] / 255 : datePattern[j % 64];
                    dot.animX = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 10 : rand(0, 10);
                    dot.animY = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 10 : rand(0, 10);
                    dot.animZ = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 10 : rand(0, 10);
                    dot.animOpacity = byteIndex < bytes.length ? bytes[byteIndex++] / 255 : rand(0.1, 1);
                    dot.animDuration = byteIndex < bytes.length ? 1 + (bytes[byteIndex++] % 5) : rand(1, 6);
                    dot.animDelay = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 2 : rand(0, 2);
                    props.neuralDots.push(dot);
                }

                // Connections (72 bytes)
                for (let j = 0; j < 64; j++) {
                    for (let k = j + 1; k < Math.min(j + 9, 64); k++) {
                        if (props.connections.length < 512 && byteIndex < bytes.length) {
                            const angle = (bytes[byteIndex++] % 16) * (360 / 16);
                            props.connections.push({ from: j, to: k, angle });
                        }
                    }
                }

                // Rotations (20 bytes)
                props.rotationX = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 90 : rand(0, 90);
                props.rotationY = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 90 : rand(0, 90);
                props.rotationZ = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 90 : rand(0, 90);
                props.rotationSpeed = byteIndex < bytes.length ? 5 + (bytes[byteIndex++] % 10) : rand(5, 15);
                props.keyframe1 = byteIndex < bytes.length ? bytes[byteIndex++] % 100 : rand(0, 100);
                props.keyframe2 = byteIndex < bytes.length ? bytes[byteIndex++] % 100 : rand(0, 100);

                // Keyframes (500 bytes)
                for (let k = 0; k < 10; k++) {
                    const kf = {};
                    kf.percentage = byteIndex < bytes.length ? bytes[byteIndex++] % 100 : rand(0, 100);
                    kf.rotateX = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 360 : rand(0, 360);
                    kf.rotateY = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 360 : rand(0, 360);
                    kf.translateZ = byteIndex < bytes.length ? (bytes[byteIndex++] / 255) * 20 : rand(0, 20);
                    kf.opacity = byteIndex < bytes.length ? bytes[byteIndex++] / 255 : rand(0.1, 1);
                    props.keyframes.push(kf);
                }

                props.type = type;
                props.className = `grid-element-${i}`;
                properties.push(props);
            }

            return properties;
        }

        function decodeDataFromCSS(properties) {
            const bytes = [];

            properties.forEach((props, index) => {
                // Grid Properties
                bytes.push(Math.round((props.rotateX / 360) * 255));
                bytes.push(Math.round((props.rotateY / 360) * 255));
                bytes.push(Math.round((props.rotateZ / 360) * 255));
                bytes.push(Math.round(((props.translateX + 50) / 100) * 255));
                bytes.push(Math.round(((props.translateY + 50) / 100) * 255));
                bytes.push(Math.round(((props.translateZ - ((index % 250000) * 0.001 - 125)) / 5) * 255));
                bytes.push(Math.round(((props.scale - 0.5) / 1) * 255));
                bytes.push(Math.round((props.skewX / 30) * 255));
                bytes.push(Math.round((props.skewY / 30) * 255));
                bytes.push(Math.round(props.opacity * 255));
                bytes.push(props.colorR);
                bytes.push(props.colorG);
                bytes.push(props.colorB);
                bytes.push(props.borderColorR);
                bytes.push(props.borderColorG);
                bytes.push(props.borderColorB);
                if (props.type === 'grid-system-5') {
                    bytes.push(Math.round(props.width - 20));
                    bytes.push(Math.round(props.height - 20));
                    bytes.push(Math.round((props.left / 100) * 255));
                    bytes.push(Math.round((props.top / 100) * 255));
                }
                if (props.type === 'grid-system-1' || props.type === 'grid-system-6') {
                    bytes.push(props.gradientAngle);
                    bytes.push(Math.round(props.gradientSpacing - 8));
                }
                bytes.push(Math.round((props.borderWidth / 5) * 255));
                bytes.push(Math.round((props.margin / 10) * 255));
                bytes.push(Math.round((props.padding / 10) * 255));
                bytes.push(Math.round((props.animationDelay / 5) * 255));
                bytes.push(Math.round((props.blur / 5) * 255));
                bytes.push(Math.round(((props.brightness - 0.8) / 0.4) * 255));
                bytes.push(Math.round(((props.contrast - 0.8) / 0.4) * 255));
                for (let i = 0; i < 8; i++) bytes.push(props.pseudoBefore.charCodeAt(i) - 65);
                for (let i = 0; i < 8; i++) bytes.push(props.pseudoAfter.charCodeAt(i) - 65);
                const classMatch = props.className.match(/data-([0-9a-f]+)/);
                if (classMatch) {
                    const hex = classMatch[1];
                    for (let i = 0; i < hex.length; i += 2) {
                        bytes.push(parseInt(hex.slice(i, i + 2), 16));
                    }
                }

                // Neural Dots
                props.neuralDots.forEach(dot => {
                    bytes.push(Math.round((dot.x / 180) * 255));
                    bytes.push(Math.round((dot.y / 180) * 255));
                    bytes.push(Math.round((dot.z - ((index % 250000) * 0.001 - 125)) / 5 * 255));
                    bytes.push(dot.colorR);
                    bytes.push(dot.colorG);
                    bytes.push(dot.colorB);
                    bytes.push(Math.round(dot.opacity * 255));
                    bytes.push(Math.round((dot.animX / 10) * 255));
                    bytes.push(Math.round((dot.animY / 10) * 255));
                    bytes.push(Math.round((dot.animZ / 10) * 255));
                    bytes.push(Math.round(dot.animOpacity * 255));
                    bytes.push(Math.round(dot.animDuration - 1));
                    bytes.push(Math.round((dot.animDelay / 2) * 255));
                });

                // Connections
                props.connections.forEach(conn => {
                    bytes.push(Math.round((conn.angle / 360) * 16));
                });

                // Rotations
                bytes.push(Math.round((props.rotationX / 90) * 255));
                bytes.push(Math.round((props.rotationY / 90) * 255));
                bytes.push(Math.round((props.rotationZ / 90) * 255));
                bytes.push(Math.round((props.rotationSpeed - 5) / 10 * 255));
                bytes.push(props.keyframe1);
                bytes.push(props.keyframe2);

                // Keyframes
                props.keyframes.forEach(kf => {
                    bytes.push(kf.percentage);
                    bytes.push(Math.round((kf.rotateX / 360) * 255));
                    bytes.push(Math.round((kf.rotateY / 360) * 255));
                    bytes.push(Math.round((kf.translateZ / 20) * 255));
                    bytes.push(Math.round(kf.opacity * 255));
                });
            });

            return new Uint8Array(bytes);
        }

        function generateSerialNumber() {
            const counter = Math.floor(Math.random() * 1000000).toString().padStart(6, '0');
            const suffix = Math.random().toString(36).substr(2, 3).toUpperCase();
            return `HOLO-${counter}-${suffix}`;
        }

        function generateImageFromSeed(serial, properties, date) {
            scene.clear();

            const gridBaseGeo = new THREE.PlaneGeometry(180, 180);
            const gridBaseMat = new THREE.MeshBasicMaterial({
                color: 0x00cc00,
                opacity: 0.5,
                transparent: true
            });
            const gridBase = new THREE.Mesh(gridBaseGeo, gridBaseMat);
            scene.add(gridBase);

            const dotGeometry = new THREE.BufferGeometry();
            const dotPositions = [];
            const dotColors = [];
            const lineGeometry = new THREE.BufferGeometry();
            const linePositions = [];

            properties.forEach((props, index) => {
                const system = parseInt(props.type.split('-')[2]);
                const color = new THREE.Color(`rgb(${props.colorR},${props.colorG},${props.colorB})`);
                const planeGeo = new THREE.PlaneGeometry(props.width, props.height);
                const planeMat = new THREE.MeshBasicMaterial({
                    color,
                    opacity: props.opacity,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                const plane = new THREE.Mesh(planeGeo, planeMat);
                plane.position.set(
                    props.translateX + (props.left || 0) * 1.8,
                    props.translateY + (props.top || 0) * 1.8,
                    props.translateZ
                );
                plane.rotation.set(
                    props.rotateX * Math.PI / 180,
                    props.rotateY * Math.PI / 180,
                    props.rotateZ * Math.PI / 180
                );
                plane.scale.set(props.scale, props.scale, props.scale);
                scene.add(plane);

                // Neural Dots
                props.neuralDots.forEach(dot => {
                    dotPositions.push(dot.x - 90, dot.y - 90, dot.z);
                    dotColors.push(dot.colorR / 255, dot.colorG / 255, dot.colorB / 255);
                });

                // Connections
                props.connections.forEach(conn => {
                    const from = props.neuralDots[conn.from];
                    const to = props.neuralDots[conn.to];
                    linePositions.push(from.x - 90, from.y - 90, from.z);
                    linePositions.push(to.x - 90, to.y - 90, to.z);
                });
            });

            dotGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dotPositions, 3));
            dotGeometry.setAttribute('color', new THREE.Float32BufferAttribute(dotColors, 3));
            const dotMaterial = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true
            });
            const dots = new THREE.Points(dotGeometry, dotMaterial);
            scene.add(dots);

            lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0x00ff00,
                opacity: 0.3,
                transparent: true
            });
            const lines = new THREE.LineSegments(lineGeometry, lineMaterial);
            scene.add(lines);

            function animate() {
                requestAnimationFrame(animate);
                scene.rotation.y += 0.01;
                renderer.render(scene, camera);
            }
            animate();
        }

        async function generateGrid() {
            try {
                const message = consoleInput.value;
                const file = fileInput.files[0];
                if (file) fileNameDisplay.textContent = `${file.name} (${formatFileSize(file.size)})`;
                else fileNameDisplay.textContent = '';

                const serial = generateSerialNumber();
                const date = new Date();
                const compressedData = await encryptData(message, file, serial, date);
                const cssProperties = encodeDataInCSS(compressedData, date, serial);

                currentSerial = serial;
                currentCode = generateCrypticCode();
                consoleOutput.textContent = `Serial: ${serial}\nCode: ${currentCode}\nData embedded in grid.`;
                generateImageFromSeed(serial, cssProperties, date);
            } catch (e) {
                consoleOutput.textContent = 'Error: ' + e.message;
            }
        }

        function copyCode() {
            if (currentSerial && currentCode) {
                const text = `Serial: ${currentSerial}\nCode: ${currentCode}`;
                navigator.clipboard.writeText(text).then(() => {
                    consoleOutput.textContent = 'Serial and code copied to clipboard!';
                }).catch(err => {
                    consoleOutput.textContent = 'Error copying to clipboard: ' + err;
                });
            } else {
                consoleOutput.textContent = 'No grid generated yet!';
            }
        }

        function showExecutePopup() {
            executePopup.style.display = 'block';
            executeOverlay.style.display = 'block';
            executeInput.value = '';
        }

        function closeExecutePopup() {
            executePopup.style.display = 'none';
            executeOverlay.style.display = 'none';
        }

        async function executeGrid() {
            const serial = executeInput.value.trim();
            if (!serial) {
                consoleOutput.textContent = 'Please enter a serial number.';
                return;
            }

            try {
                const date = new Date();
                const properties = encodeDataInCSS(new Uint8Array(), date, serial); // Regenerate from serial
                const bytes = decodeDataFromCSS(properties);
                const data = await decryptData(bytes, serial);
                consoleOutput.textContent = `Message: ${data.message}\nDate: ${new Date(data.date.join('')).toISOString().slice(0, 10)}`;
                if (data.file) {
                    consoleOutput.textContent += `\nFile: ${data.file.name} (${formatFileSize(data.file.size)})`;
                    const blob = new Blob([new Uint8Array(data.file.data)], { type: data.file.type });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = data.file.name;
                    a.click();
                    URL.revokeObjectURL(url);
                }
                closeExecutePopup();
            } catch (e) {
                consoleOutput.textContent = 'Error executing grid: ' + e.message;
            }
        }

        function clearConsole() {
            consoleInput.value = '';
            consoleOutput.textContent = '';
            fileInput.value = '';
            fileNameDisplay.textContent = '';
            scene.clear();
            currentSerial = '';
            currentCode = '';
            currentFile = null;
        }

        fileInput.addEventListener('change', () => {
            const file = fileInput.files[0];
            if (file) {
                fileNameDisplay.textContent = `${file.name} (${formatFileSize(file.size)})`;
            } else {
                fileNameDisplay.textContent = '';
            }
        });
    </script>
</body>
</html>
