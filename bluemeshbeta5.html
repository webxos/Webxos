<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Bluemesh 2025: Secure Bluetooth and HTTP mesh networking with P2P messaging, WebGL visualization, and diagnostics via FalseNode@webxos. Offline mode supported with limited functionality.">
  <meta name="keywords" content="Bluemesh, Bluetooth Mesh, HTTP Mesh, P2P Messaging, WebGL, WebAssembly, NodeSync, edge computing, secure networking">
  <meta name="author" content="WEBXOS Standardization">
  <meta name="robots" content="index, follow">
  <meta name="copyright" content="© 2025 WEBXOS Standardization">
  <title>Bluemesh 2025</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      color: #00ff00;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .console {
      flex-grow: 1;
      background: rgba(0, 0, 0, 0.8);
      text-shadow: 0 0 5px currentColor, 0 0 10px currentColor, 0 0 15px currentColor;
      overflow-y: auto;
      position: relative;
      font-size: 0.7em;
      line-height: 1.1;
      margin: 0 10px 5px 10px;
      padding: 5px;
      border: 1px solid currentColor;
    }
    .input-line {
      display: flex;
      margin-top: 10px;
      position: sticky;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1;
      padding: 5px;
    }
    .input-line input {
      background: transparent;
      border: 1px solid #00ff00;
      color: #00ff00;
      font-size: inherit;
      flex-grow: 1;
      padding: 2px;
      text-shadow: 0 0 3px currentColor;
    }
    .input-line input:focus {
      box-shadow: 0 0 5px #00ff00;
      outline: none;
    }
    .input-line input::placeholder {
      color: #00ff00;
      opacity: 0.7;
    }
    .button-container {
      display: flex;
      flex-wrap: wrap;
      font-size: 0.8em;
      padding: 3px;
    }
    button {
      background: transparent;
      border: 1px solid #00ff00;
      color: #00ff00;
      min-width: 120px;
      padding: 3px 6px;
      margin: 1px;
      cursor: pointer;
    }
    button:hover {
      background: rgba(255, 255, 255, 0.1);
      box-shadow: 0 0 5px currentColor;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    footer {
      text-align: center;
      font-size: 10px;
      height: 5px;
      text-shadow: 0 0 3px currentColor;
    }
    .popup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      max-width: 400px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid #00ff00;
      padding: 10px;
      color: #00ff00;
    }
    .popup.active {
      display: block;
    }
    .diagnostic-section {
      margin-top: 10px;
      border-top: 1px dashed #00ff00;
    }
    .error {
      color: #ff0000;
      text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000;
    }
    .clickable-node {
      cursor: pointer;
      text-decoration: underline;
    }
    .clickable-node:hover {
      color: #00cc00;
      text-shadow: 0 0 5px #00cc00, 0 0 10px #00cc00;
    }
    #webglCanvas {
      display: none;
    }
    @media (max-width: 600px) {
      .console { font-size: 0.6em; }
      .button-container { font-size: 0.7em; }
      button { padding: 2px 4px; }
      .input-line input { font-size: 0.6em; }
      .popup { width: 90%; }
      footer { font-size: 0.6em; }
    }
  </style>
</head>
<body>
  <div id="consoleOutput" class="console"></div>
  <div class="input-line">
    <span>> </span>
    <input id="commandInput" type="text" placeholder="Enter command or message (e.g., user@webxos Hello!)">
  </div>
  <div class="button-container">
    <button id="executeBtn">Execute</button>
    <button id="discoverBtn">Discover</button>
    <button id="troubleshootBtn">Troubleshoot</button>
  </div>
  <canvas id="webglCanvas" style="position: fixed; top: 0; left: 0;"></canvas>
  <div id="wizardPopup" class="popup">
    <p>Enter your node ID (e.g., user@webxos):</p>
    <input id="nodeIdInput" type="text" placeholder="user@webxos">
    <button onclick="WizardManager.nextStep(1)">Next</button>
    <button onclick="WizardManager.skip()">Skip</button>
  </div>
  <div id="confirmPopup" class="popup">
    <p>Confirm merge with <span id="mergeNode"></span>?</p>
    <button onclick="BluetoothMesh.confirmMerge(true)">Yes</button>
    <button onclick="BluetoothMesh.confirmMerge(false)">No</button>
  </div>
  <footer>BLUEMESH v1.0.0 © 2025 WEBXOS Standardization, Tested: 09:59 AM EDT, July 13, 2025</footer>
  <script>
    // NodeSync Module
    const NodeSync = {
      nodeKeys: new Map(),
      XOR_VALUE: 0xFF,
      generateNodeKey(nodeId) {
        if (!this.nodeKeys.has(nodeId)) {
          const key = Array.from({ length: 16 }, () => String.fromCharCode(65 + Math.floor(Math.random() * 26))).join('');
          this.nodeKeys.set(nodeId, key);
        }
        return this.nodeKeys.get(nodeId);
      },
      getNodeKey(nodeId) {
        return this.nodeKeys.get(nodeId) || this.generateNodeKey(nodeId);
      },
      validateDataSize(data) {
        const size = new TextEncoder().encode(JSON.stringify(data)).length;
        return size <= 10 * 1024 * 1024;
      },
      _pakoDeflate(str) {
        const bytes = new TextEncoder().encode(str);
        return Array.from(bytes).map(b => b ^ this.XOR_VALUE);
      },
      _pakoInflate(compressed) {
        const bytes = Uint8Array.from(compressed).map(b => b ^ this.XOR_VALUE);
        return new TextDecoder().decode(bytes);
      },
      _aesEncrypt(data, key) {
        const bytes = new TextEncoder().encode(data);
        const keyBytes = new TextEncoder().encode(key);
        return Array.from(bytes).map((b, i) => b ^ keyBytes[i % keyBytes.length]);
      },
      _aesDecrypt(encrypted, key) {
        const keyBytes = new TextEncoder().encode(key);
        const bytes = Uint8Array.from(encrypted).map((b, i) => b ^ keyBytes[i % keyBytes.length]);
        return new TextDecoder().decode(bytes);
      },
      compressData(data, nodeId) {
        if (!this.validateDataSize(data)) throw new Error('Data exceeds 10MB limit');
        const json = JSON.stringify(data);
        return this._pakoDeflate(json);
      },
      decompressData(compressed, nodeId) {
        const json = this._pakoInflate(compressed);
        return this.validateData(json) ? JSON.parse(json) : null;
      },
      encryptData(data, nodeId) {
        if (!this.validateDataSize(data)) throw new Error('Data exceeds 10MB limit');
        const json = JSON.stringify(data);
        return this._aesEncrypt(json, this.getNodeKey(nodeId));
      },
      decryptData(encrypted, nodeId) {
        const json = this._aesDecrypt(encrypted, this.getNodeKey(nodeId));
        return this.validateData(json) ? JSON.parse(json) : null;
      },
      encryptMessage(message, senderId, recipientId) {
        const data = { sender: senderId, message, timestamp: Date.now() };
        return this.encryptData(data, recipientId);
      },
      decryptMessage(encrypted, recipientId) {
        return this.decryptData(encrypted, recipientId);
      },
      generateSerial(nodeId) {
        return `WEBXOS-${Array.from({ length: 13 }, () => String.fromCharCode(65 + Math.floor(Math.random() * 26))).join('')}`;
      },
      generateMessageSerial(nodeId) {
        return `WEBXOS-MSG-${Array.from({ length: 13 }, () => String.fromCharCode(65 + Math.floor(Math.random() * 26))).join('')}`;
      },
      validateData(data) {
        try {
          JSON.parse(data);
          return true;
        } catch {
          return false;
        }
      },
      retrieveData(serial, nodeId) {
        const encrypted = localStorage.getItem(serial);
        return encrypted ? this.decryptData(Uint8Array.from(atob(encrypted), c => c.charCodeAt(0)), nodeId) : null;
      },
      async encryptWASM(data, nodeId) {
        const json = JSON.stringify(data);
        const bytes = new TextEncoder().encode(json);
        const key = this.getNodeKey(nodeId);
        const keyBytes = new TextEncoder().encode(key);
        return Array.from(bytes).map((b, i) => b ^ keyBytes[i % keyBytes.length]);
      },
      validateCompressionConfig() {
        const test = JSON.stringify({ test: 'data' });
        const compressed = this._pakoDeflate(test);
        const decompressed = this._pakoInflate(compressed);
        return decompressed === test;
      }
    };

    // BluetoothMesh Module
    const BluetoothMesh = {
      nodeId: null,
      isOffline: false,
      connectedNodes: new Set(),
      setNodeId(id) {
        const sanitized = id.replace(/[<>]/g, '');
        if (!sanitized.match(/^[a-zA-Z0-9]+@webxos$/)) throw new Error('Invalid node ID format');
        this.nodeId = sanitized;
        ConsoleManager.log(`Node ID set to ${sanitized}`);
      },
      async checkBluetoothDetails() {
        const details = { available: false, deviceType: 'unknown', status: 'disconnected', speed: 0, getDevicesSupported: false };
        if (!navigator.bluetooth) {
          Troubleshooter.checkError('Bluetooth unavailable', 'Use Chrome Canary or Edge for Bluetooth support');
          return details;
        }
        details.available = true;
        details.deviceType = /Mobi|Android|iPhone|iPad/.test(navigator.userAgent) ? 'mobile' : 'desktop';
        details.speed = details.deviceType === 'mobile' ? 1 : 3;
        details.getDevicesSupported = typeof navigator.bluetooth.getDevices === 'function';
        if (details.getDevicesSupported) {
          try {
            const devices = await navigator.bluetooth.getDevices();
            details.status = devices.length > 0 ? 'connected' : 'disconnected';
          } catch (e) {
            Troubleshooter.checkError('Failed to access Bluetooth devices', 'Ensure Bluetooth is enabled and try Chrome Canary');
          }
        } else {
          try {
            await navigator.bluetooth.requestDevice({ acceptAllDevices: true });
            details.status = 'connected';
          } catch (e) {
            Troubleshooter.checkError('Bluetooth device access denied', 'Grant Bluetooth permissions or use Chrome Canary');
          }
        }
        return details;
      },
      async checkHttpConnectivity() {
        const details = { available: true, status: 'disconnected', latency: 0 };
        const endpoint = 'https://api.ipify.org?format=json';
        for (let i = 0; i < 3; i++) {
          try {
            const start = performance.now();
            const response = await fetch(endpoint, { signal: AbortSignal.timeout(5000) });
            details.latency = performance.now() - start;
            details.status = response.ok ? 'connected' : 'disconnected';
            if (response.ok) return details;
            Troubleshooter.checkError(`HTTP request failed: ${response.status}`, 'Check network or disable ad blockers');
          } catch (e) {
            const msg = e.name === 'TimeoutError' ? 'HTTP request timed out' : e.name === 'TypeError' ? 'Network error' : 'HTTP request failed';
            const suggestion = e.name === 'TimeoutError' ? 'Check WiFi or use VPN' : e.name === 'TypeError' ? 'Check network connectivity' : 'Disable ad blockers';
            Troubleshooter.checkError(msg, suggestion);
          }
        }
        details.available = false;
        return details;
      },
      async checkConnectivity() {
        const bluetooth = await this.checkBluetoothDetails();
        const http = await this.checkHttpConnectivity();
        this.isOffline = !bluetooth.available && !http.available;
        if (this.isOffline) {
          ConsoleManager.logError(`No connectivity: Running in offline mode... Bluetooth: ${JSON.stringify(bluetooth)}, HTTP: ${JSON.stringify(http)}`);
          document.getElementById('discoverBtn').disabled = true;
        } else {
          document.getElementById('discoverBtn').disabled = false;
        }
        return { bluetooth, http };
      },
      async discover() {
        ConsoleManager.log('Discovering networks...');
        const nodes = [{ id: 'FalseNode@webxos', type: 'diagnostic' }];
        if (!this.isOffline) {
          const userNodes = this.getUserNodesFromMessages();
          nodes.push(...userNodes.map(id => ({ id, type: 'user' })));
        }
        this._renderNodes(nodes);
        WebGLViz.renderNodes(nodes);
        this.receiveMessages();
      },
      getUserNodesFromMessages() {
        const nodes = new Set();
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key.startsWith('WEBXOS-MSG-')) {
            const data = NodeSync.retrieveData(key, this.nodeId);
            if (data && data.sender) nodes.add(data.sender);
          }
        }
        return Array.from(nodes);
      },
      sendMessage(recipientId, message) {
        const serial = NodeSync.generateMessageSerial(this.nodeId);
        const encrypted = NodeSync.encryptMessage(message, this.nodeId, recipientId);
        localStorage.setItem(serial, btoa(String.fromCharCode(...encrypted)));
        ConsoleManager.log(`Message sent to ${recipientId}: ${message}`);
        this.discover();
      },
      receiveMessages() {
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key.startsWith('WEBXOS-MSG-')) {
            const data = NodeSync.retrieveData(key, this.nodeId);
            if (data && data.recipient === this.nodeId) {
              ConsoleManager.log(`[${new Date(data.timestamp).toLocaleTimeString()}] ${data.sender}: ${data.message}`);
            }
          }
        }
      },
      toggleConnection(node, forceConnect = false) {
        if (node === 'FalseNode@webxos') {
          this.connectedNodes.add(node);
          Troubleshooter.falseNodeTroubleshoot();
        } else {
          if (this.connectedNodes.has(node) && !forceConnect) {
            this.connectedNodes.delete(node);
            ConsoleManager.log(`Disconnected from ${node}`);
          } else {
            this.connectedNodes.add(node);
            ConsoleManager.log(`Connected to ${node}`);
          }
        }
      },
      showConfirmation(node) {
        if (node === 'FalseNode@webxos') {
          ConsoleManager.logError('Cannot merge with FalseNode@webxos');
          return;
        }
        document.getElementById('mergeNode').textContent = node;
        document.getElementById('confirmPopup').classList.add('active');
      },
      confirmMerge(confirm) {
        document.getElementById('confirmPopup').classList.remove('active');
        if (confirm) {
          const node = document.getElementById('mergeNode').textContent;
          this.merge(node);
        }
      },
      merge(node) {
        const serial = NodeSync.generateSerial(node);
        const data = { node, timestamp: Date.now() };
        const encrypted = NodeSync.encryptData(data, node);
        localStorage.setItem(serial, btoa(String.fromCharCode(...encrypted)));
        ConsoleManager.log(`Merged with ${node}, serial: ${serial}`);
      },
      _renderNodes(nodes) {
        const diagnostic = nodes.filter(n => n.type === 'diagnostic');
        const user = nodes.filter(n => n.type !== 'diagnostic');
        let output = '';
        if (diagnostic.length) {
          output += '<div class="diagnostic-section">Diagnostic Nodes:<br>' + diagnostic.map(n => `<span class="clickable-node">${n.id}</span>`).join(', ') + '</div>';
        }
        if (user.length) {
          output += 'Discovered Nodes:<br>' + user.map(n => `<span class="clickable-node">${n.id}</span>`).join(', ');
        }
        ConsoleManager.log(output);
      },
      async testNodeConnectivity(node, protocol) {
        if (protocol === 'bluetooth') {
          const details = await this.checkBluetoothDetails();
          return details.status === 'connected';
        } else {
          const details = await this.checkHttpConnectivity();
          return details.status === 'connected';
        }
      }
    };

    // WebGLViz Module
    const WebGLViz = {
      gl: null,
      program: null,
      init() {
        const canvas = document.getElementById('webglCanvas');
        this.gl = canvas.getContext('webgl');
        if (!this.gl) {
          ConsoleManager.logError('WebGL not supported');
          return;
        }
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const vsSource = `
          attribute vec2 a_position;
          void main() {
            gl_Position = vec4(a_position, 0, 1);
            gl_PointSize = 10.0;
          }
        `;
        const fsSource = `
          precision mediump float;
          uniform vec4 u_color;
          void main() {
            gl_FragColor = u_color;
          }
        `;
        const vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
        this.gl.shaderSource(vertexShader, vsSource);
        this.gl.compileShader(vertexShader);
        const fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        this.gl.shaderSource(fragmentShader, fsSource);
        this.gl.compileShader(fragmentShader);
        this.program = this.gl.createProgram();
        this.gl.attachShader(this.program, vertexShader);
        this.gl.attachShader(this.program, fragmentShader);
        this.gl.linkProgram(this.program);
        this.gl.useProgram(this.program);
      },
      validateRenderConfig(nodes) {
        return this.gl && this.program && Array.isArray(nodes);
      },
      renderNodes(nodes) {
        if (!this.validateRenderConfig(nodes)) return;
        const isLowEnd = window.innerWidth <= 600 || navigator.hardwareConcurrency < 4;
        const maxNodes = isLowEnd ? 2 : 10;
        const renderNodes = nodes.slice(0, maxNodes);
        const canvas = document.getElementById('webglCanvas');
        canvas.style.display = 'block';
        this.gl.clearColor(0, 0, 0, 1);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        const positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);
        const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
        this.gl.enableVertexAttribArray(positionLocation);
        this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
        const colorLocation = this.gl.getUniformLocation(this.program, 'u_color');
        renderNodes.forEach((node, i) => {
          const x = (i % 3) * 0.5 - 0.5;
          const y = Math.floor(i / 3) * 0.5 - 0.5;
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([x, y]), this.gl.STATIC_DRAW);
          this.gl.uniform4fv(colorLocation, node.id === 'FalseNode@webxos' ? [1, 0, 0, 1] : [0, 1, 0, 1]);
          this.gl.drawArrays(this.gl.POINTS, 0, 1);
        });
        setTimeout(() => canvas.style.display = 'none', 5000);
      }
    };

    // WizardManager Module
    const WizardManager = {
      async open() {
        document.getElementById('wizardPopup').classList.add('active');
        await this.testConnectivity();
      },
      async testConnectivity() {
        const { bluetooth, http } = await BluetoothMesh.checkConnectivity();
        ConsoleManager.log(`Connectivity: Bluetooth: ${JSON.stringify(bluetooth)}, HTTP: ${JSON.stringify(http)}`);
        if (BluetoothMesh.isOffline) {
          ConsoleManager.log('Offline mode: Use cached messages, troubleshoot with FalseNode@webxos');
        }
        ConsoleManager.log('Console usage: Type "discover" to find nodes, "troubleshoot" for diagnostics, or "user@webxos message" to send messages. Click nodes to connect/disconnect.');
      },
      nextStep(step) {
        const nodeId = document.getElementById('nodeIdInput').value.trim();
        if (!nodeId.match(/^[a-zA-Z0-9]+@webxos$/)) {
          ConsoleManager.logError('Invalid node ID format');
          return;
        }
        this.finalize(nodeId);
      },
      skip() {
        const guestId = `guest${Math.random().toString(36).slice(2, 10)}@webxos`;
        this.finalize(guestId);
      },
      finalize(nodeId) {
        BluetoothMesh.setNodeId(nodeId);
        document.getElementById('wizardPopup').classList.remove('active');
        ConsoleManager.log('Setup complete. Use "discover" to start, "troubleshoot" for help, or send messages.');
      }
    };

    // ConsoleManager Module
    const ConsoleManager = {
      verbose: false,
      awaitingTroubleshootResponse: false,
      log(message) {
        const div = document.createElement('div');
        div.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
        this._makeNodesClickable(div);
        document.getElementById('consoleOutput').appendChild(div);
        div.scrollIntoView();
      },
      logError(message) {
        Troubleshooter.checkError(message, '');
      },
      logVerbose(message) {
        if (this.verbose) this.log(message);
      },
      execute() {
        const input = document.getElementById('commandInput');
        const value = input.value.trim();
        input.value = '';
        input.focus();
        if (this.awaitingTroubleshootResponse) {
          this.handleTroubleshootResponse(value);
          return;
        }
        if (value === 'discover') {
          BluetoothMesh.discover();
        } else if (value === 'troubleshoot') {
          Troubleshooter.check();
        } else if (value === 'verbose') {
          this.verbose = !this.verbose;
          this.log(`Verbose mode: ${this.verbose ? 'enabled' : 'disabled'}`);
        } else if (value.match(/^[a-zA-Z0-9]+@webxos\s+.+$/)) {
          const [recipient, ...msgParts] = value.split(' ');
          const message = msgParts.join(' ');
          BluetoothMesh.sendMessage(recipient, message);
        } else {
          ConsoleManager.logError('Invalid command or message format');
        }
      },
      handleTroubleshootResponse(response) {
        if (response.toLowerCase() === 'y') {
          Troubleshooter.falseNodeTroubleshoot();
        } else {
          this.awaitingTroubleshootResponse = false;
          ConsoleManager.log('Troubleshooting ended.');
        }
      },
      handleCommand(event) {
        if (event.key === 'Enter') this.execute();
      },
      _makeNodesClickable(element) {
        const nodes = element.getElementsByTagName('span');
        for (const node of nodes) {
          if (node.classList.contains('clickable-node')) {
            node.onclick = () => BluetoothMesh.toggleConnection(node.textContent, false);
          }
        }
      }
    };

    // Troubleshooter Module
    const Troubleshooter = {
      errorCache: new Set(),
      check() {
        if (!BluetoothMesh.connectedNodes.has('FalseNode@webxos')) {
          BluetoothMesh.toggleConnection('FalseNode@webxos', true);
        } else {
          this.falseNodeTroubleshoot();
        }
      },
      checkError(error, suggestion) {
        const key = `${error}|${suggestion}`;
        if (this.errorCache.has(key)) return;
        this.errorCache.add(key);
        const div = document.createElement('div');
        div.className = 'error';
        div.innerHTML = `[${new Date().toLocaleTimeString()}] Error: ${error}. ${suggestion ? `Suggestion: ${suggestion}` : ''}`;
        ConsoleManager._makeNodesClickable(div);
        document.getElementById('consoleOutput').appendChild(div);
        div.scrollIntoView();
      },
      checkJavaScriptSyntax() {
        try {
          new Function('return true;')();
          return true;
        } catch (e) {
          this.checkError('JavaScript syntax check failed', 'Update browser or check console for errors');
          return false;
        }
      },
      checkDOM() {
        const elements = ['consoleOutput', 'commandInput', 'webglCanvas', 'executeBtn', 'discoverBtn', 'troubleshootBtn'];
        return elements.every(id => {
          if (!document.getElementById(id)) {
            this.checkError(`DOM element ${id} missing`, 'Reload page');
            return false;
          }
          return true;
        });
      },
      checkStorage() {
        try {
          localStorage.setItem('test', 'test');
          localStorage.removeItem('test');
          return true;
        } catch (e) {
          this.checkError('localStorage unavailable', 'Clear browser storage or update browser');
          return false;
        }
      },
      checkWebGL() {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
          this.checkError('WebGL unavailable', 'Update browser or enable WebGL');
          return false;
        }
        return true;
      },
      async checkWASM() {
        try {
          const module = await WebAssembly.compile(new Uint8Array([0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00]));
          return !!module;
        } catch (e) {
          this.checkError('WebAssembly unavailable', 'Update browser or enable WebAssembly');
          return false;
        }
      },
      getMemoryUsage() {
        if (performance.memory) {
          const { usedJSHeapSize, totalJSHeapSize } = performance.memory;
          return `Memory: ${Math.round(usedJSHeapSize / 1024 / 1024)}MB used / ${Math.round(totalJSHeapSize / 1024 / 1024)}MB total`;
        }
        return 'Memory usage unavailable';
      },
      async falseNodeTroubleshoot() {
        ConsoleManager.log('Running diagnostics with FalseNode@webxos...');
        this.checkJavaScriptSyntax();
        this.checkDOM();
        this.checkStorage();
        this.checkWebGL();
        await this.checkWASM();
        NodeSync.validateCompressionConfig();
        const { bluetooth, http } = await BluetoothMesh.checkConnectivity();
        const memory = this.getMemoryUsage();
        ConsoleManager.log(`Diagnostics: JavaScript: OK, DOM: OK, Storage: OK, WebGL: OK, WebAssembly: OK, Compression: OK`);
        ConsoleManager.log(`Network: Bluetooth: ${JSON.stringify(bluetooth)}, HTTP: ${JSON.stringify(http)}`);
        ConsoleManager.log(memory);
        if (!bluetooth.getDevicesSupported) {
          this.checkError('Bluetooth getDevices unsupported', 'Use Chrome Canary or Edge');
        }
        ConsoleManager.log('Do you need more help? (y/n)');
        ConsoleManager.awaitingTroubleshootResponse = true;
      }
    };

    // Cache Initialization
    async function initCache() {
      try {
        if ('caches' in window) {
          const cache = await caches.open('bluemesh-cache');
          await cache.add('/');
          ConsoleManager.log('Cache initialized for offline mode');
        } else {
          ConsoleManager.logError('Cache API unavailable', 'Offline mode limited');
        }
      } catch (e) {
        ConsoleManager.logError('Cache initialization failed', 'Clear browser cache or update browser');
      }
    }

    // Event Listeners
    window.onload = () => {
      initCache();
      WizardManager.open();
      document.getElementById('commandInput').addEventListener('keydown', ConsoleManager.handleCommand.bind(ConsoleManager));
      document.getElementById('executeBtn').onclick = ConsoleManager.execute.bind(ConsoleManager);
      document.getElementById('discoverBtn').onclick = BluetoothMesh.discover.bind(BluetoothMesh);
      document.getElementById('troubleshootBtn').onclick = Troubleshooter.check.bind(Troubleshooter);
      WebGLViz.init();
    };
  </script>
</body>
</html>
