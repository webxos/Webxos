<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Post API</title>
    <style>
        body {
            background: #000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            width: 100%;
        }
        .form-container, .board-container {
            background: #111;
            padding: 20px;
            border: 2px solid #00ff00;
            border-radius: 5px;
            margin-bottom: 20px;
            display: none;
        }
        .form-container.active, .board-container.active {
            display: block;
        }
        input, button, textarea {
            background: #222;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 10px;
            margin: 5px 0;
            width: 100%;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }
        button {
            cursor: pointer;
        }
        button:hover {
            background: #00ff00;
            color: #000;
        }
        .post-card {
            background: #111;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #00ff00;
        }
        .api-key-container {
            word-break: break-all;
            font-size: 0.9em;
        }
        #copyApiKey, #copySerial {
            width: auto;
            display: inline-block;
        }
        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }
            input, button, textarea {
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="formContainer" class="form-container active">
            <h2>Post API</h2>
            <div id="createForm">
                <h3>Create Bulletin</h3>
                <input id="apiName" placeholder="API Name (e.g., API-MyBoard)" required>
                <button onclick="createBulletin()">Create</button>
            </div>
            <div id="joinForm">
                <h3>Join Bulletin</h3>
                <input id="joinApiName" placeholder="API Name (e.g., API-MyBoard)">
                <input id="joinSerial" placeholder="Serial">
                <input id="joinApiKey" placeholder="API Key (API-xxxxxx)">
                <button onclick="joinBulletin()">Join</button>
            </div>
        </div>
        <div id="boardContainer" class="board-container">
            <h2 id="boardTitle"></h2>
            <div>Serial: <span id="serialDisplay"></span> <button id="copySerial">Copy Serial</button></div>
            <div>API Key: <span id="apiKeyDisplay" class="api-key-container"></span> <button id="copyApiKey">Copy API Key</button></div>
            <div>
                <textarea id="postContent" placeholder="Enter post content"></textarea>
                <input id="fileInput" type="file">
                <button onclick="submitPost()">Post</button>
            </div>
            <div id="posts"></div>
        </div>
    </div>
    <script>
        const formContainer = document.getElementById('formContainer');
        const boardContainer = document.getElementById('boardContainer');
        const boardTitle = document.getElementById('boardTitle');
        const serialDisplay = document.getElementById('serialDisplay');
        const apiKeyDisplay = document.getElementById('apiKeyDisplay');
        const copyApiKey = document.getElementById('copyApiKey');
        const copySerial = document.getElementById('copySerial');
        const postsDiv = document.getElementById('posts');
        let db, virtualWorker, channel, peerConnection, dataChannel;
        let currentApiName, currentSerial, currentApiKey;

        // Virtual Worker Simulation
        const workerCode = `
            const clients = new Set();
            const signalingStore = new Map();
            self.onmessage = async ({ data, ports }) => {
                if (data.type === 'register') {
                    clients.add(ports[0]);
                    ports[0].onmessage = handleClientMessage;
                } else if (data.type === 'api') {
                    const { boardId, token } = data;
                    const db = await openDB();
                    const bulletin = await db.get('bulletins', boardId);
                    if (bulletin && bulletin.token === token) {
                        const posts = await db.getAll('posts', boardId);
                        ports[0].postMessage({ status: 200, data: posts });
                    } else {
                        ports[0].postMessage({ status: 404, data: [] });
                    }
                } else if (data.type === 'signal') {
                    signalingStore.set(data.boardId, { offer: data.offer, candidates: data.candidates || [] });
                    clients.forEach(client => client.postMessage({ type: 'signal', boardId: data.boardId, offer: data.offer }));
                }
            };
            async function handleClientMessage({ data }) {
                if (data.type === 'post') {
                    const db = await openDB();
                    await db.put('posts', { id: Date.now(), boardId: data.boardId, content: data.content, file: data.file });
                    clients.forEach(client => client.postMessage({ type: 'update', boardId: data.boardId, post: { id: Date.now(), content: data.content, file: data.file } }));
                } else if (data.type === 'signal') {
                    signalingStore.set(data.boardId, { offer: data.offer, candidates: data.candidates || [] });
                    clients.forEach(client => client.postMessage({ type: 'signal', boardId: data.boardId, offer: data.offer }));
                }
            }
            async function openDB() {
                return new Promise(resolve => {
                    const req = indexedDB.open('post-api', 3);
                    req.onupgradeneeded = e => {
                        const db = e.target.result;
                        db.createObjectStore('bulletins', { keyPath: 'boardId' });
                        db.createObjectStore('posts', { keyPath: 'id' }).createIndex('boardId', 'boardId');
                        db.createObjectStore('apiKeys', { keyPath: 'apiName' });
                        db.createObjectStore('signaling', { keyPath: 'boardId' });
                    };
                    req.onsuccess = e => resolve(e.target.result);
                });
            }
        `;
        const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);
        virtualWorker = new Worker(workerUrl);
        channel = new MessageChannel();
        virtualWorker.postMessage({ type: 'register' }, [channel.port1]);

        // Crypto Utilities
        async function deriveKeyFromApiName(apiName) {
            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                encoder.encode(apiName + 'post-api-salt-v3'),
                { name: 'PBKDF2' },
                false,
                ['deriveBits', 'deriveKey']
            );
            return crypto.subtle.deriveKey(
                { name: 'PBKDF2', salt: encoder.encode('post-api-salt-v3'), iterations: 100000, hash: 'SHA-256' },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
        }

        async function generateApiKey(boardId, token, serial) {
            const key = await deriveKeyFromApiName(currentApiName);
            const encoder = new TextEncoder();
            const data = encoder.encode(`${boardId}:${token}:${serial}:${Date.now()}`);
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv },
                key,
                data
            );
            const encryptedBase64 = btoa(String.fromCharCode(...new Uint8Array(encrypted)));
            const ivBase64 = btoa(String.fromCharCode(...iv));
            return `API-${encryptedBase64}.${ivBase64}`;
        }

        async function decryptApiKey(apiKey, apiName, serial) {
            const key = await deriveKeyFromApiName(apiName);
            const [_, encryptedBase64, ivBase64] = apiKey.split(/API-|\./);
            const encrypted = Uint8Array.from(atob(encryptedBase64), c => c.charCodeAt(0));
            const iv = Uint8Array.from(atob(ivBase64), c => c.charCodeAt(0));
            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv },
                key,
                encrypted
            );
            const decoded = new TextDecoder().decode(decrypted);
            const [boardId, token, decryptedSerial, timestamp] = decoded.split(':');
            return decryptedSerial === serial ? { boardId, token } : null;
        }

        // IndexedDB Setup
        async function initDB() {
            db = await new Promise(resolve => {
                const req = indexedDB.open('post-api', 3);
                req.onupgradeneeded = e => {
                    const db = e.target.result;
                    db.createObjectStore('bulletins', { keyPath: 'boardId' });
                    db.createObjectStore('posts', { keyPath: 'id' }).createIndex('boardId', 'boardId');
                    db.createObjectStore('apiKeys', { keyPath: 'apiName' });
                    db.createObjectStore('signaling', { keyPath: 'boardId' });
                };
                req.onsuccess = e => resolve(e.target.result);
            });
        }

        // WebRTC Setup
        async function initWebRTC(boardId, isCreator = false) {
            peerConnection = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
            dataChannel = isCreator ? peerConnection.createDataChannel('posts') : null;
            peerConnection.ondatachannel = e => {
                dataChannel = e.channel;
                setupDataChannel(boardId);
            };
            peerConnection.onicecandidate = async ({ candidate }) => {
                if (candidate) {
                    const signalingData = signalingStore.get(boardId) || { candidates: [] };
                    signalingData.candidates.push(candidate);
                    signalingStore.set(boardId, signalingData);
                    await db.put('signaling', { boardId, data: signalingData });
                    virtualWorker.postMessage({ type: 'signal', boardId, candidates: signalingData.candidates });
                }
            };
            if (isCreator) {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                const signalingData = { offer: { sdp: offer.sdp, type: offer.type }, candidates: [] };
                signalingStore.set(boardId, signalingData);
                await db.put('signaling', { boardId, data: signalingData });
                virtualWorker.postMessage({ type: 'signal', boardId, offer: signalingData.offer });
            }
        }

        function setupDataChannel(boardId) {
            dataChannel.onmessage = async ({ data }) => {
                const msg = JSON.parse(data);
                if (msg.type === 'post') {
                    await db.put('posts', { id: Date.now(), boardId, content: msg.content, file: msg.file });
                    updatePosts(boardId);
                } else if (msg.type === 'apiKey') {
                    currentApiKey = msg.apiKey;
                    apiKeyDisplay.textContent = currentApiKey;
                }
            };
        }

        // UI and Logic
        async function createBulletin() {
            await initDB();
            const apiName = document.getElementById('apiName').value;
            if (!apiName.startsWith('API-')) return;
            currentApiName = apiName;
            const boardId = crypto.randomUUID();
            const token = crypto.randomUUID();
            currentSerial = crypto.randomUUID();
            currentApiKey = await generateApiKey(boardId, token, currentSerial);
            await db.put('bulletins', { boardId, token });
            await db.put('apiKeys', { apiName, serial: currentSerial, apiKey: currentApiKey });
            await initWebRTC(boardId, true);
            formContainer.classList.remove('active');
            boardContainer.classList.add('active');
            boardTitle.textContent = apiName;
            serialDisplay.textContent = currentSerial;
            apiKeyDisplay.textContent = currentApiKey;
        }

        async function joinBulletin() {
            await initDB();
            const apiName = document.getElementById('joinApiName').value;
            const serial = document.getElementById('joinSerial').value;
            const apiKey = document.getElementById('joinApiKey').value;
            if (!apiName.startsWith('API-') || !apiKey.startsWith('API-')) return;
            const { boardId, token } = await decryptApiKey(apiKey, apiName, serial);
            if (!boardId) return;
            currentApiName = apiName;
            currentSerial = serial;
            currentApiKey = apiKey;
            await initWebRTC(boardId);
            const signalingData = (await db.get('signaling', boardId))?.data;
            if (signalingData) {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(signalingData.offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                signalingData.answer = { sdp: answer.sdp, type: answer.type };
                await db.put('signaling', { boardId, data: signalingData });
                virtualWorker.postMessage({ type: 'signal', boardId, offer: signalingData.answer });
                signalingData.candidates.forEach(c => peerConnection.addIceCandidate(new RTCIceCandidate(c)));
            }
            formContainer.classList.remove('active');
            boardContainer.classList.add('active');
            boardTitle.textContent = apiName;
            serialDisplay.textContent = currentSerial;
            apiKeyDisplay.textContent = currentApiKey;
            updatePosts(boardId);
        }

        async function submitPost() {
            const content = document.getElementById('postContent').value;
            const fileInput = document.getElementById('fileInput');
            let fileData = null;
            if (fileInput.files[0]) {
                fileData = await new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.readAsDataURL(fileInput.files[0]);
                });
            }
            const post = { content, file: fileData };
            const [boardId] = (await decryptApiKey(currentApiKey, currentApiName, currentSerial)).boardId.split(':');
            await db.put('posts', { id: Date.now(), boardId, content, file: fileData });
            dataChannel.send(JSON.stringify({ type: 'post', content, file: fileData }));
            currentApiKey = await generateApiKey(boardId, crypto.randomUUID(), currentSerial);
            await db.put('apiKeys', { apiName: currentApiName, serial: currentSerial, apiKey: currentApiKey });
            dataChannel.send(JSON.stringify({ type: 'apiKey', apiKey: currentApiKey }));
            apiKeyDisplay.textContent = currentApiKey;
            updatePosts(boardId);
            document.getElementById('postContent').value = '';
            fileInput.value = '';
        }

        async function updatePosts(boardId) {
            const posts = await db.getAllFromIndex('posts', 'boardId', boardId);
            postsDiv.innerHTML = posts.map(p => `
                <div class="post-card">
                    <p>${p.content}</p>
                    ${p.file ? `<a href="${p.file}" download>File</a>` : ''}
                </div>
            `).join('');
        }

        copyApiKey.onclick = () => navigator.clipboard.writeText(currentApiKey);
        copySerial.onclick = () => navigator.clipboard.writeText(currentSerial);

        window.onunload = async () => {
            if (db) {
                await db.delete('bulletins', currentApiName);
                await db.delete('posts', IDBKeyRange.bound([currentApiName], [currentApiName + '\uffff']));
                await db.delete('apiKeys', currentApiName);
                await db.delete('signaling', currentApiName);
            }
            if (peerConnection) peerConnection.close();
            if (dataChannel) dataChannel.close();
            virtualWorker.terminate();
        };

        const signalingStore = new Map();
        initDB();
    </script>
</body>
</html>
