<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0f0">
    <meta name="description" content="Watchdog AI BETA tests users carbon emissions data">
    <meta name="keywords" content="sustainable software, green coding, eco web design, carbon testing, energy consumption studies, browser energy efficiency, eco-friendly web, green tech, carbon footprint, web performance, sustainable web development">
    <meta name="author" content="WebXOS">
    <meta name="robots" content="index, follow">
    <meta name="application-name" content="Watchdog AI BETA">
    <meta property="og:title" content="Watchdog AI BETA: Sustainable Browser Energy Testing">
    <meta property="og:description" content="Measure your browser's energy efficiency and carbon footprint with Watchdog AI BETA. Optimize for green coding and eco web design.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://watchdog-ai-beta.webxos.com">
    <meta property="og:image" content="https://watchdog-ai-beta.webxos.com/icon.png">
    <meta property="og:site_name" content="Watchdog AI BETA">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Watchdog AI BETA: Green Coding & Carbon Testing">
    <meta name="twitter:description" content="Test browser energy consumption and reduce your carbon footprint with Watchdog AI BETA. Built for sustainable software and eco web design.">
    <meta name="twitter:image" content="https://watchdog-ai-beta.webxos.com/icon.png">
    <meta name="twitter:site" content="@WebXOS">
    <title>Watchdog AI BETA: Sustainable Software & Green Coding</title>
    <link rel="icon" href="icon.png">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: monospace, sans-serif;
        }

        html, body {
            height: 100vh;
            overflow: hidden;
            background: #000;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: background 0.3s, box-shadow 0.3s;
            -webkit-tap-highlight-color: transparent;
        }

        body.glow {
            background: rgba(255, 0, 0, 0.1);
            box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000 inset;
        }

        #console {
            width: 90%;
            max-width: 900px;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0f0;
            padding: 0.6rem;
            flex: 1;
            max-height: calc(100vh - 240px);
            overflow-y: auto;
            margin: 0.5rem 0;
            border-radius: 5px;
            font-size: 0.8rem;
            -webkit-overflow-scrolling: touch;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        #console.active-byte {
            border-color: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }

        #console p {
            margin: 0.2rem 0;
        }

        #console .command {
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            text-shadow: 0 0 3px #0f0;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
            margin: 0.5rem 0;
            padding: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
            width: 90%;
            max-width: 900px;
        }

        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 0.6rem 1.2rem;
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 3px;
            min-width: 90px;
            text-align: center;
            touch-action: manipulation;
            transition: background 0.3s, box-shadow 0.3s;
        }

        button:hover, button:focus {
            background: #0c0;
            outline: 2px solid #0f0;
        }

        button.active-byte {
            background: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #eco-stats {
            width: 90%;
            max-width: 900px;
            margin: 0.5rem 0;
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }

        .progress-container {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .progress-label {
            width: 90px;
            font-size: 0.75rem;
        }

        .progress-bar {
            flex: 1;
            height: 8px;
            background: #333;
            border: 1px solid #0f0;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #0f0;
            transition: width 0.5s;
        }

        footer {
            width: 100%;
            padding: 0.4rem;
            font-size: 9pt;
            text-align: center;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            line-height: 1.2;
        }

        @media (max-width: 600px) {
            h1 { font-size: 1.1rem; margin: 0.5rem 0; }
            #console { 
                font-size: 0.75rem; 
                padding: 0.5rem; 
                max-height: calc(100vh - 220px); 
            }
            button { 
                padding: 0.5rem 1rem; 
                font-size: 0.85rem; 
                min-width: 80px; 
            }
            footer { padding: 0.3rem; }
            .progress-label { width: 70px; font-size: 0.7rem; }
            .progress-bar { height: 7px; }
        }

        @media (max-width: 400px) {
            .button-group { flex-direction: column; align-items: center; }
            button { width: 100%; max-width: 160px; }
            #console { max-height: calc(100vh - 200px); }
            #eco-stats { gap: 0.15rem; }
        }
    </style>
</head>
<body>
    <h1 role="heading" aria-level="1">Watchdog AI BETA</h1>
    <div id="console" role="log" aria-live="polite">
        <p>Watchdog AI BETA User Guide: Bark: Run tests & report | Byte: Toggle eco monitoring | Reset: Clear console</p>
    </div>
    <div id="eco-stats">
        <div class="progress-container">
            <span class="progress-label">Latency:</span>
            <div class="progress-bar"><div class="progress-fill" id="latency-bar" style="width: 0%"></div></div>
            <span id="latency-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Power Usage:</span>
            <div class="progress-bar"><div class="progress-fill" id="power-bar" style="width: 0%"></div></div>
            <span id="power-value">0 W</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Memory Usage:</span>
            <div class="progress-bar"><div class="progress-fill" id="memory-bar" style="width: 0%"></div></div>
            <span id="memory-value">0 MB</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">JS Perf:</span>
            <div class="progress-bar"><div class="progress-fill" id="jsperf-bar" style="width: 0%"></div></div>
            <span id="jsperf-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">CPU Eff:</span>
            <div class="progress-bar"><div class="progress-fill" id="cpueff-bar" style="width: 0%"></div></div>
            <span id="cpueff-value">0 ms</span>
        </div>
    </div>
    <div class="button-group">
        <button id="bark-btn" aria-label="Run performance tests and generate report">Bark</button>
        <button id="byte-btn" aria-label="Toggle eco monitoring">Byte</button>
        <button id="reset-btn" aria-label="Clear console output">Reset</button>
    </div>
    <footer>
        Â© 2025 WebXOS - Watchdog AI BETA<br>
        Bark: Run tests & report | Byte: Toggle eco monitoring | Reset: Clear console
    </footer>

    <script>
        function debugLog(message) {
            console.log(`[DEBUG] ${message}`);
        }

        const consoleDiv = document.getElementById('console');
        let logQueue = [];
        function log(message, isCommand = false) {
            const formattedMessage = isCommand 
                ? `<span class="command">${message}</span>`
                : message;
            logQueue.push(`[${new Date().toLocaleTimeString()}] ${formattedMessage}`);
            if (logQueue.length > 50) logQueue.shift();
            throttleConsoleUpdate();
        }

        const throttleConsoleUpdate = (() => {
            let timeout;
            return () => {
                if (!timeout) {
                    timeout = setTimeout(() => {
                        consoleDiv.innerHTML = logQueue.map(msg => `<p>${msg}</p>`).join('');
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        timeout = null;
                    }, 100);
                }
            };
        })();

        function triggerGlow() {
            document.body.classList.add('glow');
            setTimeout(() => document.body.classList.remove('glow'), 1000);
        }

        function flashRedGlow() {
            consoleDiv.classList.add('active-byte');
            setTimeout(() => consoleDiv.classList.remove('active-byte'), 500);
            setTimeout(() => {
                consoleDiv.classList.add('active-byte');
                setTimeout(() => consoleDiv reload() {
                    consoleDiv.classList.remove('active-byte'), 500);
            }, 1000);
        }

        function resetConsole() {
            debugLog('Reset button clicked');
            try {
                logQueue = ['Watchdog AI BETA User Guide: Bark: Run tests & report | Byte: Toggle eco monitoring | Reset: Clear console'];
                throttleConsoleUpdate();
                log('Console cleared.', true);
            } catch (err) {
                log(`Reset Error: ${err.message}`, true);
                debugLog(`Reset Error: ${err.stack}`);
            }
        }

        function calculateMetrics(results) {
            const totalScore = results.reduce((sum, result) => sum + result.score, 0);
            const maxScore = results.length * 10;
            const normalizedScore = Math.round((totalScore / maxScore) * 100);
            const estimatedWatts = 40 + (100 - normalizedScore) * 2;
            const carbonFootprint = (estimatedWatts * 0.000531).toFixed(2);
            return { totalScore, maxScore, normalizedScore, estimatedWatts, carbonFootprint };
        }

        class AdvancedAgent {
            constructor(name, tests) {
                this.name = name;
                this.tests = tests;
                this.results = [];
                this.isMobile = /Mobi|Android/i.test(navigator.userAgent);
                this.selectedTests = null;
                this.baselineFactor = 1;
            }

            async calibrate() {
                const start = performance.now();
                let sum = 0;
                for (let i = 0; i < (this.isMobile ? 5000 : 10000); i++) sum += Math.sqrt(i);
                const baselineTime = performance.now() - start;
                this.baselineFactor = Math.min(2, Math.max(0.5, baselineTime / 10));
                debugLog(`Baseline factor: ${this.baselineFactor}`);
            }

            selectTests() {
                if (this.selectedTests) return this.selectedTests;
                const supportedTests = this.tests.filter(test => {
                    if (test.requires && !test.requires()) return false;
                    if (this.isMobile && test.heavy) return false;
                    return true;
                });

                const prioritized = [];
                const categories = new Set();
                for (const test of supportedTests) {
                    if (prioritized.length >= 8) break;
                    if (!categories.has(test.category)) {
                        prioritized.push(test);
                        categories.add(test.category);
                    }
                }
                for (const test of supportedTests) {
                    if (prioritized.length >= 8) break;
                    if (!prioritized.includes(test)) prioritized.push(test);
                }
                this.selectedTests = prioritized.slice(0, Math.max(4, prioritized.length));
                return this.selectedTests;
            }

            async runTests() {
                await this.calibrate();
                this.results = [];
                const selectedTests = this.selectTests();
                log(`Running ${selectedTests.length} energy tests...`, true);

                for (const test of selectedTests) {
                    const iterations = this.isMobile ? test.iterations * 0.5 : test.iterations;
                    const result = await test.fn(iterations, this.baselineFactor);
                    this.results.push({ name: test.name, ...result });
                    log(`${test.name}: ${result.score}/10 (${result.details})`);
                }
                return this.results;
            }
        }

        const tests = [
            {
                name: 'JS Performance',
                category: 'cpu',
                iterations: 100000,
                fn: async (iterations, baselineFactor) => {
                    const start = performance.now();
                    let sum = 0;
                    for (let i = 0; i < iterations; i++) sum += Math.sqrt(i);
                    const time = performance.now() - start;
                    const threshold1 = 20 * baselineFactor;
                    const threshold2 = 50 * baselineFactor;
                    return {
                        score: time < threshold1 ? 9 : time < threshold2 ? 7 : 5,
                        details: `Completed in ${time.toFixed(2)}ms`,
                        metric: time
                    };
                }
            },
            {
                name: 'CPU Efficiency',
                category: 'cpu',
                iterations: 250000,
                fn: async (iterations, baselineFactor) => {
                    const start = performance.now();
                    let load = 0;
                    for (let i = 0; i < iterations; i++) load += Math.random();
                    const time = performance.now() - start;
                    const threshold1 = 40 * baselineFactor;
                    const threshold2 = 80 * baselineFactor;
                    return {
                        score: time < threshold1 ? 8 : time < threshold2 ? 6 : 4,
                        details: `Stress test in ${time.toFixed(2)}ms`,
                        metric: time
                    };
                }
            },
            {
                name: 'Memory Usage',
                category: 'memory',
                iterations: 100000,
                requires: () => !!performance.memory,
                fn: async (iterations, baselineFactor) => {
                    const start = performance.memory.usedJSHeapSize;
                    const array = new Array(iterations).fill(0);
                    const end = performance.memory.usedJSHeapSize;
                    const memUsage = (end - start) / 1024 / 1024;
                    const threshold1 = 2 * baselineFactor;
                    const threshold2 = 8 * baselineFactor;
                    return {
                        score: memUsage < threshold1 ? 8 : memUsage < threshold2 ? 6 : 4,
                        details: `${memUsage.toFixed(2)}MB used`,
                        metric: memUsage
                    };
                }
            },
            {
                name: 'Display Power',
                category: 'display',
                iterations: 1,
                fn: async (_, baselineFactor) => {
                    const brightness = window.matchMedia('(prefers-contrast: high)').matches ? 4 : 8;
                    return {
                        score: brightness,
                        details: brightness === 8 ? 'Low brightness' : 'High brightness',
                        metric: brightness
                    };
                }
            },
            {
                name: 'Battery Impact',
                category: 'battery',
                iterations: 1,
                requires: () => !!navigator.getBattery,
                fn: async (_, baselineFactor) => {
                    const battery = await navigator.getBattery();
                    const level = battery.level;
                    const score = level > 0.5 ? 8 : level > 0.2 ? 6 : 4;
                    return {
                        score,
                        details: `Level at ${(level * 100).toFixed(0)}%`,
                        metric: level
                    };
                }
            },
            {
                name: 'Rendering Performance',
                category: 'rendering',
                iterations: 50,
                heavy: true,
                fn: async (iterations, baselineFactor) => {
                    const start = performance.now();
                    const div = document.createElement('div');
                    for (let i = 0; i < iterations; i++) {
                        div.style.background = `#${Math.random().toString(16).slice(2, 8)}`;
                        document.body.appendChild(div);
                        document.body.removeChild(div);
                    }
                    const time = performance.now() - start;
                    const threshold1 = 50 * baselineFactor;
                    const threshold2 = 100 * baselineFactor;
                    return {
                        score: time < threshold1 ? 9 : time < threshold2 ? 7 : 5,
                        details: `Rendering in ${time.toFixed(2)}ms`,
                        metric: time
                    };
                }
            },
            {
                name: 'DOM Manipulation',
                category: 'dom',
                iterations: 500,
                fn: async (iterations, baselineFactor) => {
                    const start = performance.now();
                    const div = document.createElement('div');
                    for (let i = 0; i < iterations; i++) {
                        div.textContent = `Test ${i}`;
                        document.body.appendChild(div);
                        document.body.removeChild(div);
                    }
                    const time = performance.now() - start;
                    const threshold1 = 30 * baselineFactor;
                    const threshold2 = 60 * baselineFactor;
                    return {
                        score: time < threshold1 ? 9 : time < threshold2 ? 7 : 5,
                        details: `DOM updates in ${time.toFixed(2)}ms`,
                        metric: time
                    };
                }
            },
            {
                name: 'Event Loop Latency',
                category: 'eventloop',
                iterations: 50,
                fn: async (iterations, baselineFactor) => {
                    const start = performance.now();
                    let count = 0;
                    const tick = () => {
                        if (count++ < iterations) setTimeout(tick, 0);
                    };
                    tick();
                    await new Promise(resolve => setTimeout(resolve, iterations * 2));
                    const time = performance.now() - start;
                    const threshold1 = 200 * baselineFactor;
                    const threshold2 = 400 * baselineFactor;
                    return {
                        score: time < threshold1 ? 9 : time < threshold2 ? 7 : 5,
                        details: `Latency in ${time.toFixed(2)}ms`,
                        metric: time
                    };
                }
            }
        ];

        const enhancementTips = {
            'JS Performance': (result, isMobile) => {
                const time = parseFloat(result.details);
                const isSevere = time > 50;
                return {
                    tips: isSevere 
                        ? '- Close all unnecessary apps.\n- Restart your device.\n'
                        : '- Close unused tabs.\n- Disable heavy extensions.\n',
                    message: isMobile
                        ? `High CPU usage (${time.toFixed(2)}ms). ${isSevere ? 'Close apps or restart.' : 'Close background apps.'}`
                        : `JS Performance slow (${time.toFixed(2)}ms). ${isSevere ? 'Close heavy apps.' : 'Reduce open tabs.'}`
                };
            },
            'CPU Efficiency': (result, isMobile) => {
                const time = parseFloat(result.details);
                const isSevere = time > 80;
                return {
                    tips: isSevere 
                        ? '- Shut down background processes.\n- Update system.\n'
                        : '- Limit background apps.\n- Enable power-saving mode.\n',
                    message: isMobile
                        ? `CPU stress test took ${time.toFixed(2)}ms. ${isSevere ? 'Restart device.' : 'Close unused apps.'}`
                        : `CPU efficiency low (${time.toFixed(2)}ms). ${isSevere ? 'Close heavy apps.' : 'Enable power-saving.'}`
                };
            },
            'Memory Usage': (result, isMobile) => {
                const memUsage = parseFloat(result.details);
                const isSevere = memUsage > 8;
                return {
                    tips: isSevere 
                        ? '- Close memory-intensive apps.\n- Clear cache.\n'
                        : '- Disable unused extensions.\n- Free up RAM.\n',
                    message: isMobile
                        ? `High memory usage (${memUsage.toFixed(2)}MB). ${isSevere ? 'Close apps or restart.' : 'Disable heavy extensions.'}`
                        : `Memory usage high (${memUsage.toFixed(2)}MB). ${isSevere ? 'Close apps or restart.' : 'Clear cache.'}`
                };
            },
            'Display Power': (result, isMobile) => {
                const brightness = result.metric;
                return {
                    tips: brightness === 4 
                        ? '- Reduce screen brightness.\n- Enable auto-brightness.\n'
                        : '- Maintain low brightness.\n- Use dark mode.\n',
                    message: isMobile
                        ? `Display power ${brightness === 4 ? 'high' : 'optimized'}. ${brightness === 4 ? 'Lower brightness.' : 'Keep low brightness.'}`
                        : `Display power ${brightness === 4 ? 'high' : 'optimized'}. ${brightness === 4 ? 'Reduce brightness.' : 'Use dark mode.'}`
                };
            },
            'Battery Impact': (result, isMobile) => {
                const level = result.metric * 100;
                const isSevere = level < 20;
                return {
                    tips: isSevere 
                        ? '- Charge device soon.\n- Use efficient charger.\n'
                        : '- Charge during off-peak hours.\n- Avoid overcharging.\n',
                    message: isMobile
                        ? `Battery at ${level.toFixed(0)}%. ${isSevere ? 'Charge now.' : 'Charge later.'}`
                        : `Battery at ${level.toFixed(0)}%. ${isSevere ? 'Charge soon.' : 'Charge off-peak.'}`
                };
            },
            'Rendering Performance': (result, isMobile) => {
                const time = parseFloat(result.details);
                const isSevere = time > 100;
                return {
                    tips: isSevere 
                        ? '- Disable GPU-heavy extensions.\n- Update graphics drivers.\n'
                        : '- Simplify CSS animations.\n- Reduce visual effects.\n',
                    message: isMobile
                        ? `Rendering took ${time.toFixed(2)}ms. ${isSevere ? 'Disable heavy themes.' : 'Reduce animations.'}`
                        : `Rendering slow (${time.toFixed(2)}ms). ${isSevere ? 'Update GPU drivers.' : 'Simplify styles.'}`
                };
            },
            'DOM Manipulation': (result, isMobile) => {
                const time = parseFloat(result.details);
                const isSevere = time > 60;
                return {
                    tips: isSevere 
                        ? '- Minimize JS frameworks.\n- Optimize DOM updates.\n'
                        : '- Reduce DOM changes.\n- Use lightweight scripts.\n',
                    message: isMobile
                        ? `DOM updates took ${time.toFixed(2)}ms. ${isSevere ? 'Limit scripts.' : 'Optimize scripts.'}`
                        : `DOM manipulation slow (${time.toFixed(2)}ms). ${isSevere ? 'Refactor scripts.' : 'Reduce DOM ops.'}`
                };
            },
            'Event Loop Latency': (result, isMobile) => {
                const time = parseFloat(result.details);
                const isSevere = time > 400;
                return {
                    tips: isSevere 
                        ? '- Stop background scripts.\n- Check extensions.\n'
                        : '- Optimize event handlers.\n- Limit timers.\n',
                    message: isMobile
                        ? `Event loop latency ${time.toFixed(2)}ms. ${isSevere ? 'Disable heavy scripts.' : 'Optimize timers.'}`
                        : `Event loop latency high (${time.toFixed(2)}ms). ${isSevere ? 'Remove extensions.' : 'Streamline listeners.'}`
                };
            }
        };

        let lastTestResults = null;
        let byteActive = false;
        let byteStartTime = null;
        let latencyHistory = [];
        let powerHistory = [];
        let memoryHistory = [];
        let jsPerfHistory = [];
        let cpuEffHistory = [];
        let anomalyLog = [];
        let connectionInterval = null;
        let anomalyModel = null;

        async function loadAnomalyModel() {
            const model = tf.sequential();
            model.add(tf.layers.dense({ units: 8, activation: 'relu', inputShape: [5] }));
            model.add(tf.layers.dense({ units: 4, activation: 'relu' }));
            model.add(tf.layers.dense({ units: 8, activation: 'relu' }));
            model.add(tf.layers.dense({ units: 5 }));
            model.compile({ optimizer: 'adam', loss: 'meanSquaredError' });

            const normalData = Array.from({ length: 500 }, () => [
                Math.random() * 100 + 10, // Latency: 10-110ms
                Math.random() * 5 + 1,    // Power: 1-6W
                Math.random() * 10 + 1,   // Memory: 1-11MB
                Math.random() * 50 + 10,  // JS Perf: 10-60ms
                Math.random() * 80 + 20   // CPU Eff: 20-100ms
            ]);
            const xs = tf.tensor2d(normalData);
            await model.fit(xs, xs, { epochs: 5, batchSize: 32 });
            xs.dispose();
            return model;
        }

        async function detectAnomaly(latency, power, memory, jsPerf, cpuEff) {
            if (!anomalyModel) return false;
            const input = tf.tensor2d([[latency, power, memory, jsPerf, cpuEff]]);
            const output = anomalyModel.predict(input);
            const mse = tf.losses.meanSquaredError(input, output).dataSync()[0];
            input.dispose();
            output.dispose();
            return mse > 0.1;
        }

        async function runLatencyTest() {
            const start = performance.now();
            try {
                await fetch('https://www.google.com/generate_204', { method: 'HEAD', mode: 'no-cors' });
            } catch {
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            const latency = performance.now() - start;
            latencyHistory.push(latency);
            if (latencyHistory.length > 20) latencyHistory.shift();
            return latency;
        }

        async function runJsPerfTest() {
            const iterations = /Mobi|Android/i.test(navigator.userAgent) ? 5000 : 10000;
            const start = performance.now();
            let sum = 0;
            for (let i = 0; i < iterations; i++) sum += Math.sqrt(i);
            const time = performance.now() - start;
            jsPerfHistory.push(time);
            if (jsPerfHistory.length > 20) jsPerfHistory.shift();
            return time;
        }

        async function runCpuEffTest() {
            const iterations = /Mobi|Android/i.test(navigator.userAgent) ? 10000 : 20000;
            const start = performance.now();
            let load = 0;
            for (let i = 0; i < iterations; i++) load += Math.random();
            const time = performance.now() - start;
            cpuEffHistory.push(time);
            if (cpuEffHistory.length > 20) cpuEffHistory.shift();
            return time;
        }

        function estimatePowerUsage() {
            let power = latencyHistory.length > 0 ? latencyHistory[latencyHistory.length - 1] / 10 : 1;
            if (navigator.getBattery) {
                navigator.getBattery().then(battery => {
                    power *= (1 - battery.level) * 2 + 1;
                });
            }
            power = Math.min(10, Math.max(1, power));
            powerHistory.push(power);
            if (powerHistory.length > 20) powerHistory.shift();
            return power;
        }

        function estimateMemoryUsage() {
            let memory = 1;
            if (performance.memory) {
                memory = performance.memory.usedJSHeapSize / 1024 / 1024;
            } else {
                memory = latencyHistory.length > 0 ? latencyHistory[latencyHistory.length - 1] / 20 + 1 : 1;
            }
            memory = Math.min(20, Math.max(1, memory));
            memoryHistory.push(memory);
            if (memoryHistory.length > 20) memoryHistory.shift();
            return memory;
        }

        function calculateCarbonFootprint(power, memory, jsPerf, cpuEff) {
            const powerCarbon = power * 0.000531;
            const memoryCarbon = memory * 0.00001;
            const jsPerfCarbon = jsPerf * 0.000001;
            const cpuEffCarbon = cpuEff * 0.000001;
            return (powerCarbon + memoryCarbon + jsPerfCarbon + cpuEffCarbon).toFixed(3);
        }

        function calculateEnergySavings(power, durationHours) {
            const baselineEnergy = power * durationHours; // Wh
            const reductionPercentage = 0.15; // Assume 15% reduction from hints
            const savedEnergy = baselineEnergy * reductionPercentage;
            const savedCarbon = (savedEnergy * 0.000531).toFixed(3); // kg CO2
            return { savedEnergy: savedEnergy.toFixed(2), savedCarbon };
        }

        const ecoStates = {
            Optimal: {
                condition: (latency, power, memory, jsPerf, cpuEff) => 
                    latency < 50 && power < 3 && memory < 5 && jsPerf < 30 && cpuEff < 50,
                message: 'Eco State: Optimal - Low resource usage, mobile-friendly.',
                hints: [
                    'Maintain settings for eco compliance.',
                    'Keep low brightness on mobile.'
                ]
            },
            Moderate: {
                condition: (latency, power, memory, jsPerf, cpuEff) => 
                    latency < 100 && power < 5 && memory < 10 && jsPerf < 50 && cpuEff < 80,
                message: 'Eco State: Moderate - Acceptable usage, optimize for mobile.',
                hints: [
                    'Close unused apps to reduce memory.',
                    'Enable power-saving mode on mobile.'
                ]
            },
            High: {
                condition: (latency, power, memory, jsPerf, cpuEff) => 
                    latency < 150 && power < 7 && memory < 15 && jsPerf < 70 && cpuEff < 100,
                message: 'Eco State: High - Elevated usage, action needed.',
                hints: [
                    'Disable heavy extensions to lower CPU usage.',
                    'Reduce tabs to save memory on mobile.'
                ]
            },
            Critical: {
                condition: (latency, power, memory, jsPerf, cpuEff) => 
                    latency >= 150 || power >= 7 || memory >= 15 || jsPerf >= 70 || cpuEff >= 100,
                message: 'Eco State: Critical - Excessive usage, immediate action needed.',
                hints: [
                    'Close all unnecessary apps on mobile.',
                    'Restart device to free resources.'
                ]
            },
            Anomaly: {
                condition: async (latency, power, memory, jsPerf, cpuEff) => 
                    await detectAnomaly(latency, power, memory, jsPerf, cpuEff),
                message: 'Eco State: Anomaly - Possible intrusion or DDoS detected.',
                hints: [
                    'Check network for unauthorized access.',
                    'Contact IT to investigate threats.'
                ]
            },
            Disconnected: {
                condition: (latency) => latency >= 1000,
                message: 'Eco State: Disconnected - Connection lost, check network.',
                hints: [
                    'Verify mobile data or Wi-Fi.',
                    'Update browser for stability.'
                ]
            }
        };

        async function updateEcoStats() {
            const latency = await runLatencyTest();
            const power = estimatePowerUsage();
            const memory = estimateMemoryUsage();
            const jsPerf = await runJsPerfTest();
            const cpuEff = await runCpuEffTest();
            const carbonFootprint = calculateCarbonFootprint(power, memory, jsPerf, cpuEff);

            const avgLatency = latencyHistory.reduce((sum, val) => sum + val, 0) / latencyHistory.length;
            const deviation = Math.abs(latency - avgLatency);

            document.getElementById('latency-bar').style.width = `${Math.min(100, latency / 2)}%`;
            document.getElementById('latency-value').textContent = `${latency.toFixed(2)} ms`;
            document.getElementById('power-bar').style.width = `${power * 10}%`;
            document.getElementById('power-value').textContent = `${power.toFixed(2)} W`;
            document.getElementById('memory-bar').style.width = `${memory * 5}%`;
            document.getElementById('memory-value').textContent = `${memory.toFixed(2)} MB`;
            document.getElementById('jsperf-bar').style.width = `${Math.min(100, jsPerf / 1)}%`;
            document.getElementById('jsperf-value').textContent = `${jsPerf.toFixed(2)} ms`;
            document.getElementById('cpueff-bar').style.width = `${Math.min(100, cpuEff / 1.5)}%`;
            document.getElementById('cpueff-value').textContent = `${cpuEff.toFixed(2)} ms`;

            let currentState = null;
            for (const [state, config] of Object.entries(ecoStates)) {
                if (await config.condition(latency, power, memory, jsPerf, cpuEff)) {
                    currentState = state;
                    log(config.message, true);
                    config.hints.forEach(hint => log(`Hint: ${hint}`));
                    if (state === 'Critical' || state === 'Anomaly' || state === 'Disconnected') {
                        flashRedGlow();
                    }
                    break;
                }
            }

            if (deviation > avgLatency * 1.5 && latencyHistory.length > 5) {
                const anomalyMessage = `Latency spike detected at ${new Date().toLocaleTimeString()}. Possible network issue.`;
                log('Warning: ' + anomalyMessage, true);
                anomalyLog.push(anomalyMessage);
                flashRedGlow();
            } else if (latency < avgLatency * 0.5 && latencyHistory.length > 5) {
                const anomalyMessage = `Unusually low latency at ${new Date().toLocaleTimeString()}. Possible spoofing.`;
                log('Warning: ' + anomalyMessage, true);
                anomalyLog.push(anomalyMessage);
                flashRedGlow();
            }

            if (await detectAnomaly(latency, power, memory, jsPerf, cpuEff)) {
                const anomalyMessage = `Anomaly detected at ${new Date().toLocaleTimeString()} via TensorFlow.js. Possible intrusion or DDoS.`;
                log('Warning: ' + anomalyMessage, true);
                anomalyLog.push(anomalyMessage);
                flashRedGlow();
            }

            log(`Eco Stats: Carbon Footprint: ${carbonFootprint} kg CO2/h | Power: ${power.toFixed(2)} W | Memory: ${memory.toFixed(2)} MB | JS Perf: ${jsPerf.toFixed(2)} ms | CPU Eff: ${cpuEff.toFixed(2)} ms`, true);
        }

        async function secureConnection() {
            debugLog('Securing connection with lightweight measures');
            await new Promise(resolve => setTimeout(resolve, 50));
            log('Connection secured with data lock.', true);
        }

        async function sendPacket() {
            try {
                const response = await fetch('https://www.google.com/generate_204', {
                    method: 'HEAD',
                    mode: 'no-cors'
                });
                const latency = await runLatencyTest();
                log(`Packet sent, latency: ${latency.toFixed(2)}ms`, true);
            } catch (err) {
                log(`Packet Error: ${err.message}. Falling back to local timing.`, true);
                const latency = await runLatencyTest();
                log(`Local latency: ${latency.toFixed(2)}ms`, true);
            }
        }

        function formatDuration(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return minutes > 0 
                ? `${minutes} minute${minutes > 1 ? 's' : ''}, ${remainingSeconds} second${remainingSeconds !== 1 ? 's' : ''}`
                : `${remainingSeconds} second${remainingSeconds !== 1 ? 's' : ''}`;
        }

        async function generateByteReport() {
            const stopTime = new Date();
            const timeRanSeconds = Math.round((stopTime - byteStartTime) / 1000);
            const durationHours = timeRanSeconds / 3600;
            const isMobile = /Mobi|Android/i.test(navigator.userAgent);

            const avgLatency = latencyHistory.length > 0 
                ? (latencyHistory.reduce((sum, val) => sum + val, 0) / latencyHistory.length).toFixed(2)
                : 'N/A';
            const avgPower = powerHistory.length > 0 
                ? (powerHistory.reduce((sum, val) => sum + val, 0) / powerHistory.length).toFixed(2)
                : 'N/A';
            const avgMemory = memoryHistory.length > 0 
                ? (memoryHistory.reduce((sum, val) => sum + val, 0) / memoryHistory.length).toFixed(2)
                : 'N/A';
            const avgJsPerf = jsPerfHistory.length > 0 
                ? (jsPerfHistory.reduce((sum, val) => sum + val, 0) / jsPerfHistory.length).toFixed(2)
                : 'N/A';
            const avgCpuEff = cpuEffHistory.length > 0 
                ? (cpuEffHistory.reduce((sum, val) => sum + val, 0) / cpuEffHistory.length).toFixed(2)
                : 'N/A';

            const { savedEnergy, savedCarbon } = avgPower !== 'N/A' 
                ? calculateEnergySavings(avgPower, durationHours)
                : { savedEnergy: 'N/A', savedCarbon: 'N/A' };

            let report = `Watchdog AI BETA Eco Monitoring Report\n\n`;
            report += `Eco Monitoring Stopped: ${stopTime.toLocaleString()}\n`;
            report += `Monitoring Duration: ${formatDuration(timeRanSeconds)}\n`;
            report += `Device: ${isMobile ? 'Mobile' : 'Desktop'} | Browser: ${navigator.userAgent}\n\n`;
            report += `Average Eco Stats:\n`;
            report += `- Latency: ${avgLatency} ms\n`;
            report += `- Power Usage: ${avgPower} W\n`;
            report += `- Memory Usage: ${avgMemory} MB\n`;
            report += `- JS Performance: ${avgJsPerf} ms\n`;
            report += `- CPU Efficiency: ${avgCpuEff} ms\n\n`;
            report += `Energy Savings:\n`;
            report += `- Estimated Energy Saved: ${savedEnergy} Wh\n`;
            report += `- Estimated Carbon Saved: ${savedCarbon} kg CO2\n\n`;
            report += `Anomaly Log:\n`;
            report += anomalyLog.length > 0 
                ? anomalyLog.map(log => `- ${log}`).join('\n') + '\n'
                : '- No anomalies detected\n';
            report += `\nÂ© 2025 WebXOS - Watchdog AI BETA`;

            return report;
        }

        async function toggleByte() {
            byteActive = !byteActive;
            const byteBtn = document.getElementById('byte-btn');
            const consoleDiv = document.getElementById('console');
            byteBtn.classList.toggle('active-byte', byteActive);
            consoleDiv.classList.toggle('active-byte', byteActive);
            log(byteActive ? 'Byte: Eco monitoring activated.' : 'Byte: Eco monitoring deactivated.', true);

            if (byteActive) {
                byteStartTime = new Date();
                anomalyLog = []; // Reset anomaly log
                if (!anomalyModel) {
                    anomalyModel = await loadAnomalyModel();
                    log('TensorFlow.js anomaly detection model loaded.', true);
                }
                secureConnection();
                await sendPacket();
                await updateEcoStats();
                connectionInterval = setInterval(() => {
                    if (window.requestIdleCallback) {
                        window.requestIdleCallback(async () => {
                            await sendPacket();
                            await updateEcoStats();
                        }, { timeout: 1000 });
                    } else {
                        setTimeout(async () => {
                            await sendPacket();
                            await updateEcoStats();
                        }, 5000);
                    }
                }, 5000);
            } else {
                clearInterval(connectionInterval);
                log('Byte: Monitoring stopped.', true);
                const report = await generateByteReport();
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(report).then(() => {
                        log('Eco Monitoring Report copied to clipboard', true);
                    }).catch(err => {
                        log(`Copy Error: ${err.message}`, true);
                    });
                } else {
                    const textarea = document.createElement('textarea');
                    textarea.value = report;
                    document.body.appendChild(textarea);
                    textarea.select();
                    try {
                        document.execCommand('copy');
                        log('Eco Monitoring Report copied (fallback)', true);
                    } catch (err) {
                        log(`Copy Error: ${err.message}`, true);
                    }
                    document.body.removeChild(textarea);
                }
            }
        }

        async function bark() {
            debugLog('Bark button clicked');
            triggerGlow();
            try {
                const barkBtn = document.getElementById('bark-btn');
                barkBtn.disabled = true;
                log('Initializing advanced energy profiling...', true);

                const agent = new AdvancedAgent('Watchdog', tests);
                const results = await agent.runTests();
                const metrics = calculateMetrics(results);

                log('Final Results:', true);
                log(`Eco Score: ${metrics.normalizedScore}/100`);
                log(`Carbon Footprint: ${metrics.carbonFootprint}kg CO2/h`);
                log('Description: Watchdog AI BETA tests browser efficiency.');

                const { isMobile } = agent;
                let report = `Watchdog AI BETA Energy Certificate\n\n`;
                report += `Verification of Completion: Test completed on ${new Date().toLocaleString()}\n`;
                report += `Device: ${isMobile ? 'Mobile' : 'Desktop'} | Browser: ${navigator.userAgent}\n\n`;
                report += `Description: Watchdog AI BETA dynamically tests browser energy efficiency.\n\n`;
                report += `Scores (0-10):\n`;
                results.forEach(result => {
                    report += `${result.name}: ${result.score}/10 (${result.details})\n`;
                });

                const worstTest = results.reduce((worst, result) => {
                    if (result.score < worst.score) return result;
                    if (result.score === worst.score) {
                        const priority = { cpu: 1, memory: 2, rendering: 3, dom: 4, eventloop: 5, battery: 6, display: 7 };
                        return priority[result.category] < priority[worst.category] ? result : worst;
                    }
                    return worst;
                }, results[0]);

                const tip = enhancementTips[worstTest.name](worstTest, isMobile);

                report += `\nEco Score: ${metrics.normalizedScore}/100\n`;
                report += `Carbon Footprint: ${metrics.carbonFootprint}kg CO2/h\n`;
                report += `\nWorst: ${worstTest.name} (${worstTest.score}/10)\n`;
                report += `Next Steps:\n${tip.tips}`;
                report += `\nEnergy Enhancement Tip:\n${tip.message}\n`;
                report += `\nÂ© 2025 WebXOS - Watchdog AI BETA`;

                log(tip.message, true);

                if (navigator.clipboard) {
                    navigator.clipboard.writeText(report).then(() => log('Certificate copied', true)).catch(err => log(`Copy Error: ${err.message}`, true));
                } else {
                    const textarea = document.createElement('textarea');
                    textarea.value = report;
                    document.body.appendChild(textarea);
                    textarea.select();
                    try {
                        document.execCommand('copy');
                        log('Certificate copied (fallback)', true);
                    } catch (err) {
                        log(`Copy Error: ${err.message}`, true);
                    }
                    document.body.removeChild(textarea);
                }

                lastTestResults = null;
                log('Data destroyed.', true);
                barkBtn.disabled = false;
            } catch (err) {
                log(`Bark Error: ${err.message}`, true);
                debugLog(`Bark Error: ${err.stack}`);
                barkBtn.disabled = false;
            }
        }

        const debounce = (func, wait) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        };

        document.getElementById('bark-btn').addEventListener('click', debounce(() => {
            debugLog('Bark button clicked via event listener');
            bark();
        }, 200));
        document.getElementById('byte-btn').addEventListener('click', debounce(() => {
            debugLog('Byte button clicked via event listener');
            toggleByte();
        }, 200));
        document.getElementById('reset-btn').addEventListener('click', debounce(() => {
            debugLog('Reset button clicked via event listener');
            resetConsole();
        }, 200));

        document.addEventListener('keydown', e => {
            debugLog(`Key pressed: ${e.key}`);
            if (e.key === 'Enter' || e.key === ' ') bark();
            else if (e.key === 'b' || e.key === 'B') toggleByte();
            else if (e.key === 'r' || e.key === 'R') resetConsole();
        });

        log('Watchdog AI BETA User Guide: Bark: Run tests & report | Byte: Toggle eco monitoring | Reset: Clear console', true);
    </script>
</body>
</html>
