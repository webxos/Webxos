<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Post API</title>
    <style>
        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            max-width: 800px;
            width: 100%;
        }
        .card {
            background: #111;
            border: 2px solid #0f0;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        input, button {
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            margin: 5px;
            font-family: 'Courier New', monospace;
        }
        input {
            width: calc(100% - 22px);
        }
        button {
            cursor: pointer;
        }
        button:hover {
            background: #0f0;
            color: #000;
        }
        .post {
            background: #111;
            border: 1px solid #0f0;
            padding: 10px;
            margin: 10px 0;
        }
        .hidden {
            display: none;
        }
        #apiKeyDisplay, #serialDisplay {
            word-break: break-all;
            text-overflow: ellipsis;
        }
        @media (max-width: 600px) {
            input, button {
                width: calc(100% - 22px);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="setup" class="card">
            <h2>Create API</h2>
            <input id="apiName" placeholder="API Name (e.g., API-MyBoard)" pattern="API-[A-Za-z0-9]+" required>
            <button onclick="createBulletin()">Create</button>
            <h2>Join API</h2>
            <input id="joinApiKey" placeholder="API Key (API-xxxxxx)">
            <input id="joinApiName" placeholder="API Name (e.g., API-MyBoard)">
            <input id="joinSerial" placeholder="Serial">
            <button onclick="joinBulletin()">Join</button>
        </div>
        <div id="board" class="card hidden">
            <h2 id="boardTitle"></h2>
            <p>API Key: <span id="apiKeyDisplay"></span> <button onclick="copyText('apiKeyDisplay')">Copy</button></p>
            <p>Serial: <span id="serialDisplay"></span> <button onclick="copyText('serialDisplay')">Copy</button></p>
            <input id="postMessage" placeholder="Enter message">
            <input id="postFile" type="file">
            <button onclick="submitPost()">Post</button>
            <div id="posts"></div>
        </div>
    </div>

    <script>
        const virtualWorkerCode = `
            const signalingStore = new Map();
            const apiStore = new Map();
            self.onmessage = async ({ data }) => {
                if (data.type === 'init') {
                    self.db = await initIndexedDB();
                } else if (data.type === 'create') {
                    const { apiName, serial } = data;
                    const key = await deriveKeyFromApiName(apiName);
                    const apiKey = await generateApiKey(apiName, serial);
                    apiStore.set(apiName, { key, apiKey, serial });
                    startSignalingServer(apiName, serial);
                    self.postMessage({ type: 'created', apiKey, serial });
                } else if (data.type === 'join') {
                    const { apiKey, apiName, serial } = data;
                    const key = await deriveKeyFromApiName(apiName);
                    const decrypted = await decryptApiKey(apiKey, key, serial);
                    if (decrypted) {
                        apiStore.set(apiName, { key, apiKey, serial });
                        await joinWebRTC(apiName, serial);
                        self.postMessage({ type: 'joined', apiName, serial });
                    }
                } else if (data.type === 'post') {
                    const { apiName, serial, message, file } = data;
                    const postId = crypto.randomUUID();
                    const postKey = await crypto.subtle.generateKey({ name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']);
                    const iv = crypto.getRandomValues(new Uint8Array(12));
                    const encryptedMessage = message ? await crypto.subtle.encrypt(
                        { name: 'AES-GCM', iv }, postKey, new TextEncoder().encode(message)
                    ) : null;
                    const post = { id: postId, message: encryptedMessage ? Array.from(new Uint8Array(encryptedMessage)) : null, file, iv: Array.from(iv) };
                    await self.db.posts.add({ apiName, serial, postId, post });
                    const newApiKey = await generateApiKey(apiName, serial);
                    apiStore.set(apiName, { ...apiStore.get(apiName), apiKey: newApiKey });
                    syncApiKey(apiName, serial, newApiKey);
                    broadcastPost(apiName, post);
                    self.postMessage({ type: 'posted', apiKey: newApiKey });
                } else if (data.type === 'signal') {
                    handleSignalingMessage(data.message);
                }
            };

            async function initIndexedDB() {
                return new Promise((resolve) => {
                    const req = indexedDB.open('post-api', 3);
                    req.onupgradeneeded = () => {
                        const db = req.result;
                        db.createObjectStore('apiKeys', { keyPath: 'apiName' });
                        db.createObjectStore('posts', { keyPath: 'postId' });
                        db.createObjectStore('signaling', { keyPath: 'id' });
                    };
                    req.onsuccess = () => resolve(req.result);
                });
            }

            async function deriveKeyFromApiName(apiName) {
                const encoder = new TextEncoder();
                const baseKey = await crypto.subtle.importKey(
                    'raw', encoder.encode(apiName + 'post-api-salt-v3'), { name: 'PBKDF2' }, false, ['deriveBits', 'deriveKey']
                );
                return await crypto.subtle.deriveKey(
                    { name: 'PBKDF2', salt: encoder.encode('post-api-salt-v3'), iterations: 100000, hash: 'SHA-256' },
                    baseKey,
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );
            }

            async function generateApiKey(apiName, serial) {
                const key = await deriveKeyFromApiName(apiName);
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const data = new TextEncoder().encode(\`\${apiName}:\${crypto.randomUUID()}:\${serial}:\${Date.now()}\`);
                const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, data);
                return 'API-' + btoa(String.fromCharCode(...iv, ...new Uint8Array(encrypted)));
            }

            async function decryptApiKey(apiKey, key, serial) {
                try {
                    const data = atob(apiKey.replace('API-', '')).split('').map(c => c.charCodeAt(0));
                    const iv = data.slice(0, 12);
                    const encrypted = data.slice(12);
                    const decrypted = await crypto.subtle.decrypt(
                        { name: 'AES-GCM', iv: new Uint8Array(iv) }, key, new Uint8Array(encrypted)
                    );
                    const [apiName, , serialCheck, ] = new TextDecoder().decode(decrypted).split(':');
                    return serialCheck === serial ? apiName : null;
                } catch {
                    return null;
                }
            }

            function startSignalingServer(apiName, serial) {
                signalingStore.set(\`\${apiName}:\${serial}\`, { offers: [], candidates: [] });
            }

            async function handleSignalingMessage({ apiName, serial, type, data }) {
                const key = \`\${apiName}:\${serial}\`;
                const store = signalingStore.get(key) || { offers: [], candidates: [] };
                if (type === 'offer') {
                    store.offers.push(data);
                    signalingStore.set(key, store);
                    broadcastSignal(apiName, serial, { type: 'offer', data });
                } else if (type === 'answer') {
                    store.offers = store.offers.filter(o => o.sdp !== data.sdp);
                    signalingStore.set(key, store);
                    broadcastSignal(apiName, serial, { type: 'answer', data });
                } else if (type === 'candidate') {
                    store.candidates.push(data);
                    signalingStore.set(key, store);
                    broadcastSignal(apiName, serial, { type: 'candidate', data });
                }
                await saveSignalingMessage({ id: crypto.randomUUID(), apiName, serial, type, data });
            }

            async function saveSignalingMessage(message) {
                const tx = self.db.transaction(['signaling'], 'readwrite');
                await tx.objectStore('signaling').add(message);
            }

            let peerConnection, dataChannel;
            async function joinWebRTC(apiName, serial) {
                peerConnection = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
                dataChannel = peerConnection.createDataChannel('data');
                dataChannel.onopen = () => syncApiKey(apiName, serial, apiStore.get(apiName).apiKey);
                dataChannel.onmessage = ({ data }) => {
                    const msg = JSON.parse(data);
                    if (msg.type === 'post') displayPost(msg.post);
                    if (msg.type === 'apiKey') self.postMessage({ type: 'apiKey', apiKey: msg.apiKey });
                };
                peerConnection.onicecandidate = ({ candidate }) => {
                    if (candidate) broadcastSignal(apiName, serial, { type: 'candidate', data: candidate });
                };
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                broadcastSignal(apiName, serial, { type: 'offer', data: { sdp: offer.sdp, type: offer.type } });
                const tx = self.db.transaction(['signaling'], 'readonly');
                const messages = await tx.objectStore('signaling').getAll();
                for (const msg of messages.filter(m => m.apiName === apiName && m.serial === serial)) {
                    if (msg.type === 'answer') {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.data));
                    } else if (msg.type === 'candidate') {
raspberrypi
                    peerConnection.addIceCandidate(new RTCIceCandidate(msg.data));
                }
            }

            function broadcastSignal(apiName, serial, message) {
                if (dataChannel?.readyState === 'open') {
                    dataChannel.send(JSON.stringify({ type: 'signal', apiName, serial, ...message }));
                }
            }

            function broadcastPost(apiName, post) {
                if (dataChannel?.readyState === 'open') {
                    dataChannel.send(JSON.stringify({ type: 'post', post }));
                }
            }

            function syncApiKey(apiName, serial, apiKey) {
                if (dataChannel?.readyState === 'open') {
                    dataChannel.send(JSON.stringify({ type: 'apiKey', apiName, serial, apiKey }));
                }
            }

            function displayPost(post) {
                self.postMessage({ type: 'displayPost', post });
            }
        `;

        const channel = new MessageChannel();
        const virtualWorker = channel.port1;
        virtualWorker.onmessage = ({ data }) => {
            if (data.type === 'created') {
                currentApiKey = data.apiKey;
                currentSerial = data.serial;
                document.getElementById('boardTitle').textContent = currentApiName;
                document.getElementById('apiKeyDisplay').textContent = data.apiKey;
                document.getElementById('serialDisplay').textContent = data.serial;
                document.getElementById('setup').classList.add('hidden');
                document.getElementById('board').classList.remove('hidden');
            } else if (data.type === 'joined') {
                currentApiName = data.apiName;
                currentSerial = data.serial;
                document.getElementById('boardTitle').textContent = data.apiName;
                document.getElementById('setup').classList.add('hidden');
                document.getElementById('board').classList.remove('hidden');
            } else if (data.type === 'posted') {
                document.getElementById('apiKeyDisplay').textContent = data.apiKey;
                currentApiKey = data.apiKey;
            } else if (data.type === 'displayPost') {
                const postDiv = document.createElement('div');
                postDiv.className = 'post';
                if (data.post.message) {
                    postDiv.textContent = `Message: ${data.post.message}`;
                } else if (data.post.file) {
                    postDiv.textContent = `File: ${data.post.file.name}`;
                }
                document.getElementById('posts').prepend(postDiv);
            }
        };

        let currentApiName, currentApiKey, currentSerial;
        virtualWorker.postMessage({ type: 'init' });

        function createBulletin() {
            const apiName = document.getElementById('apiName').value;
            if (!apiName.match(/^API-[A-Za-z0-9]+$/)) return;
            currentApiName = apiName;
            const serial = crypto.randomUUID();
            virtualWorker.postMessage({ type: 'create', apiName, serial });
        }

        function joinBulletin() {
            const apiKey = document.getElementById('joinApiKey').value;
            const apiName = document.getElementById('joinApiName').value;
            const serial = document.getElementById('joinSerial').value;
            virtualWorker.postMessage({ type: 'join', apiKey, apiName, serial });
        }

        async function submitPost() {
            virtualWorker.postMessage({
                type: 'post',
                apiName: currentApiName,
                serial: currentSerial,
                message: document.getElementById('postMessage').value,
                file: document.getElementById('postFile').files[0]
            });
            document.getElementById('postMessage').value = '';
            document.getElementById('postFile').value = '';
        }

        function copyText(id) {
            navigator.clipboard.write(document.getElementById(id).textContent);
        }

        window.onunload = () => {
            indexedDB.deleteDatabase('post-api');
            if (peerConnection) peerConnection.close();
        };

        (function initVirtualWorker() {
            const script = document.createElement('script');
            script.textContent = virtualWorkerCode;
            document.head.appendChild(script);
            channel.port2.postMessage({});
        })();
    </script>
</body>
</html>
