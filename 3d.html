<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebX Universe 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Orbitron', -apple-system, BlinkMacSystemFont, sans-serif;
        }
        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            touch-action: none;
        }
        #gameCanvas {
            flex: 1;
            width: 100%;
            position: relative;
        }
        .controls {
            position: fixed;
            bottom: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            z-index: 10;
        }
        .joystick-container {
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }
        .joystick {
            width: 50px;
            height: 50px;
            background: #ff4444;
            border-radius: 50%;
            position: absolute;
            top: 25px;
            left: 25px;
            transform: translate(0, 0);
        }
        .action-buttons {
            display: flex;
            gap: 10px;
        }
        button {
            background: #4a90e2;
            border: none;
            padding: 15px;
            color: white;
            border-radius: 50%;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        button:active {
            transform: scale(0.9);
        }
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            color: #ff4444;
            font-size: 14px;
            z-index: 5;
        }
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: #ff4444;
        }
        .status {
            position: absolute;
            top: 10px;
            left: 10px;
        }
        .quest-log {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px;
            max-width: 200px;
        }
        .footer {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            font-size: 10px;
            color: #fff;
            z-index: 5;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="gameCanvas">
        <div class="hud">
            <div class="crosshair">+</div>
            <div class="status" id="status">Health: 100 | Ammo: 50</div>
            <div class="quest-log" id="questLog">Quest: Find the Data Core</div>
        </div>
    </div>
    <div class="controls">
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick" id="joystick"></div>
        </div>
        <div class="action-buttons">
            <button id="shootBtn">B</button>
            <button id="sprintBtn">Sprint</button>
        </div>
    </div>
    <div class="footer">Â© 2025 WebXOS - WebX Universe 3D</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        window.onload = () => {
            try {
                // Scene setup
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('gameCanvas').appendChild(renderer.domElement);

                camera.position.set(0, 1.6, 0); // Eye-level for FPS

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xff9999, 0.8); // Red-tinted light for desert
                directionalLight.position.set(5, 10, 5);
                scene.add(directionalLight);

                // Red desert terrain
                const terrainGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
                const terrainMaterial = new THREE.MeshStandardMaterial({ color: 0xcc3333, roughness: 0.8 });
                const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
                terrain.rotation.x = -Math.PI / 2;
                terrain.position.y = -0.5;
                scene.add(terrain);

                // Sky with planets
                const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
                const skyMaterial = new THREE.MeshBasicMaterial({ color: 0x220022, side: THREE.BackSide });
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                scene.add(sky);

                const planetGeometry = new THREE.SphereGeometry(20, 16, 16);
                const planetMaterial = new THREE.MeshBasicMaterial({ color: 0x6666cc });
                const planet = new THREE.Mesh(planetGeometry, planetMaterial);
                planet.position.set(100, 100, -300);
                scene.add(planet);

                // Towns (simple structures)
                const townGeometry = new THREE.BoxGeometry(5, 3, 5);
                const townMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
                for (let i = 0; i < 5; i++) {
                    const town = new THREE.Mesh(townGeometry, townMaterial);
                    town.position.set(
                        (Math.random() - 0.5) * 80,
                        1.5,
                        (Math.random() - 0.5) * 80
                    );
                    scene.add(town);
                }

                // Alien block data enemies
                const enemyGeometry = new THREE.BoxGeometry(1, 1, 1);
                const enemyMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const enemies = [];
                for (let i = 0; i < 10; i++) {
                    const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                    enemy.position.set(
                        (Math.random() - 0.5) * 50,
                        0.5,
                        (Math.random() - 0.5) * 50
                    );
                    enemy.userData = { health: 50, velocity: new THREE.Vector3() };
                    scene.add(enemy);
                    enemies.push(enemy);
                }

                // Player state
                const player = {
                    health: 100,
                    ammo: 50,
                    speed: 5,
                    sprintSpeed: 10,
                    velocity: new THREE.Vector3(),
                    rotation: { pitch: 0, yaw: 0 },
                    rotationVelocity: { pitch: 0, yaw: 0 },
                    isSprinting: false
                };

                // Joystick controls
                const joystickContainer = document.getElementById('joystickContainer');
                const joystick = document.getElementById('joystick');
                let joystickActive = false;
                let joystickOrigin = { x: 0, y: 0 };
                let joystickDelta = { x: 0, y: 0 };

                joystickContainer.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    joystickActive = true;
                    const touch = e.touches[0];
                    joystickOrigin = { x: touch.clientX, y: touch.clientY };
                });

                joystickContainer.addEventListener('touchmove', (e) => {
                    if (!joystickActive) return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    const dx = touch.clientX - joystickOrigin.x;
                    const dy = touch.clientY - joystickOrigin.y;
                    const maxRadius = 50;
                    const magnitude = Math.sqrt(dx * dx + dy * dy);
                    if (magnitude > maxRadius) {
                        const scale = maxRadius / magnitude;
                        joystickDelta.x = dx * scale;
                        joystickDelta.y = dy * scale;
                    } else {
                        joystickDelta.x = dx;
                        joystickDelta.y = dy;
                    }
                    joystick.style.transform = `translate(${joystickDelta.x}px, ${joystickDelta.y}px)`;
                });

                joystickContainer.addEventListener('touchend', () => {
                    joystickActive = false;
                    joystickDelta = { x: 0, y: 0 };
                    joystick.style.transform = `translate(0, 0)`;
                });

                // Action buttons
                document.getElementById('shootBtn').addEventListener('click', () => {
                    if (player.ammo > 0) {
                        shoot();
                        player.ammo--;
                        updateHUD();
                    }
                });

                document.getElementById('sprintBtn').addEventListener('touchstart', () => {
                    player.isSprinting = true;
                });
                document.getElementById('sprintBtn').addEventListener('touchend', () => {
                    player.isSprinting = false;
                });

                // Mouse/touch look controls
                let isLooking = false;
                let previousTouch = { x: 0, y: 0 };
                document.getElementById('gameCanvas').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    isLooking = true;
                    previousTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                });

                document.getElementById('gameCanvas').addEventListener('touchmove', (e) => {
                    if (!isLooking) return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - previousTouch.x;
                    const deltaY = touch.clientY - previousTouch.y;
                    player.rotationVelocity.yaw -= deltaX * 0.005;
                    player.rotationVelocity.pitch -= deltaY * 0.005;
                    previousTouch = { x: touch.clientX, y: touch.clientY };
                });

                document.getElementById('gameCanvas').addEventListener('touchend', () => {
                    isLooking = false;
                });

                // Shooting mechanics
                const projectiles = [];
                function shoot() {
                    const projectileGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const projectileMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    projectile.position.copy(camera.position).add(forward.multiplyScalar(0.5));
                    projectile.userData = { velocity: forward.multiplyScalar(20), remove: false };
                    scene.add(projectile);
                    projectiles.push(projectile);
                }

                // Quest system
                const quests = [
                    { id: 1, text: "Find the Data Core", target: new THREE.Vector3(20, 0, -20) },
                    { id: 2, text: "Defeat 5 Data Blocks", kills: 0, targetKills: 5 }
                ];
                let currentQuest = quests[0];

                function updateHUD() {
                    document.getElementById('status').textContent = `Health: ${player.health} | Ammo: ${player.ammo}`;
                    document.getElementById('questLog').textContent = `Quest: ${currentQuest.text}`;
                }

                // Physics and gravity
                const gravity = -9.8;
                const groundY = -0.5;

                // Animation loop
                let lastTime = performance.now();
                function animate() {
                    requestAnimationFrame(animate);
                    const now = performance.now();
                    const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
                    lastTime = now;

                    // Player rotation
                    player.rotation.pitch += player.rotationVelocity.pitch * deltaTime;
                    player.rotation.yaw += player.rotationVelocity.yaw * deltaTime;
                    player.rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.pitch));
                    player.rotationVelocity.pitch *= 0.95;
                    player.rotationVelocity.yaw *= 0.95;
                    camera.quaternion.setFromEuler(new THREE.Euler(player.rotation.pitch, player.rotation.yaw, 0, 'YXZ'));

                    // Player movement
                    const speed = player.isSprinting ? player.sprintSpeed : player.speed;
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    player.velocity.set(0, player.velocity.y, 0);
                    if (joystickActive) {
                        const moveX = joystickDelta.x / 50;
                        const moveZ = joystickDelta.y / 50;
                        player.velocity.add(right.multiplyScalar(moveX * speed));
                        player.velocity.add(forward.multiplyScalar(-moveZ * speed));
                    }
                    player.velocity.y += gravity * deltaTime;
                    camera.position.add(player.velocity.clone().multiplyScalar(deltaTime));

                    // Ground collision
                    if (camera.position.y < 1.6 + groundY) {
                        camera.position.y = 1.6 + groundY;
                        player.velocity.y = 0;
                    }

                    // Enemy AI
                    enemies.forEach((enemy) => {
                        const direction = camera.position.clone().sub(enemy.position).normalize();
                        enemy.userData.velocity.copy(direction.multiplyScalar(2));
                        enemy.position.add(enemy.userData.velocity.clone().multiplyScalar(deltaTime));
                        enemy.position.y = 0.5; // Stay on ground
                    });

                    // Projectile updates
                    const projectilesToRemove = [];
                    projectiles.forEach((projectile, i) => {
                        projectile.position.add(projectile.userData.velocity.clone().multiplyScalar(deltaTime));
                        if (projectile.position.length() > 100) {
                            projectile.userData.remove = true;
                            projectilesToRemove.push(i);
                        }
                        enemies.forEach((enemy, j) => {
                            if (projectile.position.distanceTo(enemy.position) < 1) {
                                enemy.userData.health -= 25;
                                projectile.userData.remove = true;
                                projectilesToRemove.push(i);
                                if (enemy.userData.health <= 0) {
                                    scene.remove(enemy);
                                    enemies.splice(j, 1);
                                    if (currentQuest.id === 2) {
                                        currentQuest.kills++;
                                        if (currentQuest.kills >= currentQuest.targetKills) {
                                            currentQuest = quests[0]; // Reset or advance
                                        }
                                        updateHUD();
                                    }
                                }
                            }
                        });
                    });
                    projectilesToRemove.sort((a, b) => b - a).forEach((i) => {
                        scene.remove(projectiles[i]);
                        projectiles.splice(i, 1);
                    });

                    // Quest progress
                    if (currentQuest.id === 1 && camera.position.distanceTo(currentQuest.target) < 5) {
                        currentQuest = quests[1];
                        updateHUD();
                    }

                    renderer.render(scene, camera);
                }

                // Resize handling
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // Initialize
                updateHUD();
                animate();
            } catch (e) {
                console.error('Game initialization error:', e);
            }
        };
    </script>
</body>
</html>
