<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="description" content="CHAT API by WebXOS is a lightweight, browser-based, offline-capable chat system for private and public networks. Secure, peer-to-peer messaging and file sharing with a minimalist terminal-style UI, with API access to chat data.">
    <meta name="keywords" content="private chat, secure messaging, WebRTC chat, offline chat, browser-based chat, lightweight chat app, peer-to-peer chat, minimalist chat, terminal-style chat, public chat rooms, WebXOS, private network chat, decentralized chat, client-side chat, API chat data">
    <meta name="author" content="WebXOS">
    <meta name="robots" content="index, follow">
    <!-- Twitter Meta Tags -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="CHAT API by WebXOS">
    <meta name="twitter:description" content="A lightweight, browser-based chat system for private and public networks with API access to chat logs and a minimalist terminal UI.">
    <meta name="twitter:site" content="@webxos">
    <meta name="twitter:creator" content="@webxos">
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="CHAT API by WebXOS">
    <meta property="og:description" content="Secure, lightweight chat for private and public networks. Browser-based, offline-capable, with API access and a retro terminal interface.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://chatapi.webxos.com">
    <meta property="og:site_name" content="CHAT API by WebXOS">
    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "SoftwareApplication",
        "name": "CHAT API by WebXOS",
        "applicationCategory": "Communication",
        "operatingSystem": "Web",
        "description": "A lightweight, browser-based chat system for private and public networks with WebRTC for peer-to-peer messaging, file sharing, API access to chat data, and a minimalist terminal-style UI.",
        "author": {
            "@type": "Organization",
            "name": "WebXOS",
            "sameAs": [
                "https://twitter.com/webxos",
                "https://twitter.com/webxos_ai",
                "https://twitter.com/webxos_games"
            ]
        },
        "featureList": [
            "Private chat rooms",
            "Public chat rooms",
            "Secure messaging",
            "File sharing",
            "Offline capability",
            "WebRTC peer-to-peer",
            "API access",
            "Minimalist UI"
        ]
    }
    </script>
    <title>CHAT API by WebXOS</title>
    <style>
        body {
            background-color: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            font-size: 16px;
        }
        h1 {
            text-align: center;
            font-size: 5vw;
            text-shadow: 0 0 5px #0f0;
            margin: 10px 0;
        }
        #start-menu, #container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px;
            max-width: 800px;
            margin: 0 auto;
        }
        #container { display: none; }
        #start-menu button, #modal-content button, #chat button, #profile button {
            background: #111;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 12px;
            font-size: 4vw;
            cursor: pointer;
            border-radius: 5px;
            width: 80%;
            max-width: 300px;
            transition: background 0.3s, color 0.3s;
            touch-action: manipulation;
        }
        #start-menu button:hover, #modal-content button:hover, #chat button:hover, #profile button:hover {
            background: #0f0;
            color: #000;
        }
        #modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #modal-content {
            background: #111;
            padding: 20px;
            border: 1px solid #0f0;
            border-radius: 5px;
            width: 90%;
            max-width: 400px;
            text-align: center;
        }
        #modal-content input, #modal-content select {
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            width: 100%;
            box-sizing: border-box;
            font-size: 4vw;
            border-radius: 3px;
        }
        #modal-content input[type="checkbox"] {
            width: auto;
            margin: 10px 5px;
        }
        #chat, #profile {
            width: 100%;
            border: 1px solid #0f0;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 5px #0f0;
        }
        #chat-messages {
            height: 50vh;
            overflow-y: auto;
            border: 1px solid #0f0;
            padding: 10px;
            margin-bottom: 10px;
            background: #111;
        }
        .message {
            margin: 8px 0;
            word-wrap: break-word;
        }
        .message img {
            max-width: 70%;
            border-radius: 5px;
            margin: 5px 0;
        }
        .message a {
            color: #0f0;
            text-decoration: underline;
        }
        #chat input {
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            margin: 5px 0;
            font-family: 'Courier New', monospace;
            width: 100%;
            box-sizing: border-box;
            font-size: 4vw;
            border-radius: 3px;
        }
        #file-input {
            padding: 5px;
        }
        #footer {
            text-align: center;
            font-size: 3vw;
            margin: 10px 0;
            text-shadow: 0 0 3px #0f0;
        }
        @media (min-width: 768px) {
            body { font-size: 18px; }
            h1 { font-size: 2.5em; }
            #start-menu button, #modal-content button, #chat button, #profile button { font-size: 1.2em; max-width: 400px; }
            #modal-content input, #modal-content select, #chat input { font-size: 1.1em; }
            #container { max-width: 1200px; }
            #chat-messages { height: 60vh; }
        }
        @media (max-width: 600px) {
            body { font-size: 14px; }
            h1 { font-size: 6vw; }
            #start-menu button, #modal-content button, #chat button, #profile button { font-size: 5vw; }
            #modal-content input, #modal-content select, #chat input { font-size: 5vw; }
        }
    </style>
</head>
<body>
    <div id="start-menu">
        <h1>CHAT API by WebXOS</h1>
        <button onclick="showCreateRoomModal()">Create Room</button>
        <button onclick="showJoinRoomModal()">Join Room</button>
    </div>
    <div id="modal">
        <div id="modal-content">
            <h2 id="modal-title">Create Room</h2>
            <input type="text" id="username-input" placeholder="Enter Username">
            <input type="password" id="password-input" placeholder="Set Room Password">
            <input type="text" id="creator-input" placeholder="Creator's Username" style="display: none;">
            <input type="text" id="api-key-input" placeholder="API Key (Room ID)" readonly>
            <label><input type="checkbox" id="public-room"> Make Room Public</label>
            <select id="public-rooms" style="display: none;">
                <option value="">Select Public Room</option>
            </select>
            <button id="modal-action" onclick="handleModalAction()">Create Room</button>
        </div>
    </div>
    <div id="container">
        <h1>CHAT API by WebXOS</h1>
        <div id="profile">
            <h2>Profile</h2>
            <div>Username: <span id="username"></span></div>
            <div>Room ID: <span id="room-id"></span> <button onclick="copyRoomId()">Copy</button></div>
            <div>API Key: <span id="api-key"></span> <button onclick="copyApiKey()">Copy</button></div>
        </div>
        <div id="chat">
            <h2>Messages</h2>
            <div id="chat-messages"></div>
            <input type="text" id="message-input" placeholder="Type a message...">
            <input type="file" id="file-input" accept="image/*,*">
            <button onclick="sendMessage()">Send</button>
        </div>
    </div>
    <div id="footer">Â© CHAT API by WebXOS 2025</div>

    <script>
        // Virtual Server (In-Memory Storage)
        let virtualServer = JSON.parse(localStorage.getItem('virtualServer')) || {
            agents: {},
            rooms: {},
            messages: {},
            files: {},
            signaling: {}
        };

        // Generate UUID for API Key (Room ID)
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0;
                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }

        // WebRTC Setup
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };
        let peerConnections = {};
        let dataChannels = {};
        let apiKey = localStorage.getItem('apiKey');
        let username = localStorage.getItem('username');
        let currentRoom = '';
        let isCreator = false;
        let connectionAttempts = 0;
        const maxAttempts = 5;

        // Simulate cross-tab/device communication
        window.addEventListener('storage', event => {
            if (event.key === 'virtualServerUpdate') {
                const update = JSON.parse(event.newValue);
                if (update.roomId === currentRoom) {
                    virtualServer = { ...virtualServer, ...update.data };
                    localStorage.setItem('virtualServer', JSON.stringify(virtualServer));
                    checkSignalingData();
                    loadMessages();
                    loadPublicRooms();
                }
            }
        });

        function broadcastVirtualServer() {
            localStorage.setItem('virtualServerUpdate', JSON.stringify({ roomId: currentRoom, data: virtualServer }));
            localStorage.removeItem('virtualServerUpdate');
        }

        function checkLogin() {
            if (apiKey && username && virtualServer.rooms[apiKey]) {
                currentRoom = apiKey;
                isCreator = virtualServer.rooms[apiKey].creator === username;
                initializeApp(virtualServer.rooms[apiKey].public, virtualServer.rooms[apiKey].password);
            } else {
                document.getElementById('start-menu').style.display = 'flex';
            }
        }

        function showCreateRoomModal() {
            document.getElementById('modal-title').textContent = 'Create Room';
            document.getElementById('modal-action').textContent = 'Create Room';
            document.getElementById('api-key-input').value = generateUUID();
            document.getElementById('api-key-input').readOnly = true;
            document.getElementById('username-input').value = username || '';
            document.getElementById('password-input').style.display = 'block';
            document.getElementById('password-input').value = '';
            document.getElementById('creator-input').style.display = 'none';
            document.getElementById('public-room').style.display = 'block';
            document.getElementById('public-rooms').style.display = 'none';
            document.getElementById('modal').style.display = 'flex';
            document.getElementById('modal-action').onclick = handleCreateRoom;
        }

        function showJoinRoomModal() {
            document.getElementById('modal-title').textContent = 'Join Room';
            document.getElementById('modal-action').textContent = 'Join Room';
            document.getElementById('api-key-input').value = '';
            document.getElementById('api-key-input').readOnly = false;
            document.getElementById('username-input').value = username || '';
            document.getElementById('password-input').style.display = 'block';
            document.getElementById('password-input').value = '';
            document.getElementById('creator-input').style.display = 'block';
            document.getElementById('public-room').style.display = 'none';
            document.getElementById('public-rooms').style.display = 'block';
            document.getElementById('modal').style.display = 'flex';
            document.getElementById('modal-action').onclick = handleJoinRoom;
            loadPublicRooms();
        }

        function loadPublicRooms() {
            const select = document.getElementById('public-rooms');
            select.innerHTML = '<option value="">Select Public Room</option>';
            Object.values(virtualServer.rooms).forEach(room => {
                if (room.public) {
                    const option = document.createElement('option');
                    option.value = room.id;
                    option.textContent = `Room ${room.id.slice(0, 8)}... (Creator: ${room.creator})`;
                    select.appendChild(option);
                }
            });
        }

        function handleCreateRoom() {
            username = document.getElementById('username-input').value.trim() || `Agent_${Math.random().toString(36).substr(2, 5)}`;
            const password = document.getElementById('password-input').value.trim();
            apiKey = document.getElementById('api-key-input').value.trim();
            const isPublic = document.getElementById('public-room').checked;
            if (username && password && apiKey) {
                localStorage.setItem('apiKey', apiKey);
                localStorage.setItem('username', username);
                currentRoom = apiKey;
                isCreator = true;
                initializeApp(isPublic, password);
            } else {
                alert('Please enter a username and password.');
            }
        }

        function handleJoinRoom() {
            username = document.getElementById('username-input').value.trim() || `Agent_${Math.random().toString(36).substr(2, 5)}`;
            const password = document.getElementById('password-input').value.trim();
            const creator = document.getElementById('creator-input').value.trim();
            apiKey = document.getElementById('public-rooms').value || document.getElementById('api-key-input').value.trim();
            if (username && password && apiKey && creator) {
                if (!virtualServer.rooms[apiKey]) {
                    alert('Room does not exist.');
                    return;
                }
                if (virtualServer.rooms[apiKey].password !== password || virtualServer.rooms[apiKey].creator !== creator) {
                    alert('Invalid password or creator username.');
                    return;
                }
                localStorage.setItem('apiKey', apiKey);
                localStorage.setItem('username', username);
                currentRoom = apiKey;
                isCreator = false;
                initializeApp(virtualServer.rooms[apiKey].public, password);
            } else {
                alert('Please enter a username, password, room ID, and creator username.');
            }
        }

        function initializeApp(isPublic, password) {
            document.getElementById('start-menu').style.display = 'none';
            document.getElementById('modal').style.display = 'none';
            document.getElementById('container').style.display = 'flex';
            document.getElementById('username').textContent = username;
            document.getElementById('room-id').textContent = apiKey;
            document.getElementById('api-key').textContent = apiKey;

            // Save user profile and room
            virtualServer.agents[apiKey] = virtualServer.agents[apiKey] || {};
            virtualServer.agents[apiKey][username] = { id: generateUUID(), username, status: 'online' };
            virtualServer.rooms[apiKey] = virtualServer.rooms[apiKey] || { id: apiKey, creator: username, public: isPublic, password };
            virtualServer.messages[apiKey] = virtualServer.messages[apiKey] || [];
            virtualServer.files[apiKey] = virtualServer.files[apiKey] || [];
            virtualServer.signaling[apiKey] = virtualServer.signaling[apiKey] || {};
            localStorage.setItem('virtualServer', JSON.stringify(virtualServer));
            broadcastVirtualServer();
            initWebRTC();
            loadMessages();
        }

        function copyRoomId() {
            navigator.clipboard.writeText(apiKey).then(() => {
                alert('Room ID copied to clipboard!');
            }).catch(() => {
                alert('Failed to copy Room ID.');
            });
        }

        function copyApiKey() {
            navigator.clipboard.writeText(apiKey).then(() => {
                alert('API Key copied to clipboard!');
            }).catch(() => {
                alert('Failed to copy API Key.');
            });
        }

        function initWebRTC() {
            // Close existing connections
            Object.values(peerConnections).forEach(pc => pc.close());
            peerConnections = {};
            dataChannels = {};

            // Create a peer connection for each other user in the room
            const otherAgents = Object.values(virtualServer.agents[apiKey] || {}).filter(agent => agent.username !== username && agent.status === 'online');
            otherAgents.forEach(agent => {
                createPeerConnection(agent.id);
            });

            // Periodically check for new agents
            setInterval(() => {
                if (connectionAttempts < maxAttempts) {
                    const currentAgents = Object.values(virtualServer.agents[apiKey] || {}).filter(agent => agent.username !== username && agent.status === 'online');
                    currentAgents.forEach(agent => {
                        if (!peerConnections[agent.id]) {
                            createPeerConnection(agent.id);
                        }
                    });
                    checkSignalingData();
                    connectionAttempts++;
                }
            }, 3000);
        }

        function createPeerConnection(peerId) {
            const pc = new RTCPeerConnection(configuration);
            peerConnections[peerId] = pc;

            // Create data channel
            const dc = pc.createDataChannel(`chat-${currentRoom}-${peerId}`);
            dataChannels[peerId] = dc;

            dc.onmessage = event => {
                const msg = JSON.parse(event.data);
                if (msg.type === 'file') {
                    saveFile(msg);
                    appendFileMessage(msg);
                } else {
                    saveMessage(msg);
                    appendMessage(`${msg.sender}: ${msg.content}`);
                }
            };

            dc.onopen = () => {
                console.log(`Data channel open with peer ${peerId}`);
                connectionAttempts = 0;
            };
            dc.onclose = () => console.log(`Data channel closed with peer ${peerId}`);
            dc.onerror = error => console.error(`Data channel error with peer ${peerId}:`, error);

            pc.onicecandidate = event => {
                if (event.candidate) {
                    saveSignalingData({ sdp: pc.localDescription, candidate: event.candidate }, 'offer', peerId);
                }
            };

            // Create offer
            pc.createOffer()
                .then(offer => pc.setLocalDescription(offer))
                .then(() => saveSignalingData({ sdp: pc.localDescription }, 'offer', peerId))
                .catch(error => console.error('Offer creation error:', error));

            pc.oniceconnectionstatechange = () => {
                if (pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed') {
                    delete peerConnections[peerId];
                    delete dataChannels[peerId];
                    createPeerConnection(peerId); // Attempt to reconnect
                }
            };
        }

        function saveSignalingData(data, type, targetPeerId) {
            virtualServer.signaling[currentRoom] = virtualServer.signaling[currentRoom] || {};
            virtualServer.signaling[currentRoom][targetPeerId] = virtualServer.signaling[currentRoom][targetPeerId] || [];
            virtualServer.signaling[currentRoom][targetPeerId].push({ data, type, timestamp: Date.now() });
            localStorage.setItem('virtualServer', JSON.stringify(virtualServer));
            broadcastVirtualServer();
        }

        function checkSignalingData() {
            const signals = virtualServer.signaling[currentRoom] || {};
            Object.entries(signals).forEach(([peerId, signalList]) => {
                if (peerId === virtualServer.agents[apiKey][username].id) return; // Skip self
                const pc = peerConnections[peerId];
                if (!pc) return;

                const latestSignal = signalList.sort((a, b) => b.timestamp - a.timestamp)[0];
                if (latestSignal && latestSignal.data) {
                    try {
                        const data = latestSignal.data;
                        if (latestSignal.type === 'offer' && data.sdp && pc.remoteDescription?.sdp !== data.sdp.sdp) {
                            pc.setRemoteDescription(new RTCSessionDescription(data.sdp))
                                .then(() => pc.createAnswer())
                                .then(answer => pc.setLocalDescription(answer))
                                .then(() => saveSignalingData({ sdp: pc.localDescription }, 'answer', peerId))
                                .catch(error => console.error('Offer processing error:', error));
                        } else if (latestSignal.type === 'answer' && data.sdp) {
                            pc.setRemoteDescription(new RTCSessionDescription(data.sdp))
                                .catch(error => console.error('Answer processing error:', error));
                        }
                        if (data.candidate) {
                            pc.addIceCandidate(new RTCIceCandidate(data.candidate))
                                .catch(error => console.error('ICE candidate error:', error));
                        }
                    } catch (error) {
                        console.error('Signaling error:', error);
                    }
                }
            });
        }

        function sendMessage() {
            const input = document.getElementById('message-input');
            const fileInput = document.getElementById('file-input');
            if (!currentRoom) {
                alert('Please join or create a room.');
                return;
            }
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                const reader = new FileReader();
                reader.onload = () => {
                    const msgData = {
                        type: 'file',
                        sender: username,
                        room: currentRoom,
                        fileName: file.name,
                        fileData: reader.result,
                        timestamp: Date.now()
                    };
                    broadcastToPeers(msgData);
                    saveFile(msgData);
                    appendFileMessage(msgData);
                    fileInput.value = '';
                };
                reader.readAsDataURL(file);
            } else {
                const message = input.value.trim();
                if (message) {
                    const msgData = { sender: username, content: message, room: currentRoom, timestamp: Date.now() };
                    broadcastToPeers(msgData);
                    saveMessage(msgData);
                    appendMessage(`${username}: ${message}`);
                    input.value = '';
                } else {
                    alert('Please enter a message or select a file.');
                }
            }
        }

        function broadcastToPeers(msgData) {
            Object.entries(dataChannels).forEach(([peerId, dc]) => {
                if (dc.readyState === 'open') {
                    dc.send(JSON.stringify(msgData));
                }
            });
        }

        function saveMessage(msg) {
            virtualServer.messages[currentRoom].push(msg);
            localStorage.setItem('virtualServer', JSON.stringify(virtualServer));
            broadcastVirtualServer();
        }

        function saveFile(msg) {
            virtualServer.files[currentRoom].push({ id: generateUUID(), ...msg });
            localStorage.setItem('virtualServer', JSON.stringify(virtualServer));
            broadcastVirtualServer();
        }

        function appendMessage(text) {
            const messages = document.getElementById('chat-messages');
            const msgDiv = document.createElement('div');
            msgDiv.className = 'message';
            msgDiv.textContent = text;
            messages.appendChild(msgDiv);
            messages.scrollTop = messages.scrollHeight;
        }

        function appendFileMessage(msg) {
            const messages = document.getElementById('chat-messages');
            const msgDiv = document.createElement('div');
            msgDiv.className = 'message';
            if (msg.fileData.startsWith('data:image/')) {
                const img = document.createElement('img');
                img.src = msg.fileData;
                msgDiv.textContent = `${msg.sender} shared an image:`;
                msgDiv.appendChild(img);
            } else {
                const link = document.createElement('a');
                link.href = msg.fileData;
                link.download = msg.fileName;
                link.textContent = msg.fileName;
                msgDiv.textContent = `${msg.sender} shared a file: `;
                msgDiv.appendChild(link);
            }
            messages.appendChild(msgDiv);
            messages.scrollTop = messages.scrollHeight;
        }

        function loadMessages() {
            const messages = document.getElementById('chat-messages');
            messages.innerHTML = '';
            (virtualServer.messages[currentRoom] || []).sort((a, b) => a.timestamp - b.timestamp).forEach(msg => {
                appendMessage(`${msg.sender}: ${msg.content}`);
            });
            (virtualServer.files[currentRoom] || []).sort((a, b) => a.timestamp - b.timestamp).forEach(file => {
                appendFileMessage(file);
            });
        }

        window.onbeforeunload = () => {
            if (virtualServer.agents[apiKey] && virtualServer.agents[apiKey][username]) {
                virtualServer.agents[apiKey][username].status = 'offline';
                const activeAgents = Object.values(virtualServer.agents[apiKey] || {}).filter(agent => agent.status === 'online');
                if (isCreator && activeAgents.length === 0) {
                    delete virtualServer.rooms[currentRoom];
                    delete virtualServer.messages[currentRoom];
                    delete virtualServer.files[currentRoom];
                    delete virtualServer.signaling[currentRoom];
                    delete virtualServer.agents[apiKey];
                }
                localStorage.setItem('virtualServer', JSON.stringify(virtualServer));
                broadcastVirtualServer();
            }
            localStorage.removeItem('apiKey');
            localStorage.removeItem('username');
            Object.values(peerConnections).forEach(pc => pc.close());
        };

        // Initialize
        checkLogin();
    </script>
</body>
</html>
