<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Post API</title>
    <style>
        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            width: 100%;
            display: none; /* Hidden until bulletin created/joined */
        }
        .setup {
            text-align: center;
        }
        h1 {
            font-size: 2em;
            text-align: center;
            text-shadow: 0 0 10px #0f0;
        }
        input, button {
            background: #111;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            margin: 5px;
            font-family: 'Courier New', monospace;
        }
        button:hover {
            background: #0f0;
            color: #000;
        }
        .post {
            background: #111;
            border: 1px solid #0f0;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        footer {
            position: fixed;
            bottom: 10px;
            text-align: center;
            width: 100%;
            font-size: 0.8em;
        }
    </style>
</head>
<body>
    <div class="setup">
        <h1>Post API</h1>
        <div>
            <input type="text" id="boardId" placeholder="Bulletin ID">
            <input type="password" id="boardPass" placeholder="Password (optional)">
            <button onclick="createBulletin()">Create Bulletin</button>
            <button onclick="joinBulletin()">Join Bulletin</button>
        </div>
    </div>
    <div class="container" id="appContainer">
        <h1 id="boardTitle"></h1>
        <div>
            <input type="text" id="postContent" placeholder="Enter post content">
            <input type="file" id="postFile">
            <button onclick="addPost()">Post</button>
        </div>
        <div id="posts"></div>
        <div>API Endpoint: <span id="apiEndpoint"></span></div>
        <div>Share Token: <span id="shareToken"></span></div>
    </div>
    <footer>&copy; 2025 Webxos</footer>

    <script>
        // Virtual Worker Emulation (Service Worker replacement)
        const virtualWorker = (() => {
            const channel = new MessageChannel();
            const port = channel.port1;
            const clients = new Set();
            const apiRoutes = new Map();

            // Simulate Service Worker fetch handling
            function handleFetch(event) {
                const url = new URL(event.url);
                const path = url.pathname;
                if (path.startsWith('/api/public-bulletins')) {
                    return getPublicBulletins();
                } else if (path.startsWith('/api/')) {
                    const [, , boardId, token] = path.split('/');
                    return handleApiRequest(boardId, token);
                }
                return { status: 404, data: { error: 'Not found' } };
            }

            // Message handler for client communication
            port.onmessage = (event) => {
                if (event.data.type === 'fetch') {
                    const response = handleFetch(event.data);
                    event.ports[0].postMessage(response);
                } else if (event.data.type === 'registerClient') {
                    clients.add(event.ports[0]);
                } else if (event.data.type === 'update') {
                    broadcastUpdate(event.data.data);
                }
            };

            // Broadcast updates to all clients
            function broadcastUpdate(data) {
                clients.forEach(client => client.postMessage({ type: 'update', data }));
            }

            return {
                postMessage: (msg, transfer) => channel.port2.postMessage(msg, transfer),
                addEventListener: (type, handler) => {
                    if (type === 'message') port.onmessage = handler;
                },
                registerRoute: (path, handler) => apiRoutes.set(path, handler),
                broadcast: broadcastUpdate
            };
        })();

        // IndexedDB Setup
        let db;
        const dbRequest = indexedDB.open('post-api', 1);
        dbRequest.onupgradeneeded = (event) => {
            db = event.target.result;
            db.createObjectStore('bulletins', { keyPath: 'id' });
            db.createObjectStore('posts', { keyPath: 'id', autoIncrement: true });
            db.createObjectStore('tokens', { keyPath: 'boardId' });
        };
        dbRequest.onsuccess = (event) => {
            db = event.target.result;
            initializeApp();
        };

        // WebRTC Setup
        let peerConnection;
        let dataChannel;
        const signalingChannel = new BroadcastChannel('post-api-signaling');

        function setupWebRTC(boardId, isCreator) {
            peerConnection = new RTCPeerConnection();
            if (isCreator) {
                dataChannel = peerConnection.createDataChannel('posts');
                dataChannel.onopen = () => console.log('Data channel open');
                dataChannel.onmessage = (event) => handlePeerMessage(event.data);
                peerConnection.createOffer().then(offer => {
                    peerConnection.setLocalDescription(offer);
                    signalingChannel.postMessage({ type: 'offer', boardId, offer });
                });
            }
            signalingChannel.onmessage = (event) => {
                if (event.data.type === 'offer' && event.data.boardId === boardId && !isCreator) {
                    peerConnection.setRemoteDescription(event.data.offer);
                    peerConnection.createAnswer().then(answer => {
                        peerConnection.setLocalDescription(answer);
                        signalingChannel.postMessage({ type: 'answer', boardId, answer });
                    });
                } else if (event.data.type === 'answer' && event.data.boardId === boardId && isCreator) {
                    peerConnection.setRemoteDescription(event.data.answer);
                } else if (event.data.type === 'candidate' && event.data.boardId === boardId) {
                    peerConnection.addIceCandidate(event.data.candidate);
                }
            };
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    signalingChannel.postMessage({ type: 'candidate', boardId, candidate: event.candidate });
                }
            };
            peerConnection.ondatachannel = (event) => {
                if (!isCreator) {
                    dataChannel = event.channel;
                    dataChannel.onopen = () => console.log('Data channel open');
                    dataChannel.onmessage = (event) => handlePeerMessage(event.data);
                }
            };
        }

        function handlePeerMessage(data) {
            const parsed = JSON.parse(data);
            if (parsed.type === 'post') {
                addPostToDB(parsed.data);
                virtualWorker.broadcast({ type: 'post', data: parsed.data });
                renderPosts();
            }
        }

        // API Handling
        function handleApiRequest(boardId, token) {
            return new Promise((resolve) => {
                const tx = db.transaction(['tokens', 'posts'], 'readonly');
                const tokenStore = tx.objectStore('tokens');
                const postStore = tx.objectStore('posts');
                const tokenReq = tokenStore.get(boardId);
                tokenReq.onsuccess = () => {
                    if (tokenReq.result?.token === token) {
                        const postsReq = postStore.getAll();
                        postsReq.onsuccess = () => {
                            resolve({ status: 200, data: postsReq.result });
                        };
                    } else {
                        resolve({ status: 403, data: { error: 'Invalid token' } });
                    }
                };
            });
        }

        function getPublicBulletins() {
            return new Promise((resolve) => {
                const tx = db.transaction(['bulletins'], 'readonly');
                const store = tx.objectStore('bulletins');
                const req = store.getAll();
                req.onsuccess = () => {
                    const bulletins = req.result.filter(b => !b.password);
                    resolve({ status: 200, data: bulletins });
                };
            });
        }

        // App Logic
        let currentBoardId = null;
        let isCreator = false;

        function initializeApp() {
            // Virtual worker client registration
            const clientPort = new MessageChannel().port1;
            virtualWorker.postMessage({ type: 'registerClient' }, [clientPort]);
            clientPort.onmessage = (event) => {
                if (event.data.type === 'update') {
                    renderPosts();
                }
            };
        }

        function createBulletin() {
            const boardId = document.getElementById('boardId').value || Math.random().toString(36).slice(2, 10);
            const password = document.getElementById('boardPass').value;
            const token = Math.random().toString(36).slice(2);
            const tx = db.transaction(['bulletins', 'tokens'], 'readwrite');
            tx.objectStore('bulletins').put({ id: boardId, password });
            tx.objectStore('tokens').put({ boardId, token });
            tx.oncomplete = () => {
                currentBoardId = boardId;
                isCreator = true;
                setupWebRTC(boardId, true);
                showBoard(boardId, token);
            };
        }

        function joinBulletin() {
            const boardId = document.getElementById('boardId').value;
            const password = document.getElementById('boardPass').value;
            const tx = db.transaction(['bulletins'], 'readonly');
            const store = tx.objectStore('bulletins');
            const req = store.get(boardId);
            req.onsuccess = () => {
                if (req.result && (!req.result.password || req.result.password === password)) {
                    currentBoardId = boardId;
                    isCreator = false;
                    setupWebRTC(boardId, false);
                    showBoard(boardId, null);
                } else {
                    alert('Invalid board ID or password');
                }
            };
        }

        function showBoard(boardId, token) {
            document.querySelector('.setup').style.display = 'none';
            document.getElementById('appContainer').style.display = 'block';
            document.getElementById('boardTitle').textContent = `Bulletin: ${boardId}`;
            document.getElementById('apiEndpoint').textContent = `/api/${boardId}/${token || 'your-token'}`;
            document.getElementById('shareToken').textContent = token || 'Not creator';
            renderPosts();
        }

        function addPost() {
            const content = document.getElementById('postContent').value;
            const fileInput = document.getElementById('postFile');
            const post = { boardId: currentBoardId, content, timestamp: Date.now() };
            if (fileInput.files.length > 0) {
                const reader = new FileReader();
                reader.onload = () => {
                    post.file = reader.result;
                    addPostToDB(post);
                    if (dataChannel?.readyState === 'open') {
                        dataChannel.send(JSON.stringify({ type: 'post', data: post }));
                    }
                    virtualWorker.broadcast({ type: 'post', data: post });
                    renderPosts();
                };
                reader.readAsDataURL(fileInput.files[0]);
            } else {
                addPostToDB(post);
                if (dataChannel?.readyState === 'open') {
                    dataChannel.send(JSON.stringify({ type: 'post', data: post }));
                }
                virtualWorker.broadcast({ type: 'post', data: post });
                renderPosts();
            }
        }

        function addPostToDB(post) {
            const tx = db.transaction(['posts'], 'readwrite');
            const store = tx.objectStore('posts');
            store.add(post);
        }

        function renderPosts() {
            const tx = db.transaction(['posts'], 'readonly');
            const store = tx.objectStore('posts');
            const req = store.getAll();
            req.onsuccess = () => {
                const posts = req.result.filter(p => p.boardId === currentBoardId);
                const postsDiv = document.getElementById('posts');
                postsDiv.innerHTML = '';
                posts.forEach(post => {
                    const div = document.createElement('div');
                    div.className = 'post';
                    div.innerHTML = `
                        <p>${post.content || 'No text'}</p>
                        ${post.file ? `<img src="${post.file}" style="max-width: 200px;">` : ''}
                        <small>${new Date(post.timestamp).toLocaleString()}</small>
                    `;
                    postsDiv.appendChild(div);
                });
            };
        }

        // Cleanup on page close
        window.onunload = () => {
            if (isCreator && currentBoardId) {
                const tx = db.transaction(['bulletins', 'posts', 'tokens'], 'readwrite');
                tx.objectStore('bulletins').delete(currentBoardId);
                tx.objectStore('tokens').delete(currentBoardId);
                const postStore = tx.objectStore('posts');
                postStore.getAll().onsuccess = (event) => {
                    event.target.result.forEach(post => {
                        if (post.boardId === currentBoardId) {
                            postStore.delete(post.id);
                        }
                    });
                };
            }
            peerConnection?.close();
            dataChannel?.close();
            signalingChannel.close();
        };
    </script>
</body>
</html>
