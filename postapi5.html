<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="description" content="Post API: Lightweight, browser-based API bulletin generator for real-time data sharing with global public bulletins and in-memory virtual server.">
    <title>Post API</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-size: 3vw;
        }
        h1 {
            font-size: 5vw;
            text-align: center;
            text-shadow: 0 0 3px #0f0;
            margin: 2px 0;
        }
        #start-menu, #container, #setup-guide {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-height: 100vh;
            overflow: hidden;
            width: 100%;
            padding: 5px;
        }
        #container, #setup-guide { display: none; }
        #start-menu button, #modal-content button, #board button, #profile button {
            background: #111;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px;
            font-size: 3.5vw;
            cursor: pointer;
            border-radius: 3px;
            width: 90%;
            max-width: 200px;
            margin: 2px 0;
            transition: background 0.3s, color 0.3s;
        }
        #start-menu button:hover, #modal-content button:hover, #board button:hover, #profile button:hover {
            background: #0f0;
            color: #000;
        }
        #public-boards-list {
            width: 90%;
            max-width: 200px;
            margin: 5px 0;
            text-align: center;
        }
        #public-boards-list h3 {
            font-size: 3.5vw;
            margin: 2px 0;
        }
        #public-boards-list ul {
            list-style: none;
            max-height: 15vh;
            overflow-y: auto;
            padding: 0;
            margin: 0;
        }
        #public-boards-list li {
            background: #111;
            border: 1px solid #0f0;
            padding: 3px;
            margin: 2px 0;
            border-radius: 3px;
            font-size: 3vw;
            cursor: pointer;
        }
        #public-boards-list li:hover {
            background: #0f0;
            color: #000;
        }
        #modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #modal-content {
            background: #111;
            padding: 10px;
            border: 1px solid #0f0;
            border-radius: 3px;
            width: 90%;
            max-width: 300px;
            text-align: center;
        }
        #modal-content input, #modal-content select {
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px;
            margin: 2px 0;
            font-family: 'Courier New', monospace;
            width: 100%;
            font-size: 3.5vw;
            border-radius: 3px;
        }
        #modal-content input[type="checkbox"] {
            width: auto;
            margin: 5px 3px;
        }
        #board, #profile {
            width: 100%;
            border: 1px solid #0f0;
            padding: 5px;
            border-radius: 3px;
            margin: 2px 0;
        }
        #profile {
            font-size: 2.5vw;
            padding: 3px;
        }
        #board-posts {
            height: 50vh;
            overflow-y: auto;
            border: 1px solid #0f0;
            padding: 5px;
            margin-bottom: 5px;
            background: #111;
            flex-grow: 1;
        }
        .post {
            margin: 3px 0;
            word-wrap: break-word;
            font-size: 3vw;
        }
        .post img {
            max-width: 60%;
            border-radius: 3px;
            margin: 3px 0;
        }
        .post a {
            color: #0f0;
            text-decoration: underline;
        }
        #board input {
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px;
            margin: 2px 0;
            font-family: 'Courier New', monospace;
            width: 100%;
            font-size: 3.5vw;
            border-radius: 3px;
        }
        #file-input { padding: 3px; }
        #webrtc-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #webrtc-modal div {
            background: #111;
            padding: 10px;
            border: 1px solid #0f0;
            border-radius: 3px;
            width: 90%;
            max-width: 300px;
            text-align: center;
        }
        #webrtc-answer-input {
            width: 100%;
            height: 100px;
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            font-family: 'Courier New', monospace;
        }
        #error-message {
            color: #f00;
            font-size: 3vw;
            margin: 5px 0;
            display: none;
        }
        #setup-guide p {
            font-size: 3vw;
            margin: 5px 0;
            text-align: center;
        }
        @media (min-width: 768px) {
            body { font-size: 16px; }
            h1 { font-size: 24px; }
            #start-menu button, #modal-content button, #board button, #profile button { font-size: 14px; max-width: 250px; padding: 8px; }
            #modal-content input, #modal-content select, #board input { font-size: 14px; }
            #public-boards-list h3 { font-size: 16px; }
            #public-boards-list li { font-size: 12px; }
            #profile { font-size: 12px; }
            .post { font-size: 12px; }
            #board-posts { max-height: 70%; }
            #error-message, #setup-guide p { font-size: 14px; }
        }
    </style>
</head>
<body>
    <div id="setup-guide">
        <h1>Post API Setup</h1>
        <p>This app requires HTTPS or localhost to function.</p>
        <p><strong>Steps to fix:</strong></p>
        <p>1. Serve the page via HTTPS (e.g., use a hosting service like Netlify or GitHub Pages).</p>
        <p>2. Or, serve locally with: <code>python -m http.server 8000</code> and visit <code>http://localhost:8000</code>.</p>
        <p>3. Ensure your browser supports Service Workers (Chrome, Firefox, Edge).</p>
        <p>4. Reload the page after fixing the setup.</p>
    </div>
    <div id="start-menu">
        <h1>Post API</h1>
        <button id="create-board-btn">Create API Bulletin</button>
        <button id="join-board-btn">Join API Bulletin</button>
        <div id="public-boards-list">
            <h3>Public API Bulletins</h3>
            <ul id="public-boards-items"></ul>
            <button id="refresh-boards-btn">Refresh</button>
        </div>
    </div>
    <div id="modal">
        <div id="modal-content">
            <h2 id="modal-title">Create API Bulletin</h2>
            <div id="error-message"></div>
            <input type="text" id="creator-input" placeholder="Creator Name">
            <input type="password" id="password-input" placeholder="Bulletin Password (optional for private)">
            <input type="text" id="board-id-input" placeholder="Bulletin ID" readonly style="display: none;">
            <label><input type="checkbox" id="public-board" checked> Public Bulletin</label>
            <select id="public-boards" style="display: none;">
                <option value="">Select Public API Bulletin</option>
            </select>
            <button id="modal-action">Create Bulletin</button>
        </div>
    </div>
    <div id="container">
        <h1>Post API</h1>
        <div id="profile">
            <div>Session ID: <span id="session-id"></span></div>
            <div>Bulletin: <span id="board-id"></span> <button onclick="copyBoardId()">Copy</button></div>
            <div>API Endpoint: <span id="api-key"></span> <button onclick="copyApiKey()">Copy</button></div>
            <div>WebRTC Offer: <span id="webrtc-offer"></span> <button onclick="copyWebRTCOffer()">Copy</button></div>
            <button onclick="showWebRTCAnswerModal()">Enter WebRTC Answer</button>
            <button onclick="leaveBoard()">Leave Bulletin</button>
        </div>
        <div id="board">
            <div id="board-posts"></div>
            <input type="text" id="post-input" placeholder="Post message to API...">
            <input type="file" id="file-input" accept="image/*,*">
            <button onclick="submitPost()">Post</button>
        </div>
    </div>
    <div id="webrtc-modal">
        <div>
            <h2>Enter WebRTC Answer</h2>
            <textarea id="webrtc-answer-input"></textarea>
            <button onclick="submitWebRTCAnswer()">Submit</button>
        </div>
    </div>
    <script>
        let boardId = localStorage.getItem('boardId');
        let sessionId = localStorage.getItem('sessionId');
        let currentBoard = '';
        let isCreator = false;
        let peerConnections = new Map();
        let dataChannel = null;
        let currentApiToken = '';

        // Service Worker script (base64-encoded)
        const swCode = btoa(`
            const virtualServer = {
                bulletins: [],
                posts: [],
                files: [],
                tokens: [],
                webrtcOffers: []
            };

            self.addEventListener('fetch', event => {
                const url = new URL(event.request.url);
                if (url.pathname === '/api/public-bulletins') {
                    const publicBulletins = virtualServer.bulletins
                        .filter(b => b.public)
                        .map(b => ({ id: b.id, creator: b.creator, createdAt: b.createdAt }));
                    event.respondWith(new Response(JSON.stringify(publicBulletins), {
                        headers: { 'Content-Type': 'application/json' }
                    }));
                } else {
                    const match = url.pathname.match(/^\\/api\\/([^\\/]+)\\/([^\\/]+)/);
                    if (match) {
                        const [, boardId, token] = match;
                        const tokenData = virtualServer.tokens.find(t => t.boardId === boardId);
                        if (!tokenData || tokenData.token !== token) {
                            return event.respondWith(new Response(JSON.stringify({ error: 'Invalid token' }), { status: 403 }));
                        }
                        const posts = virtualServer.posts.filter(p => p.boardId === boardId);
                        const files = virtualServer.files.filter(f => f.boardId === boardId);
                        event.respondWith(new Response(JSON.stringify({ posts, files }), {
                            headers: { 'Content-Type': 'application/json' }
                        }));
                    }
                }
            });

            self.addEventListener('message', event => {
                const data = event.data;
                if (data.type === 'save') {
                    if (data.data.type === 'bulletin') {
                        virtualServer.bulletins.push(data.data);
                    } else if (data.data.type === 'post') {
                        virtualServer.posts.push(data.data);
                    } else if (data.data.type === 'file') {
                        virtualServer.files.push(data.data);
                    } else if (data.data.type === 'token') {
                        virtualServer.tokens.push(data.data);
                    } else if (data.data.type === 'webrtc-offer') {
                        virtualServer.webrtcOffers.push(data.data);
                    }
                    event.source.postMessage({ type: 'save-complete', boardId: data.data.boardId });
                    clients.matchAll().then(clients => {
                        clients.forEach(client => client.postMessage({ type: 'data-updated', boardId: data.data.boardId }));
                    });
                } else if (data.type === 'cleanup' && data.boardId) {
                    virtualServer.bulletins = virtualServer.bulletins.filter(b => b.id !== data.boardId);
                    virtualServer.posts = virtualServer.posts.filter(p => p.boardId !== data.boardId);
                    virtualServer.files = virtualServer.files.filter(f => f.boardId !== data.boardId);
                    virtualServer.tokens = virtualServer.tokens.filter(t => t.boardId !== data.boardId);
                    virtualServer.webrtcOffers = virtualServer.webrtcOffers.filter(o => o.boardId !== data.boardId);
                } else if (data.type === 'get-bulletins') {
                    event.source.postMessage({ type: 'bulletins', data: virtualServer.bulletins });
                } else if (data.type === 'get-data' && data.boardId) {
                    const posts = virtualServer.posts.filter(p => p.boardId === data.boardId);
                    const files = virtualServer.files.filter(f => f.boardId === data.boardId);
                    event.source.postMessage({ type: 'data', data: { posts, files } });
                } else if (data.type === 'get-tokens') {
                    event.source.postMessage({ type: 'tokens', data: virtualServer.tokens });
                } else if (data.type === 'get-webrtc-offer' && data.boardId) {
                    const offer = virtualServer.webrtcOffers.find(o => o.boardId === data.boardId);
                    event.source.postMessage({ type: 'webrtc-offer', data: offer });
                } else if (data.type === 'check-status') {
                    event.source.postMessage({ type: 'status', active: true });
                }
            });

            self.addEventListener('install', event => {
                event.waitUntil(self.skipWaiting());
            });

            self.addEventListener('activate', event => {
                event.waitUntil(clients.claim());
            });
        `);

        // Register Service Worker
        async function registerServiceWorker(retries = 5, delay = 1000) {
            console.log('Attempting to register Service Worker...');
            if (!navigator.serviceWorker) {
                throw new Error('Service Workers not supported in this browser');
            }
            for (let i = 0; i < retries; i++) {
                try {
                    const blob = new Blob([atob(swCode)], { type: 'application/javascript' });
                    const url = URL.createObjectURL(blob);
                    const registration = await navigator.serviceWorker.register(url, { scope: '/' });
                    console.log('Service Worker registered successfully');
                    URL.revokeObjectURL(url);
                    return registration;
                } catch (error) {
                    console.error(`Service Worker registration attempt ${i + 1} failed:`, error);
                    if (i < retries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                    }
                }
            }
            throw new Error(`Service Worker registration failed after ${retries} retries`);
        }

        async function initServiceWorker() {
            try {
                if (!window.location.protocol.includes('https') && !window.location.hostname.includes('localhost')) {
                    throw new Error('Service Workers require HTTPS or localhost');
                }
                const registration = await registerServiceWorker();
                navigator.serviceWorker.addEventListener('message', event => {
                    if (event.data.type === 'data-updated' && event.data.boardId === currentBoard) {
                        loadPosts();
                    }
                });
                console.log('Service Worker initialized');
                return registration;
            } catch (error) {
                console.error('Service Worker initialization failed:', error);
                document.getElementById('start-menu').style.display = 'none';
                document.getElementById('setup-guide').style.display = 'flex';
                throw error;
            }
        }

        // Generate UUID
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0;
                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }

        // Generate API token
        function generateApiToken() {
            return 'api_' + Math.random().toString(36).substr(2, 16);
        }

        // Initialize WebRTC
        async function initWebRTC(boardId, isPublic) {
            console.log('Initializing WebRTC for board:', boardId);
            try {
                const peer = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
                dataChannel = peer.createDataChannel('post-api');
                dataChannel.onopen = () => console.log('Data channel opened');
                dataChannel.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'post' || data.type === 'file') {
                            navigator.serviceWorker.controller?.postMessage({ type: 'save', data });
                            loadPosts();
                        }
                    } catch (error) {
                        console.error('WebRTC message error:', error);
                    }
                };
                dataChannel.onerror = (error) => console.error('Data channel error:', error);
                peerConnections.set(boardId, peer);

                peer.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('ICE candidate:', JSON.stringify(event.candidate));
                    }
                };

                const offer = await peer.createOffer();
                await peer.setLocalDescription(offer);
                const offerStr = JSON.stringify(offer);
                document.getElementById('webrtc-offer').textContent = offerStr.slice(0, 20) + '...';
                if (isPublic) {
                    navigator.serviceWorker.controller?.postMessage({
                        type: 'save',
                        data: { type: 'webrtc-offer', boardId, offer: offerStr }
                    });
                    loadPublicBoardsList();
                }
                console.log('WebRTC initialized successfully');
                return peer;
            } catch (error) {
                console.error('WebRTC initialization failed:', error);
                throw new Error('Failed to initialize WebRTC');
            }
        }

        // Handle WebRTC answer
        async function submitWebRTCAnswer() {
            try {
                const answerStr = document.getElementById('webrtc-answer-input').value.trim();
                if (!answerStr) {
                    alert('Please enter a WebRTC answer.');
                    return;
                }
                const answer = JSON.parse(answerStr);
                const peer = peerConnections.get(currentBoard);
                if (peer) {
                    await peer.setRemoteDescription(new RTCSessionDescription(answer));
                    document.getElementById('webrtc-modal').style.display = 'none';
                } else {
                    alert('No active WebRTC connection.');
                }
            } catch (error) {
                console.error('WebRTC answer error:', error);
                alert('Invalid WebRTC answer.');
            }
        }

        // Create bulletin
        async function handleCreateBoard() {
            console.log('handleCreateBoard called');
            const errorDiv = document.getElementById('error-message');
            errorDiv.style.display = 'none';
            errorDiv.textContent = '';

            try {
                if (!navigator.serviceWorker.controller) {
                    throw new Error('Service Worker not initialized. Ensure HTTPS/localhost.');
                }
                const creator = document.getElementById('creator-input').value.trim();
                const password = document.getElementById('password-input').value.trim();
                const isPublic = document.getElementById('public-board').checked;
                const newBoardId = generateUUID();

                if (!creator) {
                    throw new Error('Please enter a creator name.');
                }

                console.log('Creating bulletin with ID:', newBoardId);
                sessionId = `Session_${Math.random().toString(36).substr(2, 8)}`;
                boardId = newBoardId;
                localStorage.setItem('boardId', boardId);
                localStorage.setItem('sessionId', sessionId);
                currentBoard = boardId;
                isCreator = true;

                const token = generateApiToken();
                const bulletinData = {
                    type: 'bulletin',
                    id: boardId,
                    creator,
                    creatorSessionId: sessionId,
                    public: isPublic,
                    password: isPublic ? '' : password,
                    createdAt: Date.now()
                };
                const tokenData = { type: 'token', boardId, token };
                navigator.serviceWorker.controller.postMessage({ type: 'save', data: bulletinData });
                navigator.serviceWorker.controller.postMessage({ type: 'save', data: tokenData });
                currentApiToken = token;

                await initWebRTC(boardId, isPublic);
                initializeApp(isPublic, password);
                document.getElementById('modal').style.display = 'none';
                alert(`Bulletin created! API Endpoint: /api/${boardId}/${token}`);
                console.log('Bulletin created successfully');
            } catch (error) {
                console.error('Create bulletin error:', error);
                errorDiv.textContent = error.message || 'Failed to create bulletin. Please try again.';
                errorDiv.style.display = 'block';
            }
        }

        // Join bulletin
        async function handleJoinBoard() {
            console.log('handleJoinBoard called');
            const errorDiv = document.getElementById('error-message');
            errorDiv.style.display = 'none';
            errorDiv.textContent = '';

            try {
                if (!navigator.serviceWorker.controller) {
                    throw new Error('Service Worker not initialized. Ensure HTTPS/localhost.');
                }
                const password = document.getElementById('password-input').value.trim();
                const creator = document.getElementById('creator-input').value.trim();
                const selectedBoardId = document.getElementById('public-boards').value || document.getElementById('board-id-input').value.trim();

                if (!selectedBoardId) {
                    throw new Error('Please select or enter a bulletin ID.');
                }

                const bulletin = await new Promise(resolve => {
                    navigator.serviceWorker.controller.postMessage({ type: 'get-bulletins' });
                    navigator.serviceWorker.addEventListener('message', function handler(event) {
                        if (event.data.type === 'bulletins') {
                            resolve(event.data.data.find(b => b.id === selectedBoardId));
                            navigator.serviceWorker.removeEventListener('message', handler);
                        }
                    });
                });

                if (!bulletin) {
                    throw new Error('Bulletin does not exist.');
                }

                if (!bulletin.public && (bulletin.password !== password || bulletin.creator !== creator)) {
                    throw new Error('Invalid password or creator name.');
                }

                sessionId = `Session_${Math.random().toString(36).substr(2, 8)}`;
                boardId = selectedBoardId;
                localStorage.setItem('boardId', boardId);
                localStorage.setItem('sessionId', sessionId);
                currentBoard = boardId;
                isCreator = false;

                const tokenData = await new Promise(resolve => {
                    navigator.serviceWorker.controller.postMessage({ type: 'get-tokens' });
                    navigator.serviceWorker.addEventListener('message', function handler(event) {
                        if (event.data.type === 'tokens') {
                            resolve(event.data.data.find(t => t.boardId === boardId));
                            navigator.serviceWorker.removeEventListener('message', handler);
                        }
                    });
                });
                currentApiToken = tokenData?.token || '';

                await initWebRTC(boardId, bulletin.public);
                initializeApp(bulletin.public, password);
                document.getElementById('modal').style.display = 'none';
                console.log('Joined bulletin successfully');
            } catch (error) {
                console.error('Join bulletin error:', error);
                errorDiv.textContent = error.message || 'Failed to join bulletin. Please try again.';
                errorDiv.style.display = 'block';
            }
        }

        // Initialize app
        function initializeApp(isPublic, password) {
            console.log('Initializing app UI');
            document.getElementById('start-menu').style.display = 'none';
            document.getElementById('modal').style.display = 'none';
            document.getElementById('container').style.display = 'flex';
            document.getElementById('session-id').textContent = sessionId;
            document.getElementById('board-id').textContent = boardId.slice(0, 8);
            document.getElementById('api-key').textContent = `/api/${boardId}/${currentApiToken}`;
            loadPosts();
        }

        // Leave bulletin
        async function leaveBoard() {
            console.log('Leaving board:', boardId);
            try {
                if (isCreator) {
                    navigator.serviceWorker.controller?.postMessage({ type: 'cleanup', boardId });
                    peerConnections.get(boardId)?.close();
                    peerConnections.delete(boardId);
                }
                localStorage.removeItem('boardId');
                localStorage.removeItem('sessionId');
                currentBoard = '';
                sessionId = '';
                boardId = '';
                isCreator = false;
                currentApiToken = '';
                document.getElementById('container').style.display = 'none';
                document.getElementById('start-menu').style.display = 'flex';
                loadPublicBoardsList();
                console.log('Left board successfully');
            } catch (error) {
                console.error('Leave bulletin error:', error);
                alert('Failed to leave bulletin.');
            }
        }

        // Copy functions
        function copyBoardId() {
            navigator.clipboard.writeText(boardId).then(() => alert('Bulletin ID copied!')).catch(() => alert('Copy failed.'));
        }

        function copyApiKey() {
            const apiKey = `/api/${boardId}/${currentApiToken}`;
            navigator.clipboard.writeText(apiKey).then(() => alert('API Endpoint copied!')).catch(() => alert('Copy failed.'));
        }

        function copyWebRTCOffer() {
            const peer = peerConnections.get(currentBoard);
            if (peer && peer.localDescription) {
                navigator.clipboard.writeText(JSON.stringify(peer.localDescription)).then(() => alert('WebRTC Offer copied!')).catch(() => alert('Copy failed.'));
            } else {
                alert('No WebRTC offer available.');
            }
        }

        // WebRTC answer modal
        function showWebRTCAnswerModal() {
            console.log('Showing WebRTC answer modal');
            document.getElementById('webrtc-modal').style.display = 'flex';
        }

        // Submit post
        async function submitPost() {
            console.log('Submitting post');
            try {
                const input = document.getElementById('post-input');
                const fileInput = document.getElementById('file-input');
                if (!currentBoard) {
                    alert('Join or create a bulletin.');
                    return;
                }
                if (fileInput.files.length > 0) {
                    const file = fileInput.files[0];
                    const reader = new FileReader();
                    reader.onload = () => {
                        const fileData = {
                            type: 'file',
                            id: generateUUID(),
                            sessionId,
                            boardId: currentBoard,
                            fileName: file.name,
                            fileData: reader.result,
                            timestamp: Date.now()
                        };
                        navigator.serviceWorker.controller?.postMessage({ type: 'save', data: fileData });
                        appendFilePost(fileData);
                        if (dataChannel) dataChannel.send(JSON.stringify(fileData));
                        fileInput.value = '';
                    };
                    reader.readAsDataURL(file);
                } else {
                    const message = input.value.trim();
                    if (message) {
                        const postData = {
                            type: 'post',
                            id: generateUUID(),
                            sessionId,
                            content: message,
                            boardId: currentBoard,
                            timestamp: Date.now()
                        };
                        navigator.serviceWorker.controller?.postMessage({ type: 'save', data: postData });
                        appendPost(`${sessionId}: ${message}`);
                        if (dataChannel) dataChannel.send(JSON.stringify(postData));
                        input.value = '';
                    } else {
                        alert('Enter a message or file.');
                    }
                }
            } catch (error) {
                console.error('Submit post error:', error);
                alert('Failed to submit post.');
            }
        }

        // Append text post
        function appendPost(text) {
            const posts = document.getElementById('board-posts');
            const postDiv = document.createElement('div');
            postDiv.className = 'post';
            postDiv.textContent = text;
            posts.appendChild(postDiv);
            posts.scrollTop = posts.scrollHeight;
        }

        // Append file post
        function appendFilePost(file) {
            const posts = document.getElementById('board-posts');
            const postDiv = document.createElement('div');
            postDiv.className = 'post';
            if (file.fileData.startsWith('data:image/')) {
                const img = document.createElement('img');
                img.src = file.fileData;
                postDiv.textContent = `${file.sessionId} shared image:`;
                postDiv.appendChild(img);
            } else {
                const link = document.createElement('a');
                link.href = file.fileData;
                link.download = file.fileName;
                link.textContent = file.fileName;
                postDiv.textContent = `${file.sessionId} shared file: `;
                postDiv.appendChild(link);
            }
            posts.appendChild(postDiv);
            posts.scrollTop = posts.scrollHeight;
        }

        // Load posts
        async function loadPosts() {
            console.log('Loading posts for board:', currentBoard);
            try {
                const data = await new Promise(resolve => {
                    navigator.serviceWorker.controller?.postMessage({ type: 'get-data', boardId: currentBoard });
                    navigator.serviceWorker.addEventListener('message', function handler(event) {
                        if (event.data.type === 'data') {
                            resolve(event.data.data);
                            navigator.serviceWorker.removeEventListener('message', handler);
                        }
                    });
                });
                const postsDiv = document.getElementById('board-posts');
                postsDiv.innerHTML = '';
                (data.posts || []).sort((a, b) => a.timestamp - b.timestamp).forEach(post => {
                    appendPost(`${post.sessionId}: ${post.content}`);
                });
                (data.files || []).sort((a, b) => a.timestamp - b.timestamp).forEach(file => {
                    appendFilePost(file);
                });
            } catch (error) {
                console.error('Load posts error:', error);
            }
        }

        // Load public boards
        async function loadPublicBoardsList() {
            console.log('Loading public boards list');
            try {
                const publicBulletins = await fetch('/api/public-bulletins').then(res => res.json());
                const list = document.getElementById('public-boards-items');
                list.innerHTML = '';
                if (publicBulletins.length === 0) {
                    list.innerHTML = '<li>No public API bulletins</li>';
                } else {
                    publicBulletins.forEach(bulletin => {
                        const li = document.createElement('li');
                        li.textContent = `Bulletin by ${bulletin.creator} (${bulletin.id.slice(0, 8)})`;
                        li.onclick = () => {
                            document.getElementById('public-boards').value = bulletin.id;
                            document.getElementById('board-id-input').value = bulletin.id;
                            showJoinBoardModal();
                        };
                        list.appendChild(li);
                    });
                }
            } catch (error) {
                console.error('Load public boards error:', error);
            }
        }

        async function loadPublicBoards() {
            console.log('Loading public boards for dropdown');
            try {
                const publicBulletins = await fetch('/api/public-bulletins').then(res => res.json());
                const select = document.getElementById('public-boards');
                select.innerHTML = '<option value="">Select Public API Bulletin</option>';
                publicBulletins.forEach(bulletin => {
                    const option = document.createElement('option');
                    option.value = bulletin.id;
                    option.textContent = `Bulletin by ${bulletin.creator} (${bulletin.id.slice(0, 8)})`;
                    select.appendChild(option);
                });
                select.onchange = () => {
                    const selectedBoard = select.value;
                    document.getElementById('creator-input').style.display = selectedBoard ? 'none' : 'block';
                    document.getElementById('board-id-input').style.display = selectedBoard ? 'none' : 'block';
                    if (selectedBoard) {
                        document.getElementById('board-id-input').value = selectedBoard;
                    }
                };
            } catch (error) {
                console.error('Load public boards error:', error);
            }
        }

        function refreshPublicBoards() {
            console.log('Refreshing public boards');
            loadPublicBoardsList();
            loadPublicBoards();
        }

        // Modal handlers
        function showCreateBoardModal() {
            console.log('showCreateBoardModal called');
            const errorDiv = document.getElementById('error-message');
            errorDiv.style.display = 'none';
            errorDiv.textContent = '';
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalAction = document.getElementById('modal-action');
            if (!modal || !modalTitle || !modalAction) {
                console.error('Modal elements not found');
                alert('UI error: Modal elements missing. Please reload the page.');
                return;
            }
            modalTitle.textContent = 'Create API Bulletin';
            modalAction.textContent = 'Create';
            document.getElementById('board-id-input').value = generateUUID();
            document.getElementById('creator-input').value = '';
            document.getElementById('password-input').value = '';
            document.getElementById('public-board').checked = true;
            document.getElementById('public-boards').style.display = 'none';
            modal.style.display = 'flex';
            modalAction.onclick = handleCreateBoard;
            console.log('Create modal displayed');
        }

        function showJoinBoardModal() {
            console.log('showJoinBoardModal called');
            const errorDiv = document.getElementById('error-message');
            errorDiv.style.display = 'none';
            errorDiv.textContent = '';
            document.getElementById('modal-title').textContent = 'Join API Bulletin';
            document.getElementById('modal-action').textContent = 'Join';
            document.getElementById('board-id-input').value = '';
            document.getElementById('creator-input').value = '';
            document.getElementById('password-input').value = '';
            document.getElementById('public-boards').style.display = 'block';
            document.getElementById('board-id-input').style.display = 'block';
            document.getElementById('creator-input').style.display = 'block';
            document.getElementById('modal').style.display = 'flex';
            document.getElementById('modal-action').onclick = handleJoinBoard;
            loadPublicBoards();
            console.log('Join modal displayed');
        }

        // Clean up on exit
        window.onbeforeunload = () => {
            if (isCreator) {
                navigator.serviceWorker.controller?.postMessage({ type: 'cleanup', boardId });
                peerConnections.get(boardId)?.close();
                peerConnections.delete(boardId);
            }
            localStorage.removeItem('boardId');
            localStorage.removeItem('sessionId');
        };

        // Check login state
        async function checkLogin() {
            console.log('Checking login state');
            try {
                if (boardId && sessionId) {
                    const bulletin = await new Promise(resolve => {
                        navigator.serviceWorker.controller?.postMessage({ type: 'get-bulletins' });
                        navigator.serviceWorker.addEventListener('message', function handler(event) {
                            if (event.data.type === 'bulletins') {
                                resolve(event.data.data.find(b => b.id === boardId));
                                navigator.serviceWorker.removeEventListener('message', handler);
                            }
                        });
                    });
                    if (bulletin) {
                        currentBoard = boardId;
                        isCreator = bulletin.creatorSessionId === sessionId;
                        const tokenData = await new Promise(resolve => {
                            navigator.serviceWorker.controller?.postMessage({ type: 'get-tokens' });
                            navigator.serviceWorker.addEventListener('message', function handler(event) {
                                if (event.data.type === 'tokens') {
                                    resolve(event.data.data.find(t => t.boardId === boardId));
                                    navigator.serviceWorker.removeEventListener('message', handler);
                                }
                            });
                        });
                        currentApiToken = tokenData?.token || '';
                        await initWebRTC(boardId, bulletin.public);
                        initializeApp(bulletin.public, bulletin.password);
                    } else {
                        document.getElementById('start-menu').style.display = 'flex';
                        loadPublicBoardsList();
                    }
                } else {
                    document.getElementById('start-menu').style.display = 'flex';
                    loadPublicBoardsList();
                }
            } catch (error) {
                console.error('Check login error:', error);
                document.getElementById('start-menu').style.display = 'flex';
                loadPublicBoardsList();
            }
        }

        // Initialize
        async function initialize() {
            console.log('Starting app initialization');
            try {
                await initServiceWorker();
                await checkLogin();

                // Bind button events
                const createBoardBtn = document.getElementById('create-board-btn');
                const joinBoardBtn = document.getElementById('join-board-btn');
                const refreshBoardsBtn = document.getElementById('refresh-boards-btn');

                if (createBoardBtn) {
                    createBoardBtn.onclick = () => {
                        console.log('Create API Bulletin button clicked');
                        showCreateBoardModal();
                    };
                    console.log('Create button event bound');
                } else {
                    console.error('Create board button not found');
                    alert('UI error: Create button missing. Please reload the page.');
                }

                if (joinBoardBtn) {
                    joinBoardBtn.onclick = showJoinBoardModal;
                    console.log('Join button event bound');
                }

                if (refreshBoardsBtn) {
                    refreshBoardsBtn.onclick = refreshPublicBoards;
                    console.log('Refresh button event bound');
                }

                console.log('Initialization complete');
            } catch (error) {
                console.error('Initialization failed:', error);
            }
        }

        initialize();
    </script>
</body>
</html>
