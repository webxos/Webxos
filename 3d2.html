<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebX Universe 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Orbitron', -apple-system, BlinkMacSystemFont, sans-serif;
        }
        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            touch-action: none;
        }
        #gameCanvas {
            flex: 1;
            width: 100%;
            position: relative;
        }
        .controls {
            position: fixed;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 15px;
            z-index: 10;
        }
        .joystick-container {
            width: 120px;
            height: 120px;
            background: linear-gradient(135deg, #333, #666);
            border: 2px solid #00ffcc;
            border-radius: 50%;
            position: relative;
            touch-action: none;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
        }
        .joystick {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #ff4444, #cc0000);
            border-radius: 50%;
            position: absolute;
            top: 30px;
            left: 30px;
            transform: translate(0, 0);
            box-shadow: 0 0 8px rgba(255, 68, 68, 0.8);
        }
        .action-buttons {
            display: flex;
            gap: 15px;
        }
        button {
            background: linear-gradient(45deg, #1a3c34, #00ffcc);
            border: 2px solid #00ffcc;
            padding: 20px;
            color: #fff;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 70px;
            height: 70px;
            text-align: center;
            box-shadow: 0 0 12px rgba(0, 255, 204, 0.5);
        }
        button:active {
            transform: scale(0.85);
            box-shadow: 0 0 20px rgba(0, 255, 204, 1);
        }
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            color: #00ffcc;
            font-size: 16px;
            z-index: 5;
        }
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #00ffcc;
            text-shadow: 0 0 5px rgba(0, 255, 204, 0.8);
        }
        .status {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border: 1px solid #00ffcc;
            border-radius: 5px;
        }
        .quest-log {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            max-width: 250px;
            border: 1px solid #00ffcc;
            border-radius: 5px;
        }
        .minimap {
            position: absolute;
            bottom: 150px;
            right: 15px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffcc;
            border-radius: 10px;
            overflow: hidden;
        }
        .minimap canvas {
            width: 100%;
            height: 100%;
        }
        .footer {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            font-size: 10px;
            color: #00ffcc;
            z-index: 5;
            text-shadow: 0 0 5px rgba(0, 255, 204, 0.5);
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="gameCanvas">
        <div class="hud">
            <div class="crosshair">✛</div>
            <div class="status" id="status">Health: 100 | Cooldown: 0%</div>
            <div class="quest-log" id="questLog">Quest: Explore the Ancient Temple</div>
            <div class="minimap"><canvas id="minimapCanvas"></canvas></div>
        </div>
    </div>
    <div class="controls">
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick" id="joystick"></div>
        </div>
        <div class="action-buttons">
            <button id="shootBtn">A</button>
            <button id="sprintBtn">B</button>
        </div>
    </div>
    <div class="footer">© 2025 WebXOS - WebX Universe 3D</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r169/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/4.0.1/simplex-noise.min.js"></script>
    <script>
        window.onload = () => {
            try {
                // Scene setup
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('gameCanvas').appendChild(renderer.domElement);

                camera.position.set(0, 2, 0); // Eye-level for FPS

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xff9999, 1.2);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                scene.add(directionalLight);

                // Skybox
                const skyTexture = new THREE.CubeTextureLoader().load([
                    'https://example.com/skybox/px.jpg', // Replace with actual skybox textures
                    'https://example.com/skybox/nx.jpg',
                    'https://example.com/skybox/py.jpg',
                    'https://example.com/skybox/ny.jpg',
                    'https://example.com/skybox/pz.jpg',
                    'https://example.com/skybox/nz.jpg'
                ]);
                scene.background = skyTexture;

                // Terrain with displacement
                const terrainSize = 500;
                const terrainSegments = 100;
                const terrainGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSegments, terrainSegments);
                const noise = new SimplexNoise();
                const vertices = terrainGeometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = vertices[i];
                    const z = vertices[i + 1];
                    vertices[i + 2] = noise.noise2D(x / 50, z / 50) * 10; // Heightmap
                }
                terrainGeometry.computeVertexNormals();
                const terrainMaterial = new THREE.MeshStandardMaterial({
                    map: new THREE.TextureLoader().load('https://example.com/textures/rock_diffuse.jpg'),
                    normalMap: new THREE.TextureLoader().load('https://example.com/textures/rock_normal.jpg'),
                    roughnessMap: new THREE.TextureLoader().load('https://example.com/textures/rock_roughness.jpg'),
                    metalness: 0.3,
                    roughness: 0.8
                });
                const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
                terrain.rotation.x = -Math.PI / 2;
                terrain.receiveShadow = true;
                scene.add(terrain);

                // Caves and Temples
                const caveGeometry = new THREE.SphereGeometry(10, 16, 16);
                const caveMaterial = new THREE.MeshStandardMaterial({
                    map: new THREE.TextureLoader().load('https://example.com/textures/cave_diffuse.jpg'),
                    normalMap: new THREE.TextureLoader().load('https://example.com/textures/cave_normal.jpg'),
                    roughness: 1.0
                });
                for (let i = 0; i < 3; i++) {
                    const cave = new THREE.Mesh(caveGeometry, caveMaterial);
                    cave.position.set(
                        (Math.random() - 0.5) * terrainSize * 0.8,
                        -5,
                        (Math.random() - 0.5) * terrainSize * 0.8
                    );
                    cave.receiveShadow = true;
                    scene.add(cave);
                    const pointLight = new THREE.PointLight(0x00ffcc, 1, 20);
                    pointLight.position.copy(cave.position);
                    scene.add(pointLight);
                }

                const templeGeometry = new THREE.BoxGeometry(10, 5, 10);
                const templeMaterial = new THREE.MeshStandardMaterial({
                    map: new THREE.TextureLoader().load('https://example.com/textures/temple_diffuse.jpg'),
                    normalMap: new THREE.TextureLoader().load('https://example.com/textures/temple_normal.jpg'),
                    metalness: 0.5,
                    roughness: 0.4
                });
                for (let i = 0; i < 2; i++) {
                    const temple = new THREE.Mesh(templeGeometry, templeMaterial);
                    temple.position.set(
                        (Math.random() - 0.5) * terrainSize * 0.6,
                        2.5,
                        (Math.random() - 0.5) * terrainSize * 0.6
                    );
                    temple.castShadow = true;
                    temple.receiveShadow = true;
                    scene.add(temple);
                }

                // Enemies
                const enemyTypes = [
                    { geometry: new THREE.BoxGeometry(1, 1, 1), material: new THREE.MeshBasicMaterial({ color: 0x00ff00 }), speed: 2, health: 50, type: 'melee' },
                    { geometry: new THREE.SphereGeometry(0.8, 16, 16), material: new THREE.MeshBasicMaterial({ color: 0xff0000 }), speed: 1.5, health: 75, type: 'ranged' }
                ];
                const enemies = [];
                function spawnEnemy() {
                    const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                    const enemy = new THREE.Mesh(type.geometry, type.material);
                    enemy.position.set(
                        (Math.random() - 0.5) * terrainSize * 0.9,
                        1,
                        (Math.random() - 0.5) * terrainSize * 0.9
                    );
                    enemy.userData = { health: type.health, velocity: new THREE.Vector3(), type: type.type, speed: type.speed };
                    enemy.castShadow = true;
                    scene.add(enemy);
                    enemies.push(enemy);
                }
                for (let i = 0; i < 15; i++) spawnEnemy();
                setInterval(spawnEnemy, 5000); // Spawn every 5 seconds

                // Player state
                const player = {
                    health: 100,
                    shootCooldown: 0,
                    speed: 6,
                    sprintSpeed: 12,
                    velocity: new THREE.Vector3(),
                    rotation: { pitch: 0, yaw: 0 },
                    rotationVelocity: { pitch: 0, yaw: 0 },
                    isSprinting: false,
                    bobTime: 0
                };

                // Joystick controls
                const joystickContainer = document.getElementById('joystickContainer');
                const joystick = document.getElementById('joystick');
                let joystickActive = false;
                let joystickOrigin = { x: 0, y: 0 };
                let joystickDelta = { x: 0, y: 0 };

                joystickContainer.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    joystickActive = true;
                    const touch = e.touches[0];
                    joystickOrigin = { x: touch.clientX, y: touch.clientY };
                    if ('vibrate' in navigator) navigator.vibrate(50);
                });

                joystickContainer.addEventListener('touchmove', (e) => {
                    if (!joystickActive) return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    const dx = touch.clientX - joystickOrigin.x;
                    const dy = touch.clientY - joystickOrigin.y;
                    const maxRadius = 60;
                    const magnitude = Math.sqrt(dx * dx + dy * dy);
                    if (magnitude > maxRadius) {
                        const scale = maxRadius / magnitude;
                        joystickDelta.x = dx * scale;
                        joystickDelta.y = dy * scale;
                    } else {
                        joystickDelta.x = dx;
                        joystickDelta.y = dy;
                    }
                    joystick.style.transform = `translate(${joystickDelta.x}px, ${joystickDelta.y}px)`;
                });

                joystickContainer.addEventListener('touchend', () => {
                    joystickActive = false;
                    joystickDelta = { x: 0, y: 0 };
                    joystick.style.transform = `translate(0, 0)`;
                });

                // Action buttons
                const shootBtn = document.getElementById('shootBtn');
                const sprintBtn = document.getElementById('sprintBtn');
                shootBtn.addEventListener('click', () => {
                    if (player.shootCooldown <= 0) {
                        shoot();
                        player.shootCooldown = 0.5; // 500ms cooldown
                        if ('vibrate' in navigator) navigator.vibrate(100);
                    }
                });
                sprintBtn.addEventListener('touchstart', () => {
                    player.isSprinting = true;
                    if ('vibrate' in navigator) navigator.vibrate(50);
                });
                sprintBtn.addEventListener('touchend', () => {
                    player.isSprinting = false;
                });

                // Desktop controls
                const keys = {};
                window.addEventListener('keydown', (e) => { keys[e.code] = true; });
                window.addEventListener('keyup', (e) => { keys[e.code] = false; });
                let mouseDown = false;
                window.addEventListener('mousedown', () => { mouseDown = true; });
                window.addEventListener('mouseup', () => { mouseDown = false; });
                window.addEventListener('mousemove', (e) => {
                    player.rotationVelocity.yaw -= e.movementX * 0.002;
                    player.rotationVelocity.pitch -= e.movementY * 0.002;
                });

                // Touch look controls
                let isLooking = false;
                let previousTouch = { x: 0, y: 0 };
                document.getElementById('gameCanvas').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    isLooking = true;
                    previousTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                });

                document.getElementById('gameCanvas').addEventListener('touchmove', (e) => {
                    if (!isLooking) return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - previousTouch.x;
                    const deltaY = touch.clientY - previousTouch.y;
                    player.rotationVelocity.yaw -= deltaX * 0.003;
                    player.rotationVelocity.pitch -= deltaY * 0.003;
                    previousTouch = { x: touch.clientX, y: touch.clientY };
                });

                document.getElementById('gameCanvas').addEventListener('touchend', () => {
                    isLooking = false;
                });

                // Shooting mechanics
                const projectiles = [];
                function shoot() {
                    const audio = new Audio('https://example.com/sounds/shoot.mp3');
                    audio.play();
                    const projectileGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const projectileMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
                    const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    projectile.position.copy(camera.position).add(forward.multiplyScalar(0.5));
                    projectile.userData = { velocity: forward.multiplyScalar(30), remove: false };
                    scene.add(projectile);
                    projectiles.push(projectile);
                    // Particle effect
                    const particleGeometry = new THREE.BufferGeometry();
                    const particleCount = 10;
                    const positions = new Float32Array(particleCount * 3);
                    for (let i = 0; i < particleCount; i++) {
                        positions[i * 3] = (Math.random() - 0.5) * 0.2;
                        positions[i * 3 + 1] = (Math.random() - 0.5) * 0.2;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
                    }
                    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    const particleMaterial = new THREE.PointsMaterial({ color: 0xffff00, size: 0.1 });
                    const particles = new THREE.Points(particleGeometry, particleMaterial);
                    particles.position.copy(projectile.position);
                    scene.add(particles);
                    setTimeout(() => scene.remove(particles), 500);
                }

                // Quest system
                const quests = [
                    { id: 1, text: "Explore the Ancient Temple", target: new THREE.Vector3(50, 2.5, -50) },
                    { id: 2, text: "Defeat 10 Enemies", kills: 0, targetKills: 10 },
                    { id: 3, text: "Retrieve the Data Core from Cave", target: new THREE.Vector3(-30, -5, 40) }
                ];
                let currentQuest = quests[0];

                // Minimap
                const minimapCanvas = document.getElementById('minimapCanvas');
                const minimapCtx = minimapCanvas.getContext('2d');
                minimapCanvas.width = 150;
                minimapCanvas.height = 150;

                function updateMinimap() {
                    minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    minimapCtx.fillRect(0, 0, 150, 150);
                    // Player
                    minimapCtx.fillStyle = '#00ffcc';
                    minimapCtx.fillRect(75 - 2, 75 - 2, 4, 4);
                    // Enemies
                    enemies.forEach(enemy => {
                        const dx = enemy.position.x - camera.position.x;
                        const dz = enemy.position.z - camera.position.z;
                        const mx = 75 + (dx / terrainSize) * 150;
                        const my = 75 + (dz / terrainSize) * 150;
                        if (mx >= 0 && mx <= 150 && my >= 0 && my <= 150) {
                            minimapCtx.fillStyle = enemy.userData.type === 'melee' ? '#00ff00' : '#ff0000';
                            minimapCtx.fillRect(mx - 2, my - 2, 4, 4);
                        }
                    });
                    // Quest target
                    if (currentQuest.target) {
                        const dx = currentQuest.target.x - camera.position.x;
                        const dz = currentQuest.target.z - camera.position.z;
                        const mx = 75 + (dx / terrainSize) * 150;
                        const my = 75 + (dz / terrainSize) * 150;
                        if (mx >= 0 && mx <= 150 && my >= 0 && my <= 150) {
                            minimapCtx.fillStyle = '#ffff00';
                            minimapCtx.fillRect(mx - 3, my - 3, 6, 6);
                        }
                    }
                }

                function updateHUD() {
                    document.getElementById('status').textContent = `Health: ${player.health} | Cooldown: ${Math.max(0, Math.floor(player.shootCooldown * 100))}%`;
                    document.getElementById('questLog').textContent = `Quest: ${currentQuest.text}`;
                }

                // Physics and collision
                const gravity = -9.8;
                function getTerrainHeight(x, z) {
                    const scale = 50;
                    return noise.noise2D(x / scale, z / scale) * 10;
                }

                // Animation loop
                let lastTime = performance.now();
                function animate() {
                    requestAnimationFrame(animate);
                    const now = performance.now();
                    const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
                    lastTime = now;

                    // Player rotation
                    player.rotation.pitch += player.rotationVelocity.pitch * deltaTime;
                    player.rotation.yaw += player.rotationVelocity.yaw * deltaTime;
                    player.rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.pitch));
                    player.rotationVelocity.pitch *= 0.9;
                    player.rotationVelocity.yaw *= 0.9;
                    camera.quaternion.setFromEuler(new THREE.Euler(player.rotation.pitch, player.rotation.yaw, 0, 'YXZ'));

                    // Camera bob
                    if (player.velocity.length() > 0) {
                        player.bobTime += deltaTime * (player.isSprinting ? 10 : 5);
                        camera.position.y += Math.sin(player.bobTime) * 0.05;
                    }

                    // Player movement
                    const speed = player.isSprinting ? player.sprintSpeed : player.speed;
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    player.velocity.set(0, player.velocity.y, 0);
                    if (joystickActive) {
                        const moveX = joystickDelta.x / 60;
                        const moveZ = joystickDelta.y / 60;
                        player.velocity.add(right.multiplyScalar(moveX * speed));
                        player.velocity.add(forward.multiplyScalar(-moveZ * speed));
                    }
                    if (keys['KeyW']) player.velocity.add(forward.multiplyScalar(speed));
                    if (keys['KeyS']) player.velocity.add(forward.multiplyScalar(-speed));
                    if (keys['KeyA']) player.velocity.add(right.multiplyScalar(-speed));
                    if (keys['KeyD']) player.velocity.add(right.multiplyScalar(speed));
                    if (keys['Space']) player.isSprinting = true;
                    else if (!sprintBtn.ontouchstart) player.isSprinting = false;
                    if (mouseDown && player.shootCooldown <= 0) {
                        shoot();
                        player.shootCooldown = 0.5;
                    }

                    // Apply gravity and terrain height
                    player.velocity.y += gravity * deltaTime;
                    camera.position.add(player.velocity.clone().multiplyScalar(deltaTime));
                    const terrainHeight = getTerrainHeight(camera.position.x, camera.position.z) + 2;
                    if (camera.position.y < terrainHeight) {
                        camera.position.y = terrainHeight;
                        player.velocity.y = 0;
                    }

                    // Enemy AI
                    enemies.forEach((enemy) => {
                        const direction = camera.position.clone().sub(enemy.position).normalize();
                        if (enemy.userData.type === 'melee') {
                            enemy.userData.velocity.copy(direction.multiplyScalar(enemy.userData.speed));
                            enemy.position.add(enemy.userData.velocity.clone().multiplyScalar(deltaTime));
                            enemy.position.y = getTerrainHeight(enemy.position.x, enemy.position.z) + 1;
                            if (enemy.position.distanceTo(camera.position) < 1.5) {
                                player.health -= 10 * deltaTime;
                                updateHUD();
                            }
                        } else {
                            if (Math.random() < 0.01) {
                                const projectileGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                                const projectileMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                                const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
                                projectile.position.copy(enemy.position);
                                projectile.userData = { velocity: direction.multiplyScalar(15), remove: false };
                                scene.add(projectile);
                                projectiles.push(projectile);
                            }
                        }
                    });

                    // Projectile updates
                    const projectilesToRemove = [];
                    projectiles.forEach((projectile, i) => {
                        projectile.position.add(projectile.userData.velocity.clone().multiplyScalar(deltaTime));
                        if (projectile.position.length() > terrainSize) {
                            projectile.userData.remove = true;
                            projectilesToRemove.push(i);
                        }
                        enemies.forEach((enemy, j) => {
                            if (projectile.position.distanceTo(enemy.position) < 1) {
                                enemy.userData.health -= 25;
                                projectile.userData.remove = true;
                                projectilesToRemove.push(i);
                                if (enemy.userData.health <= 0) {
                                    const audio = new Audio('https://example.com/sounds/explosion.mp3');
                                    audio.play();
                                    scene.remove(enemy);
                                    enemies.splice(j, 1);
                                    if (currentQuest.id === 2) {
                                        currentQuest.kills++;
                                        if (currentQuest.kills >= currentQuest.targetKills) {
                                            currentQuest = quests[Math.min(currentQuest.id, quests.length - 1)];
                                        }
                                        updateHUD();
                                    }
                                }
                            }
                        });
                        if (projectile.userData.velocity.length() === 15 && projectile.position.distanceTo(camera.position) < 1) {
                            player.health -= 20;
                            projectile.userData.remove = true;
                            projectilesToRemove.push(i);
                            updateHUD();
                        }
                    });
                    projectilesToRemove.sort((a, b) => b - a).forEach((i) => {
                        scene.remove(projectiles[i]);
                        projectiles.splice(i, 1);
                    });

                    // Quest progress
                    if (currentQuest.target && camera.position.distanceTo(currentQuest.target) < 5) {
                        currentQuest = quests[Math.min(currentQuest.id, quests.length - 1)];
                        updateHUD();
                    }

                    // Cooldown
                    player.shootCooldown = Math.max(0, player.shootCooldown - deltaTime);

                    // Minimap
                    updateMinimap();

                    renderer.render(scene, camera);
                }

                // Resize handling
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    minimapCanvas.width = 150;
                    minimapCanvas.height = 150;
                });

                // Initialize
                updateHUD();
                animate();
            } catch (e) {
                console.error('Game initialization error:', e);
            }
        };
    </script>
</body>
</html>
