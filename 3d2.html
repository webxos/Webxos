<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebX Universe 3D - Debug</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Orbitron', -apple-system, BlinkMacSystemFont, sans-serif;
        }
        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            touch-action: none;
        }
        #gameCanvas {
            flex: 1;
            width: 100%;
            position: relative;
        }
        .controls {
            position: fixed;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 15px;
            z-index: 10;
        }
        .joystick-container {
            width: 120px;
            height: 120px;
            background: linear-gradient(135deg, #333, #666);
            border: 2px solid #00ffcc;
            border-radius: 50%;
            position: relative;
            touch-action: none;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
        }
        .joystick {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #ff4444, #cc0000);
            border-radius: 50%;
            position: absolute;
            top: 30px;
            left: 30px;
            transform: translate(0, 0);
            box-shadow: 0 0 8px rgba(255, 68, 68, 0.8);
        }
        .action-buttons {
            display: flex;
            gap: 15px;
        }
        button {
            background: linear-gradient(45deg, #1a3c34, #00ffcc);
            border: 2px solid #00ffcc;
            padding: 20px;
            color: #fff;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 70px;
            height: 70px;
            text-align: center;
            box-shadow: 0 0 12px rgba(0, 255, 204, 0.5);
        }
        button:active {
            transform: scale(0.85);
            box-shadow: 0 0 20px rgba(0, 255, 204, 1);
        }
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            color: #00ffcc;
            font-size: 16px;
            z-index: 5;
        }
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #00ffcc;
            text-shadow: 0 0 5px rgba(0, 255, 204, 0.8);
        }
        .status {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border: 1px solid #00ffcc;
            border-radius: 5px;
        }
        .footer {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            font-size: 10px;
            color: #00ffcc;
            z-index: 5;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="gameCanvas">
        <div class="hud">
            <div class="crosshair">✛</div>
            <div class="status" id="status">Health: 100</div>
        </div>
    </div>
    <div class="controls">
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick" id="joystick"></div>
        </div>
        <div class="action-buttons">
            <button id="shootBtn">A</button>
            <button id="sprintBtn">B</button>
        </div>
    </div>
    <div class="footer">© 2025 WebXOS - WebX Universe 3D</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r169/three.min.js"></script>
    <script>
        window.onload = () => {
            try {
                console.log("Initializing WebX Universe 3D...");

                // Scene setup
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x333333); // Gray background for visibility
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
                
                // Verify WebGL support
                if (!renderer.getContext()) {
                    console.error("WebGL not supported by this browser.");
                    alert("WebGL is not supported. Please use a modern browser like Chrome or Firefox.");
                    return;
                }

                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                renderer.setSize(window.innerWidth, window.innerHeight);
                const canvas = renderer.domElement;
                canvas.style.display = 'block'; // Ensure canvas is visible
                document.getElementById('gameCanvas').appendChild(canvas);
                console.log("Renderer initialized, canvas appended.");

                // Camera position
                camera.position.set(0, 5, 10); // Position camera to see origin
                camera.lookAt(0, 0, 0); // Look at origin
                console.log("Camera set to position:", camera.position);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Bright ambient light
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(5, 10, 5);
                scene.add(directionalLight);
                console.log("Lighting added.");

                // Test object (red cube)
                const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
                const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // No lighting dependency
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cube.position.set(0, 1, 0); // Place at origin, slightly raised
                scene.add(cube);
                console.log("Red cube added at position:", cube.position);

                // Player state
                const player = {
                    health: 100,
                    velocity: new THREE.Vector3(),
                    rotation: { pitch: 0, yaw: 0 },
                    rotationVelocity: { pitch: 0, yaw: 0 },
                    isSprinting: false
                };

                // Joystick controls
                const joystickContainer = document.getElementById('joystickContainer');
                const joystick = document.getElementById('joystick');
                let joystickActive = false;
                let joystickOrigin = { x: 0, y: 0 };
                let joystickDelta = { x: 0, y: 0 };

                joystickContainer.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    joystickActive = true;
                    const touch = e.touches[0];
                    joystickOrigin = { x: touch.clientX, y: touch.clientY };
                    console.log("Joystick touch started.");
                });

                joystickContainer.addEventListener('touchmove', (e) => {
                    if (!joystickActive) return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    const dx = touch.clientX - joystickOrigin.x;
                    const dy = touch.clientY - joystickOrigin.y;
                    const maxRadius = 60;
                    const magnitude = Math.sqrt(dx * dx + dy * dy);
                    if (magnitude > maxRadius) {
                        const scale = maxRadius / magnitude;
                        joystickDelta.x = dx * scale;
                        joystickDelta.y = dy * scale;
                    } else {
                        joystickDelta.x = dx;
                        joystickDelta.y = dy;
                    }
                    joystick.style.transform = `translate(${joystickDelta.x}px, ${joystickDelta.y}px)`;
                });

                joystickContainer.addEventListener('touchend', () => {
                    joystickActive = false;
                    joystickDelta = { x: 0, y: 0 };
                    joystick.style.transform = `translate(0, 0)`;
                    console.log("Joystick touch ended.");
                });

                // Action buttons
                document.getElementById('shootBtn').addEventListener('click', () => {
                    console.log("Shoot button clicked.");
                });

                document.getElementById('sprintBtn').addEventListener('touchstart', () => {
                    player.isSprinting = true;
                    console.log("Sprint started.");
                });
                document.getElementById('sprintBtn').addEventListener('touchend', () => {
                    player.isSprinting = false;
                    console.log("Sprint ended.");
                });

                // Touch look controls
                let isLooking = false;
                let previousTouch = { x: 0, y: 0 };
                document.getElementById('gameCanvas').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    isLooking = true;
                    previousTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                });

                document.getElementById('gameCanvas').addEventListener('touchmove', (e) => {
                    if (!isLooking) return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - previousTouch.x;
                    const deltaY = touch.clientY - previousTouch.y;
                    player.rotationVelocity.yaw -= deltaX * 0.003;
                    player.rotationVelocity.pitch -= deltaY * 0.003;
                    previousTouch = { x: touch.clientX, y: touch.clientY };
                });

                document.getElementById('gameCanvas').addEventListener('touchend', () => {
                    isLooking = false;
                });

                // Animation loop
                let lastTime = performance.now();
                function animate() {
                    requestAnimationFrame(animate);
                    const now = performance.now();
                    const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
                    lastTime = now;

                    // Rotate cube for visibility
                    cube.rotation.x += deltaTime;
                    cube.rotation.y += deltaTime;

                    // Player rotation
                    player.rotation.pitch += player.rotationVelocity.pitch * deltaTime;
                    player.rotation.yaw += player.rotationVelocity.yaw * deltaTime;
                    player.rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.pitch));
                    player.rotationVelocity.pitch *= 0.9;
                    player.rotationVelocity.yaw *= 0.9;
                    camera.quaternion.setFromEuler(new THREE.Euler(player.rotation.pitch, player.rotation.yaw, 0, 'YXZ'));

                    // Player movement
                    const speed = player.isSprinting ? 10 : 5;
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    player.velocity.set(0, 0, 0);
                    if (joystickActive) {
                        const moveX = joystickDelta.x / 60;
                        const moveZ = joystickDelta.y / 60;
                        player.velocity.add(right.multiplyScalar(moveX * speed));
                        player.velocity.add(forward.multiplyScalar(-moveZ * speed));
                    }
                    camera.position.add(player.velocity.clone().multiplyScalar(deltaTime));

                    renderer.render(scene, camera);
                }

                // Resize handling
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    console.log("Window resized, renderer updated.");
                });

                // Initialize
                document.getElementById('status').textContent = `Health: ${player.health}`;
                console.log("Starting animation loop...");
                animate();
            } catch (e) {
                console.error('Game initialization error:', e);
                alert("Failed to initialize game: " + e.message);
            }
        };
    </script>
</body>
</html>
