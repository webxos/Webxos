<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0f0">
    <meta name="description" content="Watchdog AI BETA tests users carbon emissions data">
    <meta name="keywords" content="sustainable software, green coding, eco web design, carbon testing, energy consumption studies, browser energy efficiency, eco-friendly web, green tech, carbon footprint, web performance, sustainable web development">
    <meta name="author" content="WebXOS">
    <meta name="robots" content="index, follow">
    <meta name="application-name" content="Watchdog AI BETA">
    <meta property="og:title" content="Watchdog AI BETA: Sustainable Browser Energy Testing">
    <meta property="og:description" content="Measure your browser's energy efficiency and carbon footprint with Watchdog AI BETA. Optimize for green coding and eco web design.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://watchdog-ai-beta.webxos.com">
    <meta property="og:image" content="https://watchdog-ai-beta.webxos.com/icon.png">
    <meta property="og:site_name" content="Watchdog AI BETA">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Watchdog AI BETA: Green Coding & Carbon Testing">
    <meta name="twitter:description" content="Test browser energy consumption and reduce your carbon footprint with Watchdog AI BETA. Built for sustainable software and eco web design.">
    <meta name="twitter:image" content="https://watchdog-ai-beta.webxos.com/icon.png">
    <meta name="twitter:site" content="@WebXOS">
    <title>Watchdog AI BETA: Sustainable Software & Green Coding</title>
    <link rel="icon" href="icon.png">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: monospace, sans-serif;
        }

        html, body {
            height: 100vh;
            overflow: hidden;
            background: #000;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: background 0.3s, box-shadow 0.3s;
            -webkit-tap-highlight-color: transparent;
        }

        body.glow {
            background: rgba(255, 0, 0, 0.1);
            box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000 inset;
        }

        h1 {
            font-size: 1.6rem;
            text-align: center;
            margin: 0.8rem 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 5px #0f0;
        }

        #console {
            width: 90%;
            max-width: 900px;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0f0;
            padding: 0.6rem;
            flex: 1;
            max-height: calc(100vh - 240px);
            overflow-y: auto;
            margin: 0.5rem 0;
            border-radius: 5px;
            font-size: 0.8rem;
            -webkit-overflow-scrolling: touch;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        #console.active-byte {
            border-color: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }

        #console p {
            margin: 0.2rem 0;
        }

        #console .command {
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            text-shadow: 0 0 3px #0f0;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
            margin: 0.5rem 0;
            padding: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
            width: 90%;
            max-width: 900px;
        }

        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 0.6rem 1.2rem;
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 3px;
            min-width: 90px;
            text-align: center;
            touch-action: manipulation;
            transition: background 0.3s, box-shadow 0.3s;
        }

        button:hover, button:focus {
            background: #0c0;
            outline: 2px solid #0f0;
        }

        button.active-byte {
            background: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #eco-stats {
            width: 90%;
            max-width: 900px;
            margin: 0.5rem 0;
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }

        .progress-container {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .progress-label {
            width: 90px;
            font-size: 0.75rem;
        }

        .progress-bar {
            flex: 1;
            height: 8px;
            background: #333;
            border: 1px solid #0f0;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #0f0;
            transition: width 0.5s;
        }

        footer {
            width: 100%;
            padding: 0.4rem;
            font-size: 9pt;
            text-align: center;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            line-height: 1.2;
        }

        @media (max-width: 600px) {
            h1 { font-size: 1.1rem; margin: 0.5rem 0; }
            #console { 
                font-size: 0.75rem; 
                padding: 0.5rem; 
                max-height: calc(100vh - 220px); 
            }
            button { 
                padding: 0.5rem 1rem; 
                font-size: 0.85rem; 
                min-width: 80px; 
            }
            footer { padding: 0.3rem; }
            .progress-label { width: 70px; font-size: 0.7rem; }
            .progress-bar { height: 7px; }
        }

        @media (max-width: 400px) {
            .button-group { flex-direction: column; align-items: center; }
            button { width: 100%; max-width: 160px; }
            #console { max-height: calc(100vh - 200px); }
            #eco-stats { gap: 0.15rem; }
        }
    </style>
</head>
<body>
    <h1 role="heading" aria-level="1">Watchdog AI BETA</h1>
    <div id="console" role="log" aria-live="polite">
        <p>Watchdog AI BETA User Guide: Bark: Run tests & copy certificate | Byte: Toggle eco monitoring | Reset: Clear console</p>
    </div>
    <div id="eco-stats">
        <div class="progress-container">
            <span class="progress-label">Latency:</span>
            <div class="progress-bar"><div class="progress-fill" id="latency-bar" style="width: 0%"></div></div>
            <span id="latency-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Power Usage:</span>
            <div class="progress-bar"><div class="progress-fill" id="power-bar" style="width: 0%"></div></div>
            <span id="power-value">0 W</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Memory Usage:</span>
            <div class="progress-bar"><div class="progress-fill" id="memory-bar" style="width: 0%"></div></div>
            <span id="memory-value">0 MB</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Carbon Footprint:</span>
            <div class="progress-bar"><div class="progress-fill" id="carbon-bar" style="width: 0%"></div></div>
            <span id="carbon-value">0 kg CO2/h</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">CPU Eff:</span>
            <div class="progress-bar"><div class="progress-fill" id="cpueff-bar" style="width: 0%"></div></div>
            <span id="cpueff-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Battery:</span>
            <div class="progress-bar"><div class="progress-fill" id="battery-bar" style="width: 0%"></div></div>
            <span id="battery-value">0 %</span>
        </div>
    </div>
    <div class="button-group">
        <button id="bark-btn" aria-label="Run performance tests and copy certificate">Bark</button>
        <button id="byte-btn" aria-label="Toggle eco monitoring">Byte</button>
        <button id="reset-btn" aria-label="Clear console output">Reset</button>
    </div>
    <footer>
        Â© 2025 WebXOS - Watchdog AI BETA<br>
        Bark: Run tests & copy certificate | Byte: Toggle eco monitoring | Reset: Clear console
    </footer>

    <script>
        function debugLog(message) {
            console.log(`[DEBUG] ${message}`);
        }

        const consoleDiv = document.getElementById('console');
        let logQueue = [];
        function log(message, isCommand = false) {
            const formattedMessage = isCommand 
                ? `<span class="command">${message}</span>`
                : message;
            logQueue.push(`[${new Date().toLocaleTimeString()}] ${formattedMessage}`);
            if (logQueue.length > 50) logQueue.shift();
            throttleConsoleUpdate();
        }

        const throttleConsoleUpdate = (() => {
            let timeout;
            return () => {
                if (!timeout) {
                    timeout = setTimeout(() => {
                        consoleDiv.innerHTML = logQueue.map(msg => `<p>${msg}</p>`).join('');
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        timeout = null;
                    }, 100);
                }
            };
        })();

        function triggerGlow() {
            document.body.classList.add('glow');
            setTimeout(() => document.body.classList.remove('glow'), 1000);
        }

        function flashRedGlow() {
            consoleDiv.classList.add('active-byte');
            setTimeout(() => consoleDiv.classList.remove('active-byte'), 500);
            setTimeout(() => {
                consoleDiv.classList.add('active-byte');
                setTimeout(() => consoleDiv.classList.remove('active-byte'), 500);
            }, 1000);
        }

        function resetConsole() {
            debugLog('Reset button clicked');
            try {
                logQueue = ['Watchdog AI BETA User Guide: Bark: Run tests & copy certificate | Byte: Toggle eco monitoring | Reset: Clear console'];
                throttleConsoleUpdate();
                log('Console cleared.', true);
            } catch (err) {
                log(`Reset Error: ${err.message}`, true);
                debugLog(`Reset Error: ${err.stack}`);
            }
        }

        function calculateMetrics(results) {
            const totalScore = results.reduce((sum, result) => sum + result.score, 0);
            const maxScore = results.length * 10;
            const normalizedScore = Math.round((totalScore / maxScore) * 100);
            const estimatedWatts = 40 + (100 - normalizedScore) * 2;
            const carbonFootprint = (estimatedWatts * 0.000531).toFixed(3);
            return { totalScore, maxScore, normalizedScore, estimatedWatts, carbonFootprint };
        }

        class AdvancedAgent {
            constructor(name, tests) {
                this.name = name;
                this.tests = tests;
                this.results = [];
                this.isMobile = /Mobi|Android/i.test(navigator.userAgent);
                this.selectedTests = null;
                this.baselineFactor = 1;
            }

            async calibrate() {
                const start = performance.now();
                let sum = 0;
                for (let i = 0; i < 10000; i++) sum += Math.sqrt(i);
                const baselineTime = performance.now() - start;
                this.baselineFactor = Math.min(2, Math.max(0.5, baselineTime / 10));
                debugLog(`Baseline factor: ${this.baselineFactor}`);
            }

            selectTests() {
                if (this.selectedTests) return this.selectedTests;
                const supportedTests = this.tests.filter(test => {
                    if (test.requires && !test.requires()) return false;
                    if (this.isMobile && test.heavy) return false;
                    return true;
                });
                this.selectedTests = supportedTests;
                return this.selectedTests;
            }

            async runTests() {
                await this.calibrate();
                this.results = [];
                const selectedTests = this.selectTests();
                log(`Running ${selectedTests.length} eco tests...`, true);

                for (const test of selectedTests) {
                    const iterations = this.isMobile ? test.iterations * 0.5 : test.iterations;
                    const result = await test.fn(iterations, this.baselineFactor);
                    this.results.push({ name: test.name, ...result });
                    log(`${test.name}: ${result.score}/10 (${result.details})`);
                }
                return this.results;
            }
        }

        const tests = [
            {
                name: 'CPU Efficiency',
                category: 'cpu',
                iterations: 500000,
                fn: async (iterations, baselineFactor) => {
                    const start = performance.now();
                    let load = 0;
                    for (let i = 0; i < iterations; i++) load += Math.random();
                    const time = performance.now() - start;
                    const threshold1 = 40 * baselineFactor;
                    const threshold2 = 80 * baselineFactor;
                    return {
                        score: time < threshold1 ? 8 : time < threshold2 ? 6 : 4,
                        details: `Stress test in ${time.toFixed(2)}ms`,
                        metric: time
                    };
                }
            },
            {
                name: 'Memory Usage',
                category: 'memory',
                iterations: 200000,
                requires: () => !!performance.memory,
                fn: async (iterations, baselineFactor) => {
                    const start = performance.memory.usedJSHeapSize;
                    const array = new Array(iterations).fill(0);
                    const end = performance.memory.usedJSHeapSize;
                    const memUsage = (end - start) / 1024 / 1024;
                    const threshold1 = 2 * baselineFactor;
                    const threshold2 = 8 * baselineFactor;
                    return {
                        score: memUsage < threshold1 ? 8 : memUsage < threshold2 ? 6 : 4,
                        details: `${memUsage.toFixed(2)}MB used`,
                        metric: memUsage
                    };
                }
            },
            {
                name: 'Power Usage',
                category: 'power',
                iterations: 1,
                fn: async (_, baselineFactor) => {
                    const estimatedWatts = 40 * baselineFactor;
                    const threshold1 = 30 * baselineFactor;
                    const threshold2 = 50 * baselineFactor;
                    return {
                        score: estimatedWatts < threshold1 ? 8 : estimatedWatts < threshold2 ? 6 : 4,
                        details: `${estimatedWatts.toFixed(2)}W estimated`,
                        metric: estimatedWatts
                    };
                }
            },
            {
                name: 'Battery Impact',
                category: 'battery',
                iterations: 1,
                requires: () => !!navigator.getBattery,
                fn: async (_, baselineFactor) => {
                    const battery = await navigator.getBattery();
                    const level = battery.level;
                    const score = level > 0.5 ? 8 : level > 0.2 ? 6 : 4;
                    return {
                        score,
                        details: `Level at ${(level * 100).toFixed(0)}%`,
                        metric: level
                    };
                }
            }
        ];

        const enhancementTips = {
            'CPU Efficiency': (result, isMobile) => {
                const time = parseFloat(result.details);
                const isSevere = time > 80;
                return {
                    firstStep: isSevere ? 'Shut down background processes to reduce CPU load.' : 'Enable power-saving mode to lower CPU usage.',
                    tips: isSevere 
                        ? '- Shut down background processes.\n- Check for system updates.\n'
                        : '- Limit background apps.\n- Enable power-saving mode.\n',
                    message: isMobile
                        ? `CPU stress test took ${time.toFixed(2)}ms. ${isSevere ? 'Restart your device to free resources.' : 'Close unused apps to save energy.'}`
                        : `CPU efficiency is low (${time.toFixed(2)}ms). ${isSevere ? 'Close heavy applications or update drivers.' : 'Enable power-saving settings.'}`
                };
            },
            'Memory Usage': (result, isMobile) => {
                const memUsage = parseFloat(result.details);
                const isSevere = memUsage > 8;
                return {
                    firstStep: isSevere ? 'Close memory-intensive apps to free up RAM.' : 'Disable unused browser extensions to reduce memory usage.',
                    tips: isSevere 
                        ? '- Close memory-intensive apps.\n- Clear browser cache.\n'
                        : '- Disable unused extensions.\n- Free up RAM.\n',
                    message: isMobile
                        ? `Memory usage high (${memUsage.toFixed(2)}MB). ${isSevere ? 'Close apps or restart your device.' : 'Disable heavy extensions to reduce memory load.'}`
                        : `Memory usage at ${memUsage.toFixed(2)}MB. ${isSevere ? 'Close other applications or restart.' : 'Clear cache to optimize memory.'}`
                };
            },
            'Power Usage': (result, isMobile) => {
                const watts = parseFloat(result.details);
                const isSevere = watts > 50;
                return {
                    firstStep: isSevere ? 'Reduce screen brightness to lower power consumption.' : 'Enable power-saving mode to optimize energy usage.',
                    tips: isSevere 
                        ? '- Reduce screen brightness.\n- Close high-power apps.\n'
                        : '- Enable power-saving mode.\n- Limit background processes.\n',
                    message: isMobile
                        ? `Power usage at ${watts.toFixed(2)}W. ${isSevere ? 'Lower brightness or close apps.' : 'Use power-saving mode to optimize.'}`
                        : `Power usage high (${watts.toFixed(2)}W). ${isSevere ? 'Reduce brightness or close apps.' : 'Enable power-saving settings.'}`
                };
            },
            'Battery Impact': (result, isMobile) => {
                const level = result.metric * 100;
                const isSevere = level < 20;
                return {
                    firstStep: isSevere ? 'Charge your device soon to maintain efficiency.' : 'Charge during off-peak hours to optimize battery health.',
                    tips: isSevere 
                        ? '- Charge device soon.\n- Use a high-efficiency charger.\n'
                        : '- Charge during off-peak hours.\n- Avoid overcharging.\n',
                    message: isMobile
                        ? `Battery at ${level.toFixed(0)}%. ${isSevere ? 'Charge now to avoid shutdown.' : 'Charge later to optimize battery health.'}`
                        : `Battery level at ${level.toFixed(0)}%. ${isSevere ? 'Connect to a charger soon.' : 'Charge during off-peak times.'}`
                };
            }
        };

        let byteActive = false;
        let byteStartTime = null;
        let latencyHistory = [];
        let powerHistory = [];
        let memoryHistory = [];
        let carbonHistory = [];
        let cpuEffHistory = [];
        let batteryHistory = [];
        let connectionInterval = null;

        async function runLatencyTest() {
            const start = performance.now();
            await new Promise(resolve => setTimeout(resolve, 10));
            const latency = performance.now() - start;
            latencyHistory.push(latency);
            if (latencyHistory.length > 20) latencyHistory.shift();
            return latency;
        }

        async function runCpuEffTest() {
            const iterations = /Mobi|Android/i.test(navigator.userAgent) ? 10000 : 20000;
            const start = performance.now();
            let load = 0;
            for (let i = 0; i < iterations; i++) load += Math.random();
            const time = performance.now() - start;
            cpuEffHistory.push(time);
            if (cpuEffHistory.length > 20) cpuEffHistory.shift();
            return time;
        }

        function estimatePowerUsage() {
            let power = latencyHistory.length > 0 ? latencyHistory[latencyHistory.length - 1] / 10 : 1;
            if (navigator.getBattery) {
                navigator.getBattery().then(battery => {
                    power *= (1 - battery.level) * 2 + 1;
                });
            }
            power = Math.min(10, Math.max(1, power));
            powerHistory.push(power);
            if (powerHistory.length > 20) powerHistory.shift();
            return power;
        }

        function estimateMemoryUsage() {
            let memory = 1;
            if (performance.memory) {
                memory = performance.memory.usedJSHeapSize / 1024 / 1024;
            } else {
                memory = latencyHistory.length > 0 ? latencyHistory[latencyHistory.length - 1] / 20 + 1 : 1;
            }
            memory = Math.min(20, Math.max(1, memory));
            memoryHistory.push(memory);
            if (memoryHistory.length > 20) memoryHistory.shift();
            return memory;
        }

        async function estimateBatteryLevel() {
            let batteryLevel = 1;
            if (navigator.getBattery) {
                const battery = await navigator.getBattery();
                batteryLevel = battery.level * 100;
            } else {
                batteryLevel = 100;
            }
            batteryLevel = Math.min(100, Math.max(0, batteryLevel));
            batteryHistory.push(batteryLevel);
            if (batteryHistory.length > 20) batteryHistory.shift();
            return batteryLevel;
        }

        function calculateCarbonFootprint(power, memory, cpuEff, batteryLevel) {
            const powerCarbon = power * 0.000531;
            const memoryCarbon = memory * 0.00001;
            const cpuEffCarbon = cpuEff * 0.000001;
            const batteryCarbon = (100 - batteryLevel) * 0.000002;
            const carbon = powerCarbon + memoryCarbon + cpuEffCarbon + batteryCarbon;
            carbonHistory.push(carbon);
            if (carbonHistory.length > 20) carbonHistory.shift();
            return carbon.toFixed(3);
        }

        const ecoStates = {
            Optimal: {
                condition: (latency, power, memory, carbon, cpuEff, battery) => 
                    latency < 50 && power < 3 && memory < 5 && carbon < 0.005 && cpuEff < 50 && battery > 50,
                message: 'Eco State: Optimal - Low resource usage, eco-friendly.',
                hints: [
                    'Maintain settings for eco compliance.',
                    'Keep low brightness on mobile.'
                ]
            },
            Moderate: {
                condition: (latency, power, memory, carbon, cpuEff, battery) => 
                    latency < 100 && power < 5 && memory < 10 && carbon < 0.008 && cpuEff < 80 && battery > 20,
                message: 'Eco State: Moderate - Acceptable usage, optimize further.',
                hints: [
                    'Close unused apps to reduce memory.',
                    'Enable power-saving mode on mobile.'
                ]
            },
            High: {
                condition: (latency, power, memory, carbon, cpuEff, battery) => 
                    latency < 150 && power < 7 && memory < 15 && carbon < 0.01 && cpuEff < 100 && battery > 10,
                message: 'Eco State: High - Elevated usage, action needed.',
                hints: [
                    'Reduce tabs to save memory.',
                    'Charge device to improve efficiency.'
                ]
            },
            Critical: {
                condition: (latency, power, memory, carbon, cpuEff, battery) => 
                    latency >= 150 || power >= 7 || memory >= 15 || carbon >= 0.01 || cpuEff >= 100 || battery <= 10,
                message: 'Eco State: Critical - Excessive usage, immediate action needed.',
                hints: [
                    'Close all unnecessary apps.',
                    'Restart device to free resources.'
                ]
            }
        };

        async function updateEcoStats() {
            const latency = await runLatencyTest();
            const power = estimatePowerUsage();
            const memory = estimateMemoryUsage();
            const cpuEff = await runCpuEffTest();
            const battery = await estimateBatteryLevel();
            const carbon = calculateCarbonFootprint(power, memory, cpuEff, battery);

            document.getElementById('latency-bar').style.width = `${Math.min(100, latency / 2)}%`;
            document.getElementById('latency-value').textContent = `${latency.toFixed(2)} ms`;
            document.getElementById('power-bar').style.width = `${power * 10}%`;
            document.getElementById('power-value').textContent = `${power.toFixed(2)} W`;
            document.getElementById('memory-bar').style.width = `${memory * 5}%`;
            document.getElementById('memory-value').textContent = `${memory.toFixed(2)} MB`;
            document.getElementById('carbon-bar').style.width = `${Math.min(100, carbon * 10000)}%`;
            document.getElementById('carbon-value').textContent = `${carbon} kg CO2/h`;
            document.getElementById('cpueff-bar').style.width = `${Math.min(100, cpuEff / 1.5)}%`;
            document.getElementById('cpueff-value').textContent = `${cpuEff.toFixed(2)} ms`;
            document.getElementById('battery-bar').style.width = `${battery}%`;
            document.getElementById('battery-value').textContent = `${battery.toFixed(0)} %`;

            let currentState = null;
            for (const [state, config] of Object.entries(ecoStates)) {
                if (config.condition(latency, power, memory, carbon, cpuEff, battery)) {
                    currentState = state;
                    log(config.message, true);
                    config.hints.forEach(hint => log(`Hint: ${hint}`));
                    if (state === 'Critical') {
                        flashRedGlow();
                    }
                    break;
                }
            }

            log(`Eco Stats: Carbon Footprint: ${carbon} kg CO2/h | Power: ${power.toFixed(2)} W | Memory: ${memory.toFixed(2)} MB | CPU Eff: ${cpuEff.toFixed(2)} ms | Battery: ${battery.toFixed(0)} %`, true);
        }

        async function toggleByte() {
            byteActive = !byteActive;
            const byteBtn = document.getElementById('byte-btn');
            const consoleDiv = document.getElementById('console');
            byteBtn.classList.toggle('active-byte', byteActive);
            consoleDiv.classList.toggle('active-byte', byteActive);
            triggerGlow();
            flashRedGlow();

            if (byteActive) {
                byteStartTime = new Date();
                log('Byte: Eco monitoring activated.', true);
                await updateEcoStats();
                connectionInterval = setInterval(() => {
                    if (window.requestIdleCallback) {
                        window.requestIdleCallback(async () => {
                            await updateEcoStats();
                        }, { timeout: 1000 });
                    } else {
                        setTimeout(async () => {
                            await updateEcoStats();
                        }, 5000);
                    }
                }, 5000);
            } else {
                clearInterval(connectionInterval);
                log('Byte: Eco monitoring deactivated.', true);

                const stopTime = new Date();
                const timeRanSeconds = Math.round((stopTime - byteStartTime) / 1000);
                const isMobile = /Mobi|Android/i.test(navigator.userAgent);

                const agent = new AdvancedAgent('Watchdog', tests);
                const results = await agent.runTests();
                const metrics = calculateMetrics(results);

                const worstTest = results.reduce((worst, result) => {
                    if (result.score < worst.score) return result;
                    return worst;
                }, results[0]);

                const tip = enhancementTips[worstTest.name](worstTest, isMobile);

                let report = `Watchdog AI BETA Eco Report\n\n`;
                report += `Monitoring Stopped: ${stopTime.toLocaleString()}\n`;
                report += `Monitoring Duration: ${Math.floor(timeRanSeconds / 60)}m ${timeRanSeconds % 60}s\n`;
                report += `Device: ${isMobile ? 'Mobile' : 'Desktop'}\n\n`;
                report += `Eco Scores (0-10):\n`;
                results.forEach(result => {
                    report += `${result.name}: ${result.score}/10 (${result.details})\n`;
                });
                report += `\nEco Score: ${metrics.normalizedScore}/100\n`;
                report += `Carbon Footprint: ${metrics.carbonFootprint} kg CO2/h\n`;
                report += `Power Usage: ${metrics.estimatedWatts.toFixed(2)} W\n`;
                report += `\nRecommendation: ${tip.message}\n`;
                report += `Next Steps:\n${tip.tips}`;
                report += `\nÂ© 2025 WebXOS - Watchdog AI BETA`;

                log(tip.message, true);

                if (navigator.clipboard) {
                    navigator.clipboard.writeText(report).then(() => log('Eco report copied', true)).catch(err => log(`Copy Error: ${err.message}`, true));
                } else {
                    const textarea = document.createElement('textarea');
                    textarea.value = report;
                    document.body.appendChild(textarea);
                    textarea.select();
                    try {
                        document.execCommand('copy');
                        log('Eco report copied (fallback)', true);
                    } catch (err) {
                        log(`Copy Error: ${err.message}`, true);
                    }
                    document.body.removeChild(textarea);
                }

                log('Monitoring data cleared.', true);
            }
        }

        async function bark() {
            debugLog('Bark button clicked');
            triggerGlow();
            flashRedGlow();
            try {
                const barkBtn = document.getElementById('bark-btn');
                barkBtn.disabled = true;
                log('Running eco-efficiency tests...', true);

                const agent = new AdvancedAgent('Watchdog', tests);
                const results = await agent.runTests();
                const metrics = calculateMetrics(results);

                const { isMobile } = agent;
                const testDate = new Date().toLocaleString();
                const worstTest = results.reduce((worst, result) => {
                    if (result.score < worst.score) return result;
                    return worst;
                }, results[0]);
                const tip = enhancementTips[worstTest.name](worstTest, isMobile);

                let certificate = `Verification of Completion\n`;
                certificate += `Test Date: ${testDate}\n`;
                certificate += `Device: ${isMobile ? 'Mobile' : 'Desktop'}\n\n`;
                certificate += `Eco Scores (0-10):\n`;
                results.forEach(result => {
                    certificate += `${result.name}: ${result.score}/10 (${result.details})\n`;
                });
                certificate += `\nEco Score: ${metrics.normalizedScore}/100\n`;
                certificate += `Carbon Footprint: ${metrics.carbonFootprint} kg CO2/h\n`;
                certificate += `Power Usage: ${metrics.estimatedWatts.toFixed(2)} W\n\n`;
                certificate += `Recommendations:\n`;
                certificate += `Best First Step: ${tip.firstStep}\n\n`;
                certificate += `Certified by WebXOS on ${testDate} for submission to green energy organizations.\n`;
                certificate += `\nÂ© 2025 WebXOS - Watchdog AI BETA`;

                if (navigator.clipboard) {
                    navigator.clipboard.writeText(certificate).then(() => log('Certificate copied', true)).catch(err => log(`Copy Error: ${err.message}`, true));
                } else {
                    const textarea = document.createElement('textarea');
                    textarea.value = certificate;
                    document.body.appendChild(textarea);
                    textarea.select();
                    try {
                        document.execCommand('copy');
                        log('Certificate copied (fallback)', true);
                    } catch (err) {
                        log(`Copy Error: ${err.message}`, true);
                    }
                    document.body.removeChild(textarea);
                }

                log(`Eco Score: ${metrics.normalizedScore}/100`, true);
                log(`Carbon Footprint: ${metrics.carbonFootprint} kg CO2/h`, true);
                log('Certificate copied for green energy analysis.', true);
                barkBtn.disabled = false;
            } catch (err) {
                log(`Bark Error: ${err.message}`, true);
                debugLog(`Bark Error: ${err.stack}`);
                barkBtn.disabled = false;
            }
        }

        const debounce = (func, wait) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        };

        document.getElementById('bark-btn').addEventListener('click', debounce(() => {
            debugLog('Bark button clicked via event listener');
            bark();
        }, 200));
        document.getElementById('byte-btn').addEventListener('click', debounce(() => {
            debugLog('Byte button clicked via event listener');
            toggleByte();
        }, 200));
        document.getElementById('reset-btn').addEventListener('click', debounce(() => {
            debugLog('Reset button clicked via event listener');
            resetConsole();
        }, 200));

        document.addEventListener('keydown', e => {
            debugLog(`Key pressed: ${e.key}`);
            if (e.key === 'Enter' || e.key === ' ') bark();
            else if (e.key === 'b' || e.key === 'B') toggleByte();
            else if (e.key === 'r' || e.key === 'R') resetConsole();
        });

        log('Watchdog AI BETA User Guide: Bark: Run tests & copy certificate | Byte: Toggle eco monitoring | Reset: Clear console', true);
    </script>
</body>
</html>
