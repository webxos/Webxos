<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Launch Sequence</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Orbitron', -apple-system, BlinkMacSystemFont, sans-serif;
    }
    body {
      background: #000;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #cosmicCanvas {
      flex: 1;
      width: 100%;
      touch-action: none;
      position: relative;
    }
    .controls {
      position: fixed;
      bottom:  marki;
      width: 100%;
      background: rgba(20, 20, 50, 0.9);
      padding: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      backdrop-filter: blur(5px);
      z-index: 10;
    }
    .control-item {
      flex: 1;
      min-width: 80px;
      text-align: center;
    }
    button {
      background: #4a90e2;
      border: none;
      padding: 10px 20px;
      color: white;
      border-radius: 20px;
      cursor: pointer;
      font-size: 16px;
      transition: transform 0.2s, background 0.2s;
    }
    button:hover {
      background: #357abd;
    }
    button.active {
      background: #ff4444;
    }
    button:active {
      transform: scale(0.95);
    }
    .prompt {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 10px;
      font-size: 14px;
      max-width: 90%;
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s;
      z-index: 5;
      border: 1px solid #00ff00;
      box-shadow: 0 0 10px #00ff00;
    }
    .prompt.active {
      opacity: 1;
    }
    .prompt select {
      background: #333;
      color: #fff;
      border: 1px solid #00ff00;
      padding: 5px;
      margin-top: 10px;
      border-radius: 5px;
    }
    .hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.4;
      z-index: 1;
    }
    .hud::before {
      content: '';
      position: absolute;
      top: 10%;
      left: 10%;
      right: 10%;
      bottom: 10%;
      border: 2px solid rgba(74, 144, 226, 0);
      border-radius: 20px;
      box-shadow: none;
    }
    .hud::after {
      content: '+';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #4a90e2;
      font-size: 24px;
    }
    .throttle-indicator {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      color: #4a90e2;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 5;
    }
    .throttle-indicator.active {
      opacity: 1;
    }
    .status-overlay {
      position: absolute;
      top: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.3);
      padding: 5px 10px;
      font-size: 12px;
      text-align: left;
      color: #fff;
      text-shadow: 0 0 2px #000;
      z-index: 5;
      pointer-events: none;
    }
    .console {
      position: absolute;
      bottom: 60px;
      width: 100%;
      height: 25%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      z-index: 5;
      padding: 5px;
    }
    .console-log {
      flex: 1;
      overflow-y: auto;
      font-size: 12px;
      color: #fff;
      text-shadow: 0 0 2px #000;
      padding: 5px;
    }
    .console-log p {
      margin: 2px 0;
    }
    .console-input {
      width: 100%;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid #4a90e2;
      color: #fff;
      padding: 5px;
      font-size: 12px;
      outline: none;
    }
    .console-input::placeholder {
      color: #aaa;
    }
    .console::-webkit-scrollbar {
      width: 8px;
    }
    .console::-webkit-scrollbar-thumb {
      background: #4a90e2;
      border-radius: 4px;
    }
    .joystick {
      position: absolute;
      bottom: 120px;
      left: 20px;
      width: 80px;
      height: 80px;
      background: rgba(74, 144, 226, 0.3);
      border-radius: 50%;
      display: none;
      touch-action: none;
      z-index: 10;
    }
    .joystick.active {
      display: block;
    }
    .joystick-knob {
      width: 40px;
      height: 40px;
      background: #4a90e2;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .fpc-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      color: #00ff00;
      font-size: 12px;
      padding: 10px;
      display: none;
      z-index: 5;
      pointer-events: none;
    }
    .fpc-overlay.active {
      display: block;
    }
    @media (max-width: 360px) {
      .controls {
        padding: 5px;
        gap: 5px;
      }
      button {
        padding: 8px 12px;
        font-size: 14px;
      }
      .prompt {
        font-size: 12px;
        padding: 10px;
      }
      .console {
        height: 30%;
      }
    }
  </style>
</head>
<body>
  <div id="cosmicCanvas">
    <div class="hud"></div>
    <div id="statusOverlay" class="status-overlay"></div>
    <div id="throttleIndicator" class="throttle-indicator"></div>
    <div id="console" class="console">
      <div id="consoleLog" class="console-log"></div>
      <input id="consoleInput" class="console-input" type="text" placeholder="Type /help for commands..." autocomplete="off">
    </div>
    <div id="joystick" class="joystick">
      <div class="joystick-knob"></div>
    </div>
    <div id="fpcOverlay" class="fpc-overlay"></div>
  </div>
  <div class="controls">
    <div class="control-item">
      <button id="throttleBtn">Full Throttle</button>
    </div>
    <div class="control-item">
      <button id="addComet">Add Drone</button>
    </div>
    <div class="control-item">
      <button id="addSystem">Add Rocket</button>
    </div>
    <div class="control-item">
      <button id="addGalaxy">Add Satellite</button>
    </div>
    <div class="control-item">
      <button id="addNode">Add Node</button>
    </div>
    <div class="control-item">
      <button id="autopilotBtn">Autopilot</button>
    </div>
    <div class="control-item">
      <button id="shootBtn">Toggle FPC</button>
    </div>
    <div class="control-item">
      <button id="resetBtn">Reset</button>
    </div>
  </div>
  <div id="prompt" class="prompt">
    <select id="agentSelect">
      <option value="">Select Agent</option>
    </select>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    window.onload = () => {
      try {
        // Scene setup
        if (!window.THREE) throw new Error('Three.js not loaded');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        const canvas = document.getElementById('cosmicCanvas');
        if (!canvas) throw new Error('Canvas element not found');
        canvas.appendChild(renderer.domElement);

        // Globe setup
        const globeGeometry = new THREE.SphereGeometry(200, 16, 16);
        const globeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
        const globe = new THREE.Mesh(globeGeometry, globeMaterial);
        scene.add(globe);

        // Camera setup
        camera.position.set(0, 0, 400);
        const frustum = new THREE.Frustum();
        const cameraMatrix = new THREE.Matrix4();
        let targetZoom = 400;
        let currentZoom = 400;

        // Shared resources
        const sharedMaterials = {
          glow: new THREE.MeshBasicMaterial({ color: 0xffffff }),
          drone: new THREE.MeshBasicMaterial({ color: 0xffff99 }),
          rocket: new THREE.MeshBasicMaterial({ color: 0x3399ff }),
          satellite: new THREE.MeshBasicMaterial({ color: 0xff33cc }),
          node: new THREE.MeshBasicMaterial({ color: 0x00ff00 }),
          line: new THREE.LineBasicMaterial({ color: 0x00ff00 })
        };
        const sharedGeometries = {
          drone: new THREE.SphereGeometry(2, 8, 8),
          rocket: new THREE.SphereGeometry(2, 8, 8),
          satellite: new THREE.SphereGeometry(2, 8, 8),
          node: new THREE.BoxGeometry(5, 5, 5)
        };

        // Entities
        let agents = [];
        let nodes = [];
        let nodeLines = [];
        let agentInstances = null;
        let agentCount = 0;
        let throttle = 0;
        let rotation = { pitch: 0, yaw: 0 };
        let rotationVelocity = { pitch: 0, yaw: 0 };
        let velocity = new THREE.Vector3(0, 0, 0);
        let lastTime = performance.now();
        let entityCount = 0;
        let autopilotActive = false;
        let currentNodeIndex = 0;
        let fpcMode = false;
        let selectedAgent = null;

        // Joystick
        let joystickActive = false;
        let joystickOrigin = { x: 0, y: 0 };
        let joystickDelta = { x: 0, y: 0 };

        // Console and status
        const statusOverlay = document.getElementById('statusOverlay');
        const consoleLog = document.getElementById('consoleLog');
        const consoleInput = document.getElementById('consoleInput');
        const prompt = document.getElementById('prompt');
        const agentSelect = document.getElementById('agentSelect');
        const joystick = document.getElementById('joystick');
        const joystickKnob = document.querySelector('.joystick-knob');
        const fpcOverlay = document.getElementById('fpcOverlay');
        const maxLogMessages = 50;
        let logMessages = [];

        function addConsoleMessage(message) {
          const timestamp = new Date().toLocaleTimeString();
          logMessages.push(`[${timestamp}] ${message}`);
          if (logMessages.length > maxLogMessages) {
            logMessages.shift();
          }
          consoleLog.innerHTML = logMessages.map(msg => `<p>${msg}</p>`).join('');
          consoleLog.scrollTop = consoleLog.scrollHeight;
        }

        function updateStatusOverlay() {
          statusOverlay.textContent = `Agents: ${entityCount} | Throttle: ${throttle} | Autopilot: ${autopilotActive ? 'On' : 'Off'} | Mode: ${fpcMode ? 'FPC' : 'Global'} | FPS: ${Math.round(1000 / (performance.now() - lastTime))}`;
        }

        // Mock WebSocket for live data
        class MockWebSocket {
          constructor() {
            this.onmessage = null;
            setInterval(() => {
              if (this.onmessage) {
                this.onmessage({
                  data: JSON.stringify({
                    type: 'agent_update',
                    agents: agents.map(agent => ({
                      id: agent.userData.id,
                      position: agent.position,
                      velocity: agent.userData.velocity,
                      role: agent.userData.role
                    }))
                  })
                });
              }
            }, 1000);
          }
          send(data) {
            addConsoleMessage(`WebSocket sent: ${data}`);
          }
        }
        const ws = new MockWebSocket();

        // Mock agent data
        const agentData = [
          { id: 'drone_1', role: 'drone', lat: 0, lon: 0, alt: 100 },
          { id: 'rocket_1', role: 'rocket', lat: 10, lon: 20, alt: 1000 },
          { id: 'satellite_1', role: 'satellite', lat: -10, lon: -20, alt: 20000 }
        ];

        function updateAgentDropdown() {
          agentSelect.innerHTML = '<option value="">Select Agent</option>';
          agentData.forEach(agent => {
            const option = document.createElement('option');
            option.value = agent.id;
            option.textContent = `${agent.id} (${agent.role})`;
            agentSelect.appendChild(option);
          });
        }

        agentSelect.addEventListener('change', e => {
          selectedAgent = agents.find(agent => agent.userData.id === e.target.value) || null;
          if (selectedAgent) {
            targetZoom = 100;
            addConsoleMessage(`Selected agent: ${e.target.value}`);
            if (fpcMode) {
              camera.position.copy(selectedAgent.position);
              camera.lookAt(globe.position);
            }
          } else {
            targetZoom = 400;
          }
        });

        // Object pools
        const agentPool = [];
        const nodePool = [];
        function getAgentFromPool(role) {
          const pool = agentPool.filter(a => a.userData.role === role);
          if (pool.length > 0) {
            const agent = pool.pop();
            agent.visible = true;
            return agent;
          }
          return new THREE.Mesh(sharedGeometries[role], sharedMaterials[role]);
        }
        function getNodeFromPool() {
          if (nodePool.length > 0) {
            const node = nodePool.pop();
            node.visible = true;
            return node;
          }
          return new THREE.Mesh(sharedGeometries.node, sharedMaterials.node);
        }

        // Add agents
        function addAgent(role) {
          const agentInfo = agentData.find(a => a.role === role);
          if (!agentInfo) return;
          const agent = getAgentFromPool(role);
          const { lat, lon, alt } = agentInfo;
          const phi = (90 - lat) * Math.PI / 180;
          const theta = lon * Math.PI / 180;
          const radius = 200 + alt / 100;
          agent.position.set(
            radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.cos(phi),
            radius * Math.sin(phi) * Math.sin(theta)
          );
          agent.userData = {
            type: 'agent',
            role,
            id: agentInfo.id,
            velocity: new THREE.Vector3(0, 0, 0.1),
            created: Date.now(),
            instanceId: agentCount
          };
          scene.add(agent);
          agents.push(agent);
          agentCount++;
          entityCount++;
          updateAgentInstances();
          updateAgentDropdown();
          showPrompt(1);
          addConsoleMessage(`${role.charAt(0).toUpperCase() + role.slice(1)} added.`);
          updateStatusOverlay();
        }

        function updateAgentInstances() {
          if (agentInstances) scene.remove(agentInstances);
          agentInstances = new THREE.InstancedMesh(sharedGeometries.drone, sharedMaterials.glow, agentCount);
          const matrix = new THREE.Matrix4();
          agents.forEach((agent, i) => {
            matrix.setPosition(agent.position);
            agentInstances.setMatrixAt(i, matrix);
          });
          scene.add(agentInstances);
        }

        function addNode() {
          const node = getNodeFromPool();
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * 100
          );
          node.position.copy(camera.position).add(forward.multiplyScalar(300)).add(offset);
          node.userData = { type: 'node', created: Date.now() };
          scene.add(node);
          nodes.push(node);
          entityCount++;

          if (nodes.length > 1) {
            const prevNode = nodes[nodes.length - 2];
            const geometry = new THREE.BufferGeometry().setFromPoints([
              prevNode.position,
              node.position
            ]);
            const line = new THREE.Line(geometry, sharedMaterials.line);
            scene.add(line);
            nodeLines.push(line);
          }

          showPrompt(4);
          addConsoleMessage('Node deployed.');
          updateStatusOverlay();
        }

        function reset() {
          agents.forEach(agent => {
            agent.visible = false;
            agentPool.push(agent);
            scene.remove(agent);
          });
          agents = [];
          nodes.forEach(node => {
            node.visible = false;
            nodePool.push(node);
            scene.remove(node);
          });
          nodes = [];
          nodeLines.forEach(line => scene.remove(line));
          nodeLines = [];
          if (agentInstances) {
            scene.remove(agentInstances);
            agentInstances = null;
          }
          agentCount = 0;
          entityCount = 0;
          autopilotActive = false;
          fpcMode = false;
          selectedAgent = null;
          updateAgentDropdown();
          const autopilotBtn = document.getElementById('autopilotBtn');
          if (autopilotBtn) autopilotBtn.classList.remove('active');
          const throttleBtn = document.getElementById('throttleBtn');
          if (throttleBtn) throttleBtn.classList.remove('active');
          const shootBtn = document.getElementById('shootBtn');
          if (shootBtn) shootBtn.classList.remove('active');
          const throttleIndicator = document.getElementById('throttleIndicator');
          if (throttleIndicator) {
            throttleIndicator.textContent = '';
            throttleIndicator.classList.remove('active');
          }
          joystick.classList.remove('active');
          fpcOverlay.classList.remove('active');
          showPrompt(6);
          addConsoleMessage('System reset.');
          updateStatusOverlay();
        }

        function toggleThrottle() {
          if (autopilotActive || fpcMode) return;
          throttle = throttle === 0 ? 150 : 0;
          const throttleBtn = document.getElementById('throttleBtn');
          if (throttleBtn) throttleBtn.classList.toggle('active', throttle > 0);
          const throttleIndicator = document.getElementById('throttleIndicator');
          if (throttleIndicator) {
            throttleIndicator.textContent = throttle > 0 ? `Thrust: ${throttle}` : '';
            throttleIndicator.classList.toggle('active', throttle > 0);
          }
          showPrompt(0);
          addConsoleMessage(throttle > 0 ? 'Throttle engaged!' : 'Throttle disengaged.');
          updateStatusOverlay();
        }

        function toggleAutopilot() {
          if (nodes.length < 2) {
            showPrompt(7);
            addConsoleMessage('Need at least 2 nodes for autopilot.');
            return;
          }
          autopilotActive = !autopilotActive;
          fpcMode = false;
          selectedAgent = null;
          const autopilotBtn = document.getElementById('autopilotBtn');
          if (autopilotBtn) autopilotBtn.classList.toggle('active', autopilotActive);
          const shootBtn = document.getElementById('shootBtn');
          if (shootBtn) shootBtn.classList.remove('active');
          if (autopilotActive) {
            throttle = 0;
            const throttleBtn = document.getElementById('throttleBtn');
            if (throttleBtn) throttleBtn.classList.remove('active');
            const throttleIndicator = document.getElementById('throttleIndicator');
            if (throttleIndicator) {
              throttleIndicator.textContent = '';
              throttleIndicator.classList.remove('active');
            }
            joystick.classList.remove('active');
            fpcOverlay.classList.remove('active');
            currentNodeIndex = 0;
            showPrompt(9);
            addConsoleMessage('Autopilot engaged! Navigating nodes.');
          } else {
            showPrompt(0);
            addConsoleMessage('Autopilot disengaged.');
          }
          updateStatusOverlay();
        }

        function toggleFPC() {
          if (autopilotActive) return;
          fpcMode = !fpcMode;
          const shootBtn = document.getElementById('shootBtn');
          if (shootBtn) shootBtn.classList.toggle('active', fpcMode);
          if (fpcMode) {
            if (!selectedAgent) {
              fpcMode = false;
              shootBtn.classList.remove('active');
              showPrompt(7);
              addConsoleMessage('Select an agent to enter FPC mode.');
              return;
            }
            throttle = 0;
            const throttleBtn = document.getElementById('throttleBtn');
            if (throttleBtn) throttleBtn.classList.remove('active');
            const throttleIndicator = document.getElementById('throttleIndicator');
            if (throttleIndicator) {
              throttleIndicator.textContent = '';
              throttleIndicator.classList.remove('active');
            }
            joystick.classList.add('active');
            fpcOverlay.classList.add('active');
            camera.position.copy(selectedAgent.position);
            camera.lookAt(globe.position);
            addConsoleMessage('FPC mode enabled.');
          } else {
            joystick.classList.remove('active');
            fpcOverlay.classList.remove('active');
            camera.position.set(0, 0, 400);
            addConsoleMessage('FPC mode disabled.');
          }
          updateStatusOverlay();
        }

        // Viewing controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let pinchDistance = 0;

        function updateRotation(deltaX, deltaY) {
          if (autopilotActive || fpcMode) return;
          rotationVelocity.yaw -= deltaX * 0.01;
          rotationVelocity.pitch -= deltaY * 0.01;
        }

        renderer.domElement.addEventListener('mousedown', e => {
          if (autopilotActive || fpcMode) return;
          isDragging = true;
          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', e => {
          if (isDragging && !autopilotActive && !fpcMode) {
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            updateRotation(deltaX, deltaY);
            previousMousePosition = { x: e.clientX, y: e.clientY };
          }
        });

        renderer.domElement.addEventListener('mouseup', () => {
          isDragging = false;
        });

        renderer.domElement.addEventListener('touchstart', e => {
          if (autopilotActive || fpcMode) return;
          e.preventDefault();
          if (e.touches.length === 1) {
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            pinchDistance = Math.sqrt(dx * dx + dy * dy);
          }
        });

        renderer.domElement.addEventListener('touchmove', e => {
          if (autopilotActive || fpcMode) return;
          e.preventDefault();
          if (e.touches.length === 1) {
            const deltaX = e.touches[0].clientX - previousMousePosition.x;
            const deltaY = e.touches[0].clientY - previousMousePosition.y;
            updateRotation(deltaX, deltaY);
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const newPinchDistance = Math.sqrt(dx * dx + dy * dy);
            targetZoom *= pinchDistance / newPinchDistance;
            targetZoom = Math.max(100, Math.min(1000, targetZoom));
            pinchDistance = newPinchDistance;
          }
        });

        renderer.domElement.addEventListener('dblclick', () => {
          if (selectedAgent) {
            targetZoom = 100;
          } else {
            targetZoom = 400;
          }
        });

        // Joystick controls
        joystick.addEventListener('touchstart', e => {
          e.preventDefault();
          joystickActive = true;
          joystickOrigin = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        joystick.addEventListener('touchmove', e => {
          if (!joystickActive) return;
          e.preventDefault();
          const x = e.touches[0].clientX - joystickOrigin.x;
          const y = e.touches[0].clientY - joystickOrigin.y;
          const maxDist = 40;
          const dist = Math.sqrt(x * x + y * y);
          if (dist > maxDist) {
            const scale = maxDist / dist;
            joystickDelta.x = x * scale;
            joystickDelta.y = y * scale;
          } else {
            joystickDelta.x = x;
            joystickDelta.y = y;
          }
          joystickKnob.style.transform = `translate(${joystickDelta.x}px, ${-joystickDelta.y}px)`;
          if (selectedAgent) {
            selectedAgent.userData.velocity.x = joystickDelta.x * 0.1;
            selectedAgent.userData.velocity.z = -joystickDelta.y * 0.1;
          }
        });

        joystick.addEventListener('touchend', () => {
          joystickActive = false;
          joystickDelta = { x: 0, y: 0 };
          joystickKnob.style.transform = 'translate(-50%, -50%)';
          if (selectedAgent) {
            selectedAgent.userData.velocity.x = 0;
            selectedAgent.userData.velocity.z = 0;
          }
        });

        // Console commands
        function handleCommand(input) {
          const cmd = input.trim().toLowerCase();
          if (!cmd.startsWith('/')) {
            addConsoleMessage('Commands must start with "/". Type /help for commands.');
            return;
          }
          const parts = cmd.slice(1).split(' ');
          const command = parts[0];
          const args = parts.slice(1);

          switch (command) {
            case 'help':
              addConsoleMessage('Commands: /add drone, /add rocket, /add satellite, /add node, /fpc, /reset, /throttle, /autopilot');
              break;
            case 'add':
              if (args[0] === 'drone') {
                addAgent('drone');
              } else if (args[0] === 'rocket') {
                addAgent('rocket');
              } else if (args[0] === 'satellite') {
                addAgent('satellite');
              } else if (args[0] === 'node') {
                addNode();
              } else {
                addConsoleMessage('Invalid add command. Use: drone, rocket, satellite, node');
              }
              break;
            case 'fpc':
              toggleFPC();
              break;
            case 'reset':
              reset();
              break;
            case 'throttle':
              if (autopilotActive || fpcMode) {
                addConsoleMessage('Cannot toggle throttle during autopilot or FPC.');
              } else {
                toggleThrottle();
              }
              break;
            case 'autopilot':
              toggleAutopilot();
              break;
            default:
              addConsoleMessage('Unknown command. Type /help for commands.');
          }
        }

        consoleInput.addEventListener('keydown', e => {
          if (e.key === 'Enter') {
            const input = consoleInput.value;
            if (input) {
              addConsoleMessage(`> ${input}`);
              handleCommand(input);
              consoleInput.value = '';
            }
          }
        });

        // Animation loop
        function animate() {
          requestAnimationFrame(animate);

          const now = performance.now();
          const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
          lastTime = now;

          if (!autopilotActive && !fpcMode) {
            rotation.pitch += rotationVelocity.pitch * deltaTime;
            rotation.yaw += rotationVelocity.yaw * deltaTime;
            rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.pitch));
            rotationVelocity.pitch *= 0.95;
            rotationVelocity.yaw *= 0.95;
            camera.quaternion.setFromEuler(new THREE.Euler(rotation.pitch, rotation.yaw, 0, 'YXZ'));

            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            velocity.copy(forward.multiplyScalar(throttle));
            camera.position.add(velocity.clone().multiplyScalar(deltaTime));
          } else if (autopilotActive) {
            if (nodes.length === 0) return;
            const targetNode = nodes[currentNodeIndex];
            const direction = targetNode.position.clone().sub(camera.position);
            const distance = direction.length();
            if (distance < 50) {
              currentNodeIndex = (currentNodeIndex + 1) % nodes.length;
              addConsoleMessage(`Reached node ${currentNodeIndex + 1}.`);
            }
            direction.normalize();
            const speed = 150;
            velocity.copy(direction.multiplyScalar(speed));
            camera.position.add(velocity.clone().multiplyScalar(deltaTime));
            camera.lookAt(targetNode.position);
          } else if (fpcMode && selectedAgent) {
            camera.position.copy(selectedAgent.position);
            camera.lookAt(globe.position);
            fpcOverlay.textContent = `Agent: ${selectedAgent.userData.id} | Role: ${selectedAgent.userData.role} | Alt: ${Math.round(selectedAgent.position.length() - 200)}`;
          }

          // Smooth zoom
          currentZoom = THREE.MathUtils.lerp(currentZoom, targetZoom, 0.1);
          camera.position.setLength(currentZoom);

          // Update agents
          cameraMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          frustum.setFromProjectionMatrix(cameraMatrix);
          const matrix = new THREE.Matrix4();
          agents.forEach((agent, i) => {
            if (!frustum.containsPoint(agent.position)) {
              agent.visible = false;
              return;
            }
            agent.visible = true;
            agent.position.add(agent.userData.velocity.clone().multiplyScalar(deltaTime));
            matrix.setPosition(agent.position);
            agentInstances.setMatrixAt(i, matrix);
          });
          if (agentInstances) agentInstances.instanceMatrix.needsUpdate = true;

          // Update node lines
          nodeLines.forEach((line, i) => {
            if (i < nodes.length - 1) {
              const geometry = new THREE.BufferGeometry().setFromPoints([
                nodes[i].position,
                nodes[i + 1].position
              ]);
              line.geometry.dispose();
              line.geometry = geometry;
            }
          });

          renderer.render(scene, camera);
        }

        // Controls
        try {
          const throttleBtn = document.getElementById('throttleBtn');
          const addCometBtn = document.getElementById('addComet');
          const addSystemBtn = document.getElementById('addSystem');
          const addGalaxyBtn = document.getElementById('addGalaxy');
          const addNodeBtn = document.getElementById('addNode');
          const autopilotBtn = document.getElementById('autopilotBtn');
          const shootBtn = document.getElementById('shootBtn');
          const resetBtn = document.getElementById('resetBtn');

          if (!throttleBtn || !addCometBtn || !addSystemBtn || !addGalaxyBtn || !addNodeBtn || !autopilotBtn || !shootBtn || !resetBtn) {
            throw new Error('One or more control elements not found');
          }

          throttleBtn.addEventListener('click', toggleThrottle);
          addCometBtn.addEventListener('click', () => addAgent('drone'));
          addSystemBtn.addEventListener('click', () => addAgent('rocket'));
          addGalaxyBtn.addEventListener('click', () => addAgent('satellite'));
          addNodeBtn.addEventListener('click', addNode);
          autopilotBtn.addEventListener('click', toggleAutopilot);
          shootBtn.addEventListener('click', toggleFPC);
          resetBtn.addEventListener('click', reset);

          const prompts = [
            "Throttle engaged!",
            "Agent added.",
            "Rocket added.",
            "Satellite added.",
            "Node deployed.",
            "FPC mode toggled.",
            "System reset.",
            "Select an agent for FPC mode!",
            "Warning: Too many agents may slow performance!",
            "Autopilot engaged!"
          ];

          function showPrompt(index) {
            prompt.textContent = prompts[index];
            prompt.classList.add('active');
            setTimeout(() => prompt.classList.remove('active'), 2000);
          }
        } catch (e) {
          console.error('Control setup error:', e);
          addConsoleMessage(`Error: ${e.message}`);
        }

        // Initialize
        try {
          addConsoleMessage('Launch Sequence initialized. Type /help for commands.');
          updateStatusOverlay();
          updateAgentDropdown();
          animate();
        } catch (e) {
          console.error('Initialization error:', e);
          addConsoleMessage(`Error: ${e.message}`);
        }

        // Resize
        window.addEventListener('resize', () => {
          try {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          } catch (e) {
            console.error('Resize error:', e);
            addConsoleMessage(`Error: ${e.message}`);
          }
        });
      } catch (e) {
        console.error('Main script error:', e);
        addConsoleMessage(`Error: ${e.message}`);
      }
    };
  </script>
</body>
</html>
