<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sacred</title>
    <style>
        body { background: #000; color: #00FF00; font-family: 'Courier New', monospace; margin: 0; padding: 10px; overflow: hidden }
        h1.glow-text { font-size: 18px; margin: 0; padding: 0; text-shadow: 0 0 20px #00FF00, 0 0 30px #00FF00, 0 0 40px #00FF00; animation: glow 1s infinite alternate }
        @keyframes glow { from { text-shadow: 0 0 10px #00FF00, 0 0 20px #00FF00, 0 0 30px #00FF00 } to { text-shadow: 0 0 20px #00FF00, 0 0 30px #00FF00, 0 0 40px #00FF00 } }
        .symbol-container { position: relative; width: 100%; height: 70vh; margin: 10px 0; overflow: hidden }
        .symbol { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; border: 1px solid #00FF00; border-radius: 5px; box-shadow: 0 0 20px #00FF00, 0 0 30px #00FF00, 0 0 40px #00FF00; background: #000 }
        .hologram {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            transform-style: preserve-3d;
            animation: rotateHologram 30s infinite linear;
        }
        .grid-square {
            position: absolute;
            background: rgba(0,255,0,0.6);
            border: 1px solid #00FF00;
            box-shadow: 0 0 5px #00FF00;
            animation: pulseSquare 4s infinite;
        }
        .draw-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .draw-canvas.active {
            pointer-events: auto;
        }
        button { display: inline-block; margin: 2px; padding: 5px 10px; font-size: 12px; background: #000; color: #00FF00; border: 1px solid #00FF00; border-radius: 3px; transition: all 0.3s ease; box-shadow: 0 0 15px #00FF00, 0 0 25px #00FF00 }
        button:hover { background: #00FF00; color: #000; box-shadow: 0 0 25px #00FF00, 0 0 35px #00FF00, 0 0 45px #00FF00 }
        .button-container { display: flex; flex-wrap: wrap; justify-content: center }
        .copyright { position: fixed; bottom: 10px; width: 100%; font-size: 10px; color: #FFFFFF; text-shadow: 0 0 15px #FFFFFF }
        .confirmation { font-family: 'Impact', sans-serif; position: fixed; bottom: 25px; width: 100%; text-align: center; color: #00FF00; text-shadow: 0 0 15px #00FF00, 0 0 25px #00FF00; font-size: 14px; display: block }
        .wallet-popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #000; border: 2px solid #00FF00; padding: 20px; box-shadow: 0 0 20px #00FF00; z-index: 1000; color: #00FF00; font-family: 'Courier New', monospace }
        .wallet-popup input { background: #000; color: #00FF00; border: 1px solid #00FF00; padding: 5px; margin: 5px; font-family: 'Courier New', monospace; width: 250px }
        .wallet-popup button { margin: 5px }
        .wallet-popup canvas { border: 1px solid #00FF00; margin-top: 10px; width: 200px; height: 200px }
        .close-btn { position: absolute; top: 10px; right: 10px; cursor: pointer; color: #00FF00 }
        @media (max-width: 600px) {
            h1.glow-text { font-size: 16px; }
            button { font-size: 10px; padding: 4px 8px; }
            .confirmation { font-size: 12px; }
            .copyright { font-size: 8px; }
            .wallet-popup { padding: 15px; width: 90%; }
            .wallet-popup input { width: 100%; font-size: 10px; }
            .wallet-popup canvas { width: 150px; height: 150px; }
        }
        @keyframes rotateHologram {
            0% { transform: rotateY(0deg) rotateX(15deg); }
            100% { transform: rotateY(360deg) rotateX(15deg); }
        }
        @keyframes pulseSquare {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <h1 class="glow-text">Sacred AI (beta)</h1>
    <div class="symbol-container">
        <div id="dynamic-shape" class="symbol"></div>
        <canvas id="draw-canvas" class="draw-canvas"></canvas>
    </div>
    <div class="button-container">
        <button onclick="generateShape()">Generate Shape</button>
        <button id="autoGenerateBtn" onclick="toggleAutoGenerate()">Auto Generate: Off</button>
        <button onclick="zoomIn()">Zoom In</button>
        <button onclick="zoomOut()">Zoom Out</button>
        <button onclick="rotateShape()">Rotate</button>
        <button onclick="changeUIColor()">Change UI Color</button>
        <button onclick="toggleDraw()">Draw</button>
        <button onclick="clearDrawing()">Clear Drawing</button>
        <button onclick="toggle3DMode()">3D Mode</button>
        <button onclick="openWallet()">Wallet</button>
    </div>
    <div class="confirmation" id="confirmationText"></div>
    <div class="copyright">© 2025 WebXOS</div>
    <div class="wallet-popup" id="walletPopup">
        <span class="close-btn" onclick="closeWallet()">X</span>
        <h2>Wallet</h2>
        <input type="text" id="nftSerialInput" placeholder="Enter Serial (e.g., HOLO-000001-ABC)">
        <input type="text" id="nftCodeInput" placeholder="Enter Code (e.g., Ω-CODE: ---111---)">
        <button onclick="loadNFTImage()">Load Image</button>
        <button onclick="copyCurrentNFTCode()">Copy Current NFT Serial & Code</button>
        <canvas id="walletCanvas"></canvas>
    </div>
    <script>
        // UI Colors
        const uiColors = ['#00FF00', '#FF00FF', '#FF0000', '#00FFFF', '#FFFF00', '#FFFFFF', '#AAAAAA'];
        let currentColorIndex = 0;
        let autoGenerateInterval = null;
        let isAutoGenerating = false;
        let currentSerial = '';
        let currentCode = '';
        let currentScale = 1;
        let currentRotation = 0;
        let currentShapePattern = null;
        let isDrawing = false;
        let strokes = [];
        let currentStroke = [];
        let serialCounter = 1;
        let serialMap = new Map();
        let is3DMode = false;
        let current3DGrid = null;

        // Drawing Canvas Setup
        const drawCanvas = document.getElementById('draw-canvas');
        const drawCtx = drawCanvas.getContext('2d');
        let canvasWidth, canvasHeight;

        function resizeCanvas() {
            try {
                const container = document.querySelector('.symbol-container');
                canvasWidth = container.offsetWidth;
                canvasHeight = container.offsetHeight;
                drawCanvas.width = canvasWidth;
                drawCanvas.height = canvasHeight;
                drawCtx.lineWidth = 3;
                drawCtx.lineCap = 'round';
                drawCtx.lineJoin = 'round';
                drawCtx.strokeStyle = uiColors[currentColorIndex];
                redrawStrokes();
            } catch (error) {
                showConfirmation(`ERROR: Canvas resize failed - ${error.message}`);
            }
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Exoskeleton AI Serial/Code Functions
        function hashCode(str, salt = '') {
            try {
                let hash = 2166136261;
                const saltedStr = str + salt;
                for (let i = 0; i < saltedStr.length; i++) {
                    hash ^= saltedStr.charCodeAt(i);
                    hash *= 16777619;
                }
                return Math.abs(hash);
            } catch (error) {
                showConfirmation(`ERROR: Hash code failed - ${error.message}`);
                return 0;
            }
        }

        function seededRandom(seed) {
            try {
                let x = Math.sin(seed++) * 10000;
                return x - Math.floor(x);
            } catch (error) {
                showConfirmation(`ERROR: Seeded random failed - ${error.message}`);
                return Math.random();
            }
        }

        function saveState() {
            try {
                localStorage.setItem('sacredAISerialMap', JSON.stringify([...serialMap]));
                localStorage.setItem('sacredAISerialCounter', serialCounter);
            } catch (error) {
                showConfirmation(`ERROR: Failed to save state - ${error.message}`);
            }
        }

        function loadState() {
            try {
                const savedMap = localStorage.getItem('sacredAISerialMap');
                const savedCounter = localStorage.getItem('sacredAISerialCounter');
                if (savedMap) {
                    serialMap = new Map(JSON.parse(savedMap));
                }
                serialCounter = parseInt(savedCounter) || 1;
                if (serialCounter < 1 || serialCounter > 999999) {
                    serialCounter = 1;
                }
                const maxSerial = Math.max(...Array.from(serialMap.keys())
                    .filter(s => s.startsWith('HOLO-'))
                    .map(s => parseInt(s.split('-')[1]) || 0), 0);
                if (maxSerial >= serialCounter) {
                    serialCounter = maxSerial + 1;
                }
            } catch (error) {
                showConfirmation(`ERROR: Failed to load state - ${error.message}`);
            }
        }

        function compressDatabase(entries) {
            try {
                return JSON.stringify(entries);
            } catch (error) {
                showConfirmation(`ERROR: Compression failed - ${error.message}`);
                return '';
            }
        }

        function decompressDatabase(compressed, seed) {
            try {
                return JSON.parse(compressed);
            } catch (error) {
                showConfirmation(`ERROR: Decompression failed - ${error.message}`);
                return [];
            }
        }

        function encodeDatabase(entries, serial) {
            try {
                const compressed = compressDatabase(entries);
                const seed = hashCode(serial);
                let encoded = '';
                for (let i = 0; i < compressed.length; i++) {
                    const charCode = compressed.charCodeAt(i);
                    const shift = (seed >> (i % 32)) & 0xFF;
                    encoded += String.fromCharCode((charCode + shift) % 256);
                }
                return btoa(encoded);
            } catch (error) {
                showConfirmation(`ERROR: Encoding failed - ${error.message}`);
                return '';
            }
        }

        function decodeDatabase(encoded, serial) {
            try {
                const seed = hashCode(serial);
                const decoded = atob(encoded);
                let decompressed = '';
                for (let i = 0; i < decoded.length; i++) {
                    const charCode = decoded.charCodeAt(i);
                    const shift = (seed >> (i % 32)) & 0xFF;
                    decompressed += String.fromCharCode((charCode - shift + 256) % 256);
                }
                return decompressDatabase(decompressed, seed);
            } catch (error) {
                showConfirmation(`ERROR: Decoding failed - ${error.message}`);
                return [];
            }
        }

        function generateRandomSuffix() {
            try {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let suffix = '';
                for (let i = 0; i < 3; i++) {
                    suffix += chars.charAt(Math.floor(seededRandom(hashCode(suffix + i)) * chars.length));
                }
                return suffix.toUpperCase();
            } catch (error) {
                showConfirmation(`ERROR: Suffix generation failed - ${error.message}`);
                return 'XYZ';
            }
        }

        function generateSerialNumber(code) {
            try {
                let serial;
                let attempts = 0;
                const maxAttempts = 1000;
                do {
                    if (serialCounter > 999999) {
                        serialCounter = 1;
                    }
                    const paddedNumber = String(serialCounter++).padStart(6, '0');
                    const suffix = generateRandomSuffix();
                    serial = `HOLO-${paddedNumber}-${suffix}`;
                    attempts++;
                    if (attempts > maxAttempts) {
                        showConfirmation('ERROR: Failed to generate unique serial');
                        return null;
                    }
                } while (serialMap.has(serial));
                serialMap.set(serial, { code, encryptedDatabase: '', strokes: [] });
                saveState();
                return serial;
            } catch (error) {
                showConfirmation(`ERROR: Serial generation failed - ${error.message}`);
                return null;
            }
        }

        function generateCrypticCode(serial) {
            try {
                const glyphs = 'ΔΩΨΘΣΦΩΓΛΞΠΩ0123456789#@&%*+-=<>';
                let code = '';
                const seedValue = hashCode(serial + 'CODE');
                for (let i = 0; i < 9; i++) {
                    code += glyphs.charAt(Math.floor(seededRandom(seedValue + i) * glyphs.length));
                }
                return `Ω-CODE: ${code}`;
            } catch (error) {
                showConfirmation(`ERROR: Code generation failed - ${error.message}`);
                return 'Ω-CODE: ERRORCODE';
            }
        }

        // Shape Generation (2D)
        function generateShape() {
            try {
                const shapeElement = document.getElementById('dynamic-shape');
                shapeElement.innerHTML = ''; // Clear any 3D grid
                is3DMode = false;
                const currentColor = uiColors[currentColorIndex];
                const patterns = [
                    () => `repeating-radial-gradient(circle, ${currentColor} ${rand(2,15)}px, #000 ${rand(2,15)}px, #000 ${rand(5,20)}px, ${currentColor} ${rand(5,20)}px)`,
                    () => `repeating-linear-gradient(${rand(0,360)}deg, transparent ${rand(5,15)}px, ${currentColor} ${rand(5,15)}px, ${currentColor} ${rand(10,25)}px, transparent ${rand(10,25)}px)`,
                    () => `repeating-radial-gradient(${currentColor} ${rand(5,20)}px, transparent ${rand(5,20)}px, #000 ${rand(10,30)}px)`,
                    () => `repeating-linear-gradient(${rand(0,360)}deg, ${currentColor} ${rand(5,20)}px, transparent ${rand(5,20)}px, ${currentColor} ${rand(10,30)}px)`,
                    () => `repeating-linear-gradient(${rand(0,360)}deg, transparent ${rand(2,10)}px, ${currentColor} ${rand(2,10)}px), repeating-linear-gradient(${rand(0,360)}deg, transparent ${rand(2,10)}px, ${currentColor} ${rand(2,10)}px)`,
                    () => `repeating-radial-gradient(${currentColor} ${rand(2,15)}px, transparent ${rand(2,15)}px, #000 ${rand(5,20)}px)`,
                    () => `repeating-linear-gradient(${rand(0,360)}deg, ${currentColor} ${rand(2,15)}px, transparent ${rand(2,15)}px, #000 ${rand(5,20)}px)`
                ];
                const patternIndex = Math.floor(Math.random() * patterns.length);
                currentShapePattern = { index: patternIndex, color: currentColor, randValues: [] };
                const patternFunc = patterns[patternIndex];
                const originalRand = Math.random;
                Math.random = () => {
                    const val = Math.random();
                    currentShapePattern.randValues.push(val);
                    return val;
                };
                shapeElement.style.background = patternFunc();
                Math.random = originalRand;
                currentScale = rand(0.8, 1.2);
                currentRotation = rand(0, 360);
                current3DGrid = null;
                updateTransform(shapeElement);
                if (!isAutoGenerating) {
                    generateNFT();
                }
            } catch (error) {
                showConfirmation(`ERROR: Shape generation failed - ${error.message}`);
            }
        }

        // 3D Grid Generation
        function generate3DGrid() {
            try {
                const shapeElement = document.getElementById('dynamic-shape');
                shapeElement.style.background = 'none';
                shapeElement.innerHTML = '<div class="hologram" id="hologram"></div>';
                const hologram = document.getElementById('hologram');
                const hash = hashCode(currentSerial + JSON.stringify(strokes));
                let seedValue = hash;
                const rand = (min, max) => {
                    seedValue = hashCode(String(seedValue));
                    return min + (seedValue % (max - min + 1));
                };
                const randFloat = (min, max) => {
                    seedValue = hashCode(String(seedValue));
                    return min + ((seedValue % 10000) / 10000) * (max - min);
                };
                const squareCount = rand(20, 50);
                current3DGrid = { squares: [], color: uiColors[currentColorIndex], seed: hash };
                for (let i = 0; i < squareCount; i++) {
                    const square = document.createElement('div');
                    square.className = 'grid-square';
                    const size = randFloat(30, 80);
                    const left = randFloat(0, canvasWidth - size);
                    const top = randFloat(0, canvasHeight - size);
                    const z = randFloat(-100, 100);
                    const rotateX = randFloat(-30, 30);
                    const rotateY = randFloat(-30, 30);
                    square.style.width = `${size}px`;
                    square.style.height = `${size}px`;
                    square.style.left = `${left}px`;
                    square.style.top = `${top}px`;
                    square.style.transform = `translateZ(${z}px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
                    square.style.opacity = randFloat(0.4, 0.8);
                    square.style.borderColor = uiColors[currentColorIndex];
                    square.style.boxShadow = `0 0 5px ${uiColors[currentColorIndex]}`;
                    current3DGrid.squares.push({ size, left, top, z, rotateX, rotateY, opacity: square.style.opacity });
                    hologram.appendChild(square);
                }
                currentScale = rand(0.8, 1.2);
                currentRotation = rand(0, 360);
                updateTransform(shapeElement);
                if (!isAutoGenerating) {
                    generateNFT();
                }
            } catch (error) {
                showConfirmation(`ERROR: 3D grid generation failed - ${error.message}`);
            }
        }

        function regenerate3DGrid(gridData, scale, rotation, strokesData) {
            try {
                const shapeElement = document.getElementById('dynamic-shape');
                shapeElement.style.background = 'none';
                shapeElement.innerHTML = '<div class="hologram" id="hologram"></div>';
                const hologram = document.getElementById('hologram');
                current3DGrid = gridData;
                gridData.squares.forEach(squareData => {
                    const square = document.createElement('div');
                    square.className = 'grid-square';
                    square.style.width = `${squareData.size}px`;
                    square.style.height = `${squareData.size}px`;
                    square.style.left = `${squareData.left}px`;
                    square.style.top = `${squareData.top}px`;
                    square.style.transform = `translateZ(${squareData.z}px) rotateX(${squareData.rotateX}deg) rotateY(${squareData.rotateY}deg)`;
                    square.style.opacity = squareData.opacity;
                    square.style.borderColor = gridData.color;
                    square.style.boxShadow = `0 0 5px ${gridData.color}`;
                    hologram.appendChild(square);
                });
                currentScale = scale;
                currentRotation = rotation;
                updateTransform(shapeElement);
                strokes = strokesData || [];
                redrawStrokes();
            } catch (error) {
                showConfirmation(`ERROR: 3D grid regeneration failed - ${error.message}`);
            }
        }

        function toggle3DMode() {
            try {
                is3DMode = !is3DMode;
                const modeBtn = document.querySelector('button[onclick="toggle3DMode()"]');
                modeBtn.innerText = is3DMode ? '3D Mode: On' : '3D Mode';
                if (is3DMode) {
                    generate3DGrid();
                } else {
                    generateShape();
                }
            } catch (error) {
                showConfirmation(`ERROR: Toggling 3D mode failed - ${error.message}`);
            }
        }

        function regenerateShape(patternData, scale, rotation, strokesData) {
            try {
                const shapeElement = document.getElementById('dynamic-shape');
                shapeElement.innerHTML = '';
                const patterns = [
                    () => `repeating-radial-gradient(circle, ${patternData.color} ${patternData.randValues[0]*13+2}px, #000 ${patternData.randValues[1]*13+2}px, #000 ${patternData.randValues[2]*15+5}px, ${patternData.color} ${patternData.randValues[3]*15+5}px)`,
                    () => `repeating-linear-gradient(${patternData.randValues[0]*360}deg, transparent ${patternData.randValues[1]*10+5}px, ${patternData.color} ${patternData.randValues[2]*10+5}px, ${patternData.color} ${patternData.randValues[3]*15+10}px, transparent ${patternData.randValues[4]*15+10}px)`,
                    () => `repeating-radial-gradient(${patternData.color} ${patternData.randValues[0]*15+5}px, transparent ${patternData.randValues[1]*15+5}px, #000 ${patternData.randValues[2]*20+10}px)`,
                    () => `repeating-linear-gradient(${patternData.randValues[0]*360}deg, ${patternData.color} ${patternData.randValues[1]*15+5}px, transparent ${patternData.randValues[2]*15+5}px, ${patternData.color} ${patternData.randValues[3]*20+10}px)`,
                    () => `repeating-linear-gradient(${patternData.randValues[0]*360}deg, transparent ${patternData.randValues[1]*8+2}px, ${patternData.color} ${patternData.randValues[2]*8+2}px), repeating-linear-gradient(${patternData.randValues[3]*360}deg, transparent ${patternData.randValues[4]*8+2}px, ${patternData.color} ${patternData.randValues[5]*8+2}px)`,
                    () => `repeating-radial-gradient(${patternData.color} ${patternData.randValues[0]*13+2}px, transparent ${patternData.randValues[1]*13+2}px, #000 ${patternData.randValues[2]*15+5}px)`,
                    () => `repeating-linear-gradient(${patternData.randValues[0]*360}deg, ${patternData.color} ${patternData.randValues[1]*13+2}px, transparent ${patternData.randValues[2]*13+2}px, #000 ${patternData.randValues[3]*15+5}px)`
                ];
                shapeElement.style.background = patterns[patternData.index]();
                currentShapePattern = patternData;
                currentScale = scale;
                currentRotation = rotation;
                updateTransform(shapeElement);
                strokes = strokesData || [];
                redrawStrokes();
            } catch (error) {
                showConfirmation(`ERROR: Shape regeneration failed - ${error.message}`);
            }
        }

        function generateNFT() {
            try {
                const shapeData = {
                    is3DMode,
                    pattern: is3DMode ? null : currentShapePattern,
                    grid: is3DMode ? current3DGrid : null,
                    scale: currentScale,
                    rotation: currentRotation,
                    colorIndex: currentColorIndex,
                    strokes
                };
                let newCode;
                do {
                    newCode = generateCrypticCode('NFT' + serialCounter + JSON.stringify(shapeData));
                } while (Array.from(serialMap.values()).some(data => data.code === newCode));
                const serial = generateSerialNumber(newCode);
                if (!serial) return;
                const encodedData = encodeDatabase([shapeData], serial);
                if (!encodedData) return;
                serialMap.set(serial, { code: newCode, encryptedDatabase: encodedData, strokes });
                saveState();
                currentSerial = serial;
                currentCode = newCode;
                if (!isAutoGenerating) {
                    showConfirmation(`New Shape Generated! ${serial} | ${newCode}`);
                    navigator.clipboard.writeText(`${serial}\n${newCode}`).then(() => {
                        showConfirmation('Serial and code copied to clipboard');
                    }).catch(() => {
                        showConfirmation('ERROR: Failed to copy serial and code');
                    });
                }
            } catch (error) {
                showConfirmation(`ERROR: NFT generation failed - ${error.message}`);
            }
        }

        function updateTransform(shapeElement) {
            try {
                shapeElement.style.transform = `rotate(${currentRotation}deg) scale(${currentScale})`;
                drawCanvas.style.transform = `rotate(${currentRotation}deg) scale(${currentScale})`;
            } catch (error) {
                showConfirmation(`ERROR: Transform update failed - ${error.message}`);
            }
        }

        function zoomIn() {
            try {
                const shapeElement = document.getElementById('dynamic-shape');
                currentScale = Math.min(currentScale + 0.1, 2.0);
                updateTransform(shapeElement);
            } catch (error) {
                showConfirmation(`ERROR: Zoom in failed - ${error.message}`);
            }
        }

        function zoomOut() {
            try {
                const shapeElement = document.getElementById('dynamic-shape');
                currentScale = Math.max(currentScale - 0.1, 0.5);
                updateTransform(shapeElement);
            } catch (error) {
                showConfirmation(`ERROR: Zoom out failed - ${error.message}`);
            }
        }

        function rotateShape() {
            try {
                const shapeElement = document.getElementById('dynamic-shape');
                currentRotation = (currentRotation + 90) % 360;
                updateTransform(shapeElement);
            } catch (error) {
                showConfirmation(`ERROR: Rotate failed - ${error.message}`);
            }
        }

        function rand(min, max) {
            return Math.random() * (max - min) + min;
        }

        function showConfirmation(message) {
            try {
                const confirmation = document.getElementById('confirmationText');
                confirmation.innerText = message;
                confirmation.style.display = 'block';
                setTimeout(() => { confirmation.style.display = 'none'; }, 3000);
            } catch (error) {
                console.error(`Confirmation display failed: ${error.message}`);
            }
        }

        function toggleAutoGenerate() {
            try {
                const autoBtn = document.getElementById('autoGenerateBtn');
                isAutoGenerating = !isAutoGenerating;
                if (isAutoGenerating) {
                    autoBtn.innerText = 'Auto Generate: On';
                    autoGenerateInterval = setInterval(() => {
                        if (is3DMode) generate3DGrid();
                        else generateShape();
                    }, 300);
                } else {
                    autoBtn.innerText = 'Auto Generate: Off';
                    if (autoGenerateInterval) {
                        clearInterval(autoGenerateInterval);
                        autoGenerateInterval = null;
                    }
                }
            } catch (error) {
                showConfirmation(`ERROR: Auto generate toggle failed - ${error.message}`);
            }
        }

        function changeUIColor() {
            try {
                currentColorIndex = (currentColorIndex + 1) % uiColors.length;
                const newColor = uiColors[currentColorIndex];
                document.body.style.color = newColor;
                const header = document.querySelector('h1.glow-text');
                header.style.textShadow = `0 0 20px ${newColor}, 0 0 30px ${newColor}, 0 0 40px ${newColor}`;
                document.querySelector('style').innerHTML = document.querySelector('style').innerHTML.replace(
                    /@keyframes glow{from{text-shadow:0 0 10px #[\da-fA-F]{3,6}.*?}to{text-shadow:0 0 20px #[\da-fA-F]{3,6}.*?}}/,
                    `@keyframes glow{from{text-shadow:0 0 10px ${newColor}, 0 0 20px ${newColor}, 0 0 30px ${newColor}}to{text-shadow:0 0 20px ${newColor}, 0 0 30px ${newColor}, 0 0 40px ${newColor}}}`
                );
                const shape = document.getElementById('dynamic-shape');
                shape.style.borderColor = newColor;
                shape.style.boxShadow = `0 0 20px ${newColor}, 0 0 30px ${newColor}, 0 0 40px ${newColor}`;
                const buttons = document.querySelectorAll('button');
                buttons.forEach(btn => {
                    btn.style.color = newColor;
                    btn.style.borderColor = newColor;
                    btn.style.boxShadow = `0 0 15px ${newColor}, 0 0 25px ${newColor}`;
                    btn.onmouseover = () => {
                        btn.style.background = newColor;
                        btn.style.color = '#000';
                        btn.style.boxShadow = `0 0 25px ${newColor}, 0 0 35px ${newColor}, 0 0 45px ${newColor}`;
                    };
                    btn.onmouseout = () => {
                        btn.style.background = '#000';
                        btn.style.color = newColor;
                        btn.style.boxShadow = `0 0 15px ${newColor}, 0 0 25px ${newColor}`;
                    };
                });
                const confirmation = document.getElementById('confirmationText');
                confirmation.style.color = newColor;
                confirmation.style.textShadow = `0 0 15px ${newColor}, 0 0 25px ${newColor}`;
                document.querySelector('.copyright').style.color = '#FFFFFF';
                document.querySelector('.copyright').style.textShadow = `0 0 15px #FFFFFF`;
                drawCtx.strokeStyle = newColor;
                if (is3DMode && current3DGrid) {
                    current3DGrid.color = newColor;
                    document.querySelectorAll('.grid-square').forEach(square => {
                        square.style.borderColor = newColor;
                        square.style.boxShadow = `0 0 5px ${newColor}`;
                    });
                }
                redrawStrokes();
            } catch (error) {
                showConfirmation(`ERROR: Color change failed - ${error.message}`);
            }
        }

        // Drawing Functions
        function startDrawing(e) {
            try {
                if (!isDrawing) return;
                e.preventDefault();
                const rect = drawCanvas.getBoundingClientRect();
                const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
                const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
                currentStroke = [{ x, y }];
                drawCtx.beginPath();
                drawCtx.moveTo(x, y);
            } catch (error) {
                showConfirmation(`ERROR: Drawing start failed - ${error.message}`);
            }
        }

        function stopDrawing() {
            try {
                if (isDrawing && currentStroke.length > 1) {
                    strokes.push([...currentStroke]);
                    currentStroke = [];
                    drawCtx.beginPath();
                    if (!isAutoGenerating) {
                        generateNFT();
                    }
                }
            } catch (error) {
                showConfirmation(`ERROR: Drawing stop failed - ${error.message}`);
            }
        }

        function draw(e) {
            try {
                if (!isDrawing) return;
                e.preventDefault();
                const rect = drawCanvas.getBoundingClientRect();
                const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
                const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
                currentStroke.push({ x, y });
                drawCtx.lineTo(x, y);
                drawCtx.stroke();
                drawCtx.beginPath();
                drawCtx.moveTo(x, y);
            } catch (error) {
                showConfirmation(`ERROR: Drawing failed - ${error.message}`);
            }
        }

        function redrawStrokes() {
            try {
                drawCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                drawCtx.strokeStyle = uiColors[currentColorIndex];
                strokes.forEach(stroke => {
                    if (stroke.length < 2) return;
                    drawCtx.beginPath();
                    stroke.forEach((point, idx) => {
                        if (idx === 0) drawCtx.moveTo(point.x, point.y);
                        else drawCtx.lineTo(point.x, point.y);
                    });
                    drawCtx.stroke();
                });
            } catch (error) {
                showConfirmation(`ERROR: Redraw strokes failed - ${error.message}`);
            }
        }

        drawCanvas.addEventListener('mousedown', startDrawing);
        drawCanvas.addEventListener('mouseup', stopDrawing);
        drawCanvas.addEventListener('mousemove', draw);
        drawCanvas.addEventListener('touchstart', startDrawing);
        drawCanvas.addEventListener('touchend', stopDrawing);
        drawCanvas.addEventListener('touchmove', draw);
        drawCanvas.addEventListener('mouseleave', stopDrawing);

        function toggleDraw() {
            try {
                isDrawing = !isDrawing;
                drawCanvas.classList.toggle('active', isDrawing);
                const drawBtn = document.querySelector('button[onclick="toggleDraw()"]');
                drawBtn.innerText = isDrawing ? 'Draw: On' : 'Draw';
            } catch (error) {
                showConfirmation(`ERROR: Draw toggle failed - ${error.message}`);
            }
        }

        function clearDrawing() {
            try {
                strokes = [];
                currentStroke = [];
                drawCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                if (!isAutoGenerating) {
                    generateNFT();
                }
            } catch (error) {
                showConfirmation(`ERROR: Clear drawing failed - ${error.message}`);
            }
        }

        // Wallet Functions
        function openWallet() {
            try {
                document.getElementById('walletPopup').style.display = 'block';
                const walletCanvas = document.getElementById('walletCanvas');
                walletCanvas.width = 200;
                walletCanvas.height = 200;
            } catch (error) {
                showConfirmation(`ERROR: Open wallet failed - ${error.message}`);
            }
        }

        function closeWallet() {
            try {
                document.getElementById('walletPopup').style.display = 'none';
            } catch (error) {
                showConfirmation(`ERROR: Close wallet failed - ${error.message}`);
            }
        }

        function copyCurrentNFTCode() {
            try {
                if (currentSerial && currentCode) {
                    navigator.clipboard.writeText(`${currentSerial}\n${currentCode}`).then(() => {
                        showConfirmation('Serial and code copied to clipboard');
                    }).catch(() => {
                        showConfirmation('ERROR: Failed to copy serial and code');
                    });
                } else {
                    showConfirmation('ERROR: No serial or code to copy');
                }
            } catch (error) {
                showConfirmation(`ERROR: Copy NFT code failed - ${error.message}`);
            }
        }

        function loadNFTImage() {
            try {
                const serialInput = document.getElementById('nftSerialInput').value.trim();
                const codeInput = document.getElementById('nftCodeInput').value.trim();
                if (!serialInput || !codeInput) {
                    showConfirmation('ERROR: Serial and code required');
                    return;
                }
                const serialMatch = serialInput.match(/^HOLO-\d{6}-[A-Z0-9]{3}$/);
                const validSerial = serialMatch ? serialMatch[0] : null;
                if (!validSerial) {
                    showConfirmation('ERROR: Invalid serial format. Use HOLO-XXXXXX-XXX');
                    return;
                }
                const codeMatch = codeInput.match(/^Ω-CODE: [ΔΩΨΘΣΦΩΓΛΞΠΩ0123456789#@&%*+=\-<>]{9}$/);
                const validCode = codeMatch ? codeMatch[0] : null;
                if (!validCode) {
                    showConfirmation('ERROR: Invalid code format. Use Ω-CODE: followed by 9 glyphs');
                    return;
                }
                if (serialMap.has(validSerial)) {
                    const { code, encryptedDatabase, strokes: storedStrokes } = serialMap.get(validSerial);
                    if (code !== validCode) {
                        showConfirmation(`ERROR: Invalid code for serial ${validSerial}`);
                        return;
                    }
                    const shapeData = decodeDatabase(encryptedDatabase, validSerial)[0];
                    if (!shapeData) {
                        showConfirmation('ERROR: Failed to decode shape data');
                        return;
                    }
                    currentSerial = validSerial;
                    currentCode = validCode;
                    currentColorIndex = shapeData.colorIndex;
                    changeUIColor();
                    is3DMode = shapeData.is3DMode;
                    if (is3DMode) {
                        regenerate3DGrid(shapeData.grid, shapeData.scale, shapeData.rotation, shapeData.strokes);
                    } else {
                        regenerateShape(shapeData.pattern, shapeData.scale, shapeData.rotation, shapeData.strokes);
                    }
                    const walletCanvas = document.getElementById('walletCanvas');
                    const walletCtx = walletCanvas.getContext('2d');
                    walletCtx.clearRect(0, 0, walletCanvas.width, walletCanvas.height);
                    walletCtx.fillStyle = '#000';
                    walletCtx.fillRect(0, 0, walletCanvas.width, walletCanvas.height);
                    walletCtx.strokeStyle = uiColors[currentColorIndex];
                    walletCtx.lineWidth = 2;
                    walletCtx.lineCap = 'round';
                    walletCtx.lineJoin = 'round';
                    shapeData.strokes.forEach(stroke => {
                        if (stroke.length < 2) return;
                        walletCtx.beginPath();
                        stroke.forEach((point, idx) => {
                            const x = (point.x / canvasWidth) * walletCanvas.width;
                            const y = (point.y / canvasHeight) * walletCanvas.height;
                            if (idx === 0) walletCtx.moveTo(x, y);
                            else walletCtx.lineTo(x, y);
                        });
                        walletCtx.stroke();
                    });
                    showConfirmation(`Loaded: ${validSerial} | ${validCode}`);
                } else {
                    showConfirmation(`ERROR: Serial ${validSerial} not found`);
                }
            } catch (error) {
                showConfirmation(`ERROR: Load NFT image failed - ${error.message}`);
            }
        }

        // Initialize
        try {
            loadState();
            generateShape();
        } catch (error) {
            showConfirmation(`ERROR: Initialization failed - ${error.message}`);
        }
    </script>
</body>
</html>
