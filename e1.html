<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Exoskeleton AI</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #0f0;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            overscroll-behavior: none;
        }
        .header {
            width: 100%;
            max-width: 320px;
            text-align: center;
            padding: 8px;
            font-size: 16px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0, 0 0 10px #0f0;
            height: 40px;
            position: fixed;
            top: 0;
            background: rgba(0,0,0,0.8);
            z-index: 20;
        }
        .app-container {
            width: 100%;
            max-width: 320px;
            height: 320px;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 40px;
            margin-bottom: 10px;
        }
        .hologram-container {
            width: 360px;
            height: 320px;
            position: relative;
            overflow: hidden;
        }
        .hologram {
            width: 320px;
            height: 320px;
            position: absolute;
            top: 0;
            left: 20px;
            transform-style: preserve-3d;
            animation: rotateHologram 30s infinite linear;
        }
        .grid-square {
            position: absolute;
            background: rgba(0,255,0,0.6);
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
            animation: pulseSquare 4s infinite;
        }
        .signature-layer {
            position: absolute;
            width: 200px;
            height: 100px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.6;
            z-index: 10;
            filter: drop-shadow(0 0 5px #0f0);
        }
        .signature-layer canvas {
            width: 100%;
            height: 100%;
        }
        .bottom-section {
            width: 100%;
            max-width: 320px;
            position: fixed;
            bottom: 0;
            display: flex;
            flex-direction: column;
            background: rgba(0,0,0,0.8);
            box-shadow: 0 0 10px #0f0;
            z-index: 10;
        }
        .console-section {
            width: 100%;
            max-height: calc(100vh - 40px - 320px - 52px - 20px);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #console {
            width: 100%;
            flex: 1;
            overflow-y: auto;
            touch-action: auto;
            font-size: 14px;
            padding: 8px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: #0f0 rgba(0,0,0,0.8);
            overscroll-behavior: contain;
        }
        #console::-webkit-scrollbar {
            width: 8px;
        }
        #console::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.8);
        }
        #console::-webkit-scrollbar-thumb {
            background: #0f0;
            border-radius: 4px;
            box-shadow: 0 0 5px #0f0;
        }
        .entry {
            margin: 4px 0;
            word-wrap: break-word;
        }
        .timestamp {
            color: #080;
            margin-right: 8px;
        }
        .input-area {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            width: 100%;
            padding: 8px;
            background: rgba(0,0,0,0.8);
            border-top: 1px solid #0f0;
            min-height: 52px;
        }
        input {
            flex: 1;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            padding: 8px;
            box-shadow: 0 0 5px #0f0;
            min-height: 36px;
            min-width: 100px;
            touch-action: auto;
        }
        button {
            flex: 0 0 auto;
            background: rgba(0,255,0,0.1);
            color: #0f0;
            border: 2px solid #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            padding: 8px;
            border-radius: 8px;
            min-height: 36px;
            min-width: 70px;
            text-transform: uppercase;
            transition: all 0.2s ease;
            box-shadow: 0 0 8px #0f0;
            touch-action: auto;
        }
        button:hover {
            background: #0f0;
            color: #000;
            cursor: pointer;
            box-shadow: 0 0 12px #0f0;
            transform: scale(1.05);
        }
        button:active {
            transform: scale(0.95);
            box-shadow: 0 0 5px #0f0;
        }
        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            padding: 12px;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 1000;
            box-shadow: 0 0 10px #0f0;
            touch-action: auto;
        }
        .popup h3 {
            margin: 0 0 10px;
            font-size: 14px;
            text-shadow: 0 0 5px #0f0;
        }
        .popup canvas {
            width: 100%;
            height: 150px;
            background: #000;
            border: 1px solid #0f0;
            margin-bottom: 8px;
            touch-action: auto;
        }
        .popup input[type="file"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            font-size: 12px;
        }
        .popup .btn {
            width: 100%;
            margin: 5px 0;
            padding: 8px;
            background: rgba(0,255,0,0.1);
            color: #0f0;
            border: 2px solid #0f0;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 8px #0f0;
            transition: all 0.2s ease;
            touch-action: auto;
        }
        .popup .btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 12px #0f0;
        }
        .popup .btn:active {
            transform: scale(0.95);
        }
        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 999;
            touch-action: none;
        }
        footer {
            width: 100%;
            text-align: center;
            font-size: 10px;
            color: #0f0;
            padding: 4px 0;
            text-shadow: 0 0 3px #0f0;
            height: 20px;
            background: rgba(0,0,0,0.8);
            border-top: 1px solid #0f0;
        }
        @media (max-width: 480px) {
            .header {
                max-width: 280px;
                font-size: 14px;
                padding: 6px;
                height: 36px;
            }
            .app-container {
                max-width: 280px;
                height: 280px;
                margin-top: 36px;
            }
            .hologram-container {
                width: 300px;
                height: 280px;
            }
            .hologram {
                width: 280px;
                height: 280px;
                left: 10px;
            }
            .signature-layer {
                width: 150px;
                height: 75px;
            }
            .bottom-section {
                max-width: 100%;
            }
            .console-section {
                max-height: calc(100vh - 36px - 280px - 48px - 18px);
            }
            #console {
                font-size: 12px;
                padding: 6px;
            }
            .input-area {
                gap: 5px;
                padding: 6px;
                min-height: 48px;
            }
            input {
                font-size: 12px;
                padding: 6px;
                min-height: 32px;
                min-width: 90px;
            }
            button {
                font-size: 12px;
                padding: 6px;
                min-height: 32px;
                min-width: 60px;
                border-radius: 6px;
            }
            .popup {
                width: 260px;
            }
            .popup .btn {
                font-size: 12px;
                padding: 6px;
            }
            footer {
                font-size: 9px;
                padding: 3px;
                height: 18px;
            }
        }
        @keyframes rotateHologram {
            0% { transform: rotateY(0deg) rotateX(15deg); }
            100% { transform: rotateY(360deg) rotateX(15deg); }
        }
        @keyframes pulseSquare {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <div class="header">Exoskeleton AI</div>
    <div class="app-container">
        <div class="hologram-container">
            <div class="hologram" id="hologram"></div>
        </div>
    </div>
    <div class="bottom-section">
        <div class="console-section">
            <div id="console">
                <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Exoskeleton AI v1.0 - Holographic Console initialized</div>
                <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Type 'HELP' for commands</div>
                <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Serials and codes encode data algorithmically; stored in IndexedDB (webXOS collects no data, use at your own risk.)</div>
            </div>
        </div>
        <div class="input-area">
            <input type="text" id="commandInput" placeholder="Enter command..." onkeydown="if(event.key === 'Enter') executeCommand()">
            <button onclick="executeCommand()">Execute</button>
            <button onclick="clearConsole()">Clear</button>
        </div>
        <footer>WebXOS 2025 stores no data. Use at your own risk.</footer>
    </div>
    <div class="popup-overlay" id="signOverlay"></div>
    <div class="popup" id="signPopup">
        <h3>Sign Exoskeleton AI</h3>
        <canvas id="signCanvas"></canvas>
        <button class="btn" onclick="submitSignature()">Submit</button>
        <button class="btn" onclick="closeSignPopup()">Cancel</button>
    </div>
    <div class="popup-overlay" id="uploadOverlay"></div>
    <div class="popup" id="uploadPopup">
        <h3>Upload File</h3>
        <p>Max file size: 5MB per file</p>
        <p id="storageInfo">Checking storage...</p>
        <input type="file" id="fileInput">
        <button class="btn" onclick="submitUpload()">Upload</button>
        <button class="btn" onclick="closeUploadPopup()">Cancel</button>
    </div>
    <script>
        let database = [];
        let currentSerial = '';
        let currentCode = '';
        let serialCounter = 1;
        let serialMap = new Map();
        const hologram = document.getElementById('hologram');
        const commandInput = document.getElementById('commandInput');
        const consoleDiv = document.getElementById('console');
        const signCanvas = document.getElementById('signCanvas');
        const signCtx = signCanvas.getContext('2d');
        const signPopup = document.getElementById('signPopup');
        const signOverlay = document.getElementById('signOverlay');
        const uploadPopup = document.getElementById('uploadPopup');
        const uploadOverlay = document.getElementById('uploadOverlay');
        const fileInput = document.getElementById('fileInput');
        const storageInfo = document.getElementById('storageInfo');
        let painting = false;
        let strokes = [];
        let currentStroke = [];
        const DB_NAME = 'ExoskeletonAI';
        const STATE_STORE_NAME = 'State';
        const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB per file
        const DEFAULT_MAX_DB_SIZE = 50 * 1024 * 1024; // Fallback: 50MB
        let saveStateTimeout = null;

        // Initialize canvas
        signCanvas.width = 280;
        signCanvas.height = 150;
        signCtx.lineWidth = 3;
        signCtx.lineCap = 'round';
        signCtx.lineJoin = 'round';
        signCtx.strokeStyle = '#0f0';

        // Prevent page scrolling on touch
        document.addEventListener('touchmove', (e) => {
            if (!e.target.closest('#console') && !e.target.closest('.popup') && !e.target.closest('.input-area')) {
                e.preventDefault();
            }
        }, { passive: false });

        // Ensure console scrolling is smooth
        consoleDiv.addEventListener('touchstart', () => {
            consoleDiv.style.scrollBehavior = 'smooth';
        });

        // Storage Quota Estimation
        async function getStorageQuota() {
            try {
                if (navigator.storage && navigator.storage.estimate) {
                    const estimate = await navigator.storage.estimate();
                    const total = estimate.quota || DEFAULT_MAX_DB_SIZE;
                    const used = estimate.usage || 0;
                    return { total, used, remaining: total - used };
                }
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>WARNING: Storage quota API not supported. Using default limit of ${(DEFAULT_MAX_DB_SIZE / (1024 * 1024)).toFixed(2)} MB</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return { total: DEFAULT_MAX_DB_SIZE, used: 0, remaining: DEFAULT_MAX_DB_SIZE };
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to estimate storage quota - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return { total: DEFAULT_MAX_DB_SIZE, used: 0, remaining: DEFAULT_MAX_DB_SIZE };
            }
        }

        // IndexedDB Setup
        let dbPromise = null;
        function openDB() {
            if (dbPromise) return dbPromise;
            dbPromise = new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 2);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STATE_STORE_NAME)) {
                        db.createObjectStore(STATE_STORE_NAME, { keyPath: 'id' });
                    }
                };
                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };
                request.onerror = (event) => {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to open IndexedDB - ${event.target.error.message}</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    reject(event.target.error);
                };
            });
            return dbPromise;
        }

        async function saveAppState() {
            clearTimeout(saveStateTimeout);
            return new Promise((resolve) => {
                saveStateTimeout = setTimeout(async () => {
                    try {
                        const db = await openDB();
                        const transaction = db.transaction([STATE_STORE_NAME], 'readwrite');
                        const store = transaction.objectStore(STATE_STORE_NAME);
                        const state = {
                            id: 'appState',
                            serialMap: JSON.stringify([...serialMap]),
                            serialCounter,
                            currentSerial,
                            currentCode,
                            database: compressDatabase(database)
                        };
                        const request = store.put(state);
                        request.onsuccess = () => resolve();
                        request.onerror = () => {
                            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to save app state - ${request.error.message}</div>`;
                            consoleDiv.scrollTop = consoleDiv.scrollHeight;
                            resolve();
                        };
                    } catch (error) {
                        consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to save app state - ${error.message}</div>`;
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        resolve();
                    }
                }, 100);
            });
        }

        async function loadAppState() {
            try {
                const db = await openDB();
                const transaction = db.transaction([STATE_STORE_NAME], 'readonly');
                const store = transaction.objectStore(STATE_STORE_NAME);
                const request = store.get('appState');
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        const state = request.result;
                        if (state) {
                            try {
                                serialMap = new Map(JSON.parse(state.serialMap || '[]'));
                                serialCounter = state.serialCounter || 1;
                                currentSerial = state.currentSerial || '';
                                currentCode = state.currentCode || '';
                                database = state.database ? decompressDatabase(state.database, hashCode(currentSerial)) : [];
                            } catch (e) {
                                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>WARNING: Invalid state data, resetting state</div>`;
                                serialMap = new Map();
                                serialCounter = 1;
                                currentSerial = '';
                                currentCode = '';
                                database = [];
                            }
                        }
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        resolve();
                    };
                    request.onerror = () => {
                        consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to load app state - ${request.error.message}</div>`;
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        reject(request.error);
                    };
                });
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to load app state - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                throw error;
            }
        }

        function getFullTimestamp() {
            return new Date().toLocaleString();
        }

        function hashCode(str, salt = '') {
            let hash = 2166136261;
            const saltedStr = str + salt;
            for (let i = 0; i < saltedStr.length; i++) {
                hash ^= saltedStr.charCodeAt(i);
                hash *= 16777619;
            }
            return Math.abs(hash);
        }

        function seededRandom(seed) {
            let x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        function compressDatabase(entries) {
            try {
                return JSON.stringify(entries.map(entry => ({
                    text: entry.text,
                    time: entry.time.toISOString(),
                    signature: entry.signature,
                    miniSignature: entry.miniSignature,
                    isFile: entry.isFile || false,
                    fileName: entry.fileName || '',
                    fileSize: entry.fileSize || 0,
                    fileType: entry.fileType || '',
                    fileData: entry.fileData || ''
                })));
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to compress database - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return '[]';
            }
        }

        function decompressDatabase(compressed, seed) {
            try {
                const entries = JSON.parse(compressed);
                return entries.map(entry => ({
                    text: entry.text || '',
                    time: new Date(entry.time || Date.now()),
                    signature: entry.signature || false,
                    miniSignature: entry.miniSignature || '',
                    isFile: entry.isFile || false,
                    fileName: entry.fileName || '',
                    fileSize: entry.fileSize || 0,
                    fileType: entry.fileType || '',
                    fileData: entry.fileData || ''
                }));
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Decompression failed - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return [];
            }
        }

        function encodeDatabase(entries, serial) {
            try {
                const compressed = compressDatabase(entries);
                const seed = hashCode(serial);
                let encoded = '';
                for (let i = 0; i < compressed.length; i++) {
                    const charCode = compressed.charCodeAt(i);
                    const shift = (seed >> (i % 32)) & 0xFF;
                    encoded += String.fromCharCode((charCode + shift) % 256);
                }
                return btoa(encoded);
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Encoding failed - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return '';
            }
        }

        function decodeDatabase(encoded, serial) {
            try {
                const seed = hashCode(serial);
                const decoded = atob(encoded);
                let decompressed = '';
                for (let i = 0; i < decoded.length; i++) {
                    const charCode = decoded.charCodeAt(i);
                    const shift = (seed >> (i % 32)) & 0xFF;
                    decompressed += String.fromCharCode((charCode - shift + 256) % 256);
                }
                return decompressDatabase(decompressed, seed);
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Decoding failed - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return [];
            }
        }

        function generateRandomSuffix() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let suffix = '';
            for (let i = 0; i < 3; i++) {
                suffix += chars.charAt(Math.floor(seededRandom(hashCode(suffix + i)) * chars.length));
            }
            return suffix.toUpperCase();
        }

        function generateSerialNumber(code) {
            let serial;
            let attempts = 0;
            const maxAttempts = 1000;
            do {
                if (serialCounter > 999999) {
                    serialCounter = 1;
                }
                const paddedNumber = String(serialCounter++).padStart(6, '0');
                const suffix = generateRandomSuffix();
                serial = `HOLO-${paddedNumber}-${suffix}`;
                attempts++;
                if (attempts > maxAttempts) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to generate unique serial</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return null;
                }
            } while (serialMap.has(serial));
            serialMap.set(serial, { code, encryptedDatabase: '', strokes: [] });
            saveAppState();
            return serial;
        }

        function generateCrypticCode(serial) {
            const glyphs = 'ΔΩΨΘΣΦΩΓΛΞΠΩ0123456789#@&%*+-=<>';
            let code = '';
            const seedValue = hashCode(serial + 'CODE');
            for (let i = 0; i < 9; i++) {
                code += glyphs.charAt(Math.floor(seededRandom(seedValue + i) * glyphs.length));
            }
            return `Ω-CODE: ${code}`;
        }

        function generateCodeSign(serial, timestamp) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let sign = '';
            const seedValue = hashCode(serial + timestamp);
            for (let i = 0; i < 8; i++) {
                sign += chars.charAt(Math.floor(seededRandom(seedValue + i) * chars.length));
                if (i === 3) sign += '-';
            }
            return `Ω-SIGN: ${sign}`;
        }

        function createStrokeReplica(codesign) {
            const glyphMap = {
                'A': 'Λ', 'B': 'β', 'C': 'C', 'D': 'Δ', 'E': 'Σ', 'F': 'F', 'G': 'Γ', 'H': 'H',
                'I': 'I', 'J': 'J', 'K': 'K', 'L': 'L', 'M': 'M', 'N': 'N', 'O': 'O', 'P': 'Π',
                'Q': 'Q', 'R': 'R', 'S': 'S', 'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X',
                'Y': 'Y', 'Z': 'Z', '0': '0', '1': '|', '2': '2', '3': '3', '4': '4', '5': '5',
                '6': '6', '7': '7', '8': '8', '9': '9', '-': '-'
            };
            return codesign.replace(/./g, c => glyphMap[c] || c);
        }

        function startPainting(e) {
            painting = true;
            const rect = signCanvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            currentStroke = [{ x, y }];
            signCtx.beginPath();
            signCtx.moveTo(x, y);
        }

        function stopPainting() {
            if (painting) {
                painting = false;
                if (currentStroke.length > 1) {
                    strokes.push([...currentStroke]);
                }
                currentStroke = [];
                signCtx.beginPath();
            }
        }

        function draw(e) {
            if (!painting) return;
            e.preventDefault();
            const rect = signCanvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            currentStroke.push({ x, y });
            signCtx.lineTo(x, y);
            signCtx.stroke();
            signCtx.beginPath();
            signCtx.moveTo(x, y);
        }

        signCanvas.addEventListener('mousedown', startPainting);
        signCanvas.addEventListener('mouseup', stopPainting);
        signCanvas.addEventListener('mousemove', draw);
        signCanvas.addEventListener('touchstart', startPainting);
        signCanvas.addEventListener('touchend', stopPainting);
        signCanvas.addEventListener('touchmove', draw);
        signCanvas.addEventListener('mouseleave', stopPainting);

        function clearSignCanvas() {
            signCtx.clearRect(0, 0, signCanvas.width, signCanvas.height);
            strokes = [];
            currentStroke = [];
            painting = false;
            signCtx.beginPath();
        }

        function drawSignatureStrokes(canvas, ctx, strokes, width, height) {
            ctx.clearRect(0, 0, width, height);
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = '#0f0';
            strokes.forEach(stroke => {
                if (stroke.length < 2) return;
                ctx.beginPath();
                stroke.forEach((point, idx) => {
                    const x = (point.x / 280) * width;
                    const y = (point.y / 150) * height;
                    if (idx === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            });
        }

        async function submitSignature() {
            if (strokes.length === 0 && currentStroke.length <= 1) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Draw a signature first</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (strokes.reduce((sum, stroke) => sum + stroke.length, 0) + currentStroke.length < 5) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Signature too short</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (currentStroke.length > 1) {
                strokes.push([...currentStroke]);
            }
            const timestamp = Date.now().toString();
            const codesign = generateCodeSign(currentSerial, timestamp);
            const strokeReplica = createStrokeReplica(codesign);
            const fullImage = signCanvas.toDataURL('image/png');
            const miniCanvas = document.createElement('canvas');
            miniCanvas.width = 50;
            miniCanvas.height = 50;
            const miniCtx = miniCanvas.getContext('2d');
            drawSignatureStrokes(miniCanvas, miniCtx, strokes, 50, 50);
            const miniImage = miniCanvas.toDataURL('image/png');
            database.push({
                text: `Signed by: ${fullImage} ${codesign} (${strokeReplica})`,
                time: new Date(),
                signature: true,
                miniSignature: miniImage
            });
            serialMap.get(currentSerial).strokes = strokes;
            await saveAppState();
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Signature added: ${codesign}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            closeSignPopup();
            generateGrid(currentSerial, { serial: currentSerial, entries: database, code: currentCode }, serialMap.get(currentSerial).encryptedDatabase);
        }

        function showSignPopup() {
            if (database.some(entry => entry.signature)) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Exoskeleton AI already signed</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            clearSignCanvas();
            signPopup.style.display = 'block';
            signOverlay.style.display = 'block';
        }

        function closeSignPopup() {
            signPopup.style.display = 'none';
            signOverlay.style.display = 'none';
            clearSignCanvas();
        }

        async function showUploadPopup() {
            fileInput.value = '';
            try {
                const quota = await getStorageQuota();
                const browser = navigator.userAgent;
                const browserName = browser.includes('Chrome') ? 'Chrome' :
                                   browser.includes('Firefox') ? 'Firefox' :
                                   browser.includes('Safari') ? 'Safari' : 'your browser';
                const totalMB = (quota.total / (1024 * 1024)).toFixed(2);
                const usedMB = (quota.used / (1024 * 1024)).toFixed(2);
                const remainingMB = (quota.remaining / (1024 * 1024)).toFixed(2);
                storageInfo.textContent = `${browserName} supports up to ${totalMB} MB. ${remainingMB} MB remaining.`;
                uploadPopup.style.display = 'block';
                uploadOverlay.style.display = 'block';
            } catch (error) {
                storageInfo.textContent = `ERROR: Unable to check storage. Using default limit of ${(DEFAULT_MAX_DB_SIZE / (1024 * 1024)).toFixed(2)} MB.`;
                uploadPopup.style.display = 'block';
                uploadOverlay.style.display = 'block';
            }
        }

        function closeUploadPopup() {
            uploadPopup.style.display = 'none';
            uploadOverlay.style.display = 'none';
            fileInput.value = '';
        }

        async function submitUpload() {
            const file = fileInput.files[0];
            if (!file) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No file selected</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (file.size > MAX_FILE_SIZE) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: File size exceeds 5MB limit</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            try {
                const quota = await getStorageQuota();
                if (file.size > quota.remaining) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Insufficient browser storage</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                const reader = new FileReader();
                reader.onload = async () => {
                    try {
                        const base64Data = reader.result.split(',')[1];
                        if (!base64Data) {
                            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to encode file to base64</div>`;
                            consoleDiv.scrollTop = consoleDiv.scrollHeight;
                            return;
                        }
                        database.push({
                            text: `File: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`,
                            time: new Date(),
                            signature: false,
                            miniSignature: '',
                            isFile: true,
                            fileName: file.name,
                            fileSize: file.size,
                            fileType: file.type || 'application/octet-stream',
                            fileData: base64Data
                        });
                        await saveAppState();
                        consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>File uploaded: ${file.name} (${(file.size / 1024).toFixed(2)} KB)</div>`;
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        closeUploadPopup();
                    } catch (error) {
                        consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to process file data - ${error.message}</div>`;
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    }
                };
                reader.onerror = () => {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to read file - ${reader.error.message}</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                };
                reader.readAsDataURL(file);
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to upload file - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        async function downloadFile(index) {
            if (isNaN(index) || index < 0 || index >= database.length) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid index ${index}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            const entry = database[index];
            if (!entry.isFile) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Entry at index ${index} is not a downloadable file</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (entry.text === ':DELETED') {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: File at index ${index} has been deleted</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            try {
                if (!entry.fileData) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: File data not found in database</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                const byteCharacters = atob(entry.fileData);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], { type: entry.fileType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = entry.fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>File downloaded: ${entry.fileName}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to download file - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        async function removeEntry(index) {
            if (isNaN(index) || index < 0 || index >= database.length) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid index ${index}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            database[index].text = ':DELETED';
            await saveAppState();
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Entry at index ${index} marked as deleted</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        async function showDatabaseStats() {
            try {
                const quota = await getStorageQuota();
                const localSize = database.reduce((sum, entry) => sum + (entry.fileSize || 0), 0);
                const browser = navigator.userAgent;
                const browserName = browser.includes('Chrome') ? 'Chrome' :
                                   browser.includes('Firefox') ? 'Firefox' :
                                   browser.includes('Safari') ? 'Safari' : 'your browser';
                const output = `
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Database Stats:</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>${browserName} supports: ${(quota.total / (1024 * 1024)).toFixed(2)} MB</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Total Used (all apps): ${(quota.used / (1024 * 1024)).toFixed(2)} MB</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>This Database Used: ${(localSize / (1024 * 1024)).toFixed(2)} MB</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Remaining: ${(quota.remaining / (1024 * 1024)).toFixed(2)} MB</div>
                `;
                consoleDiv.innerHTML += output;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to retrieve database stats - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        function generateImageFromSeed(code, serial, data, encryptedDatabase) {
            hologram.innerHTML = '';
            const seed = hashCode(code + serial);
            const squareCount = 50; // Number of squares for chaotic effect
            for (let i = 0; i < squareCount; i++) {
                if (seededRandom(seed + i) > 0.2) {
                    const square = document.createElement('div');
                    square.className = 'grid-square';
                    const size = 10 + (seededRandom(seed + i + 1) * 20); // Random size 10-30px
                    const maxX = 320 - size;
                    const maxY = 320 - size;
                    const x = seededRandom(seed + i + 2) * maxX;
                    const y = seededRandom(seed + i + 3) * maxY;
                    square.style.width = `${size}px`;
                    square.style.height = `${size}px`;
                    square.style.left = `${x}px`;
                    square.style.top = `${y}px`;
                    square.style.animationDelay = `${(seededRandom(seed + i + 4) * 2).toFixed(2)}s`;
                    hologram.appendChild(square);
                }
            }
            const signatureData = data.entries.find(entry => entry.signature && entry.miniSignature);
            if (signatureData && signatureData.miniSignature) {
                const signatureLayer = document.createElement('div');
                signatureLayer.className = 'signature-layer';
                const sigCanvas = document.createElement('canvas');
                sigCanvas.width = 200;
                sigCanvas.height = 100;
                const sigCtx = sigCanvas.getContext('2d');
                const img = new Image();
                img.src = signatureData.miniSignature;
                img.onload = () => {
                    sigCtx.drawImage(img, 0, 0, 200, 100);
                    signatureLayer.appendChild(sigCanvas);
                    hologram.appendChild(signatureLayer);
                };
                img.onerror = () => {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to load signature image</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                };
            }
        }

        function generateGrid(serial, data, encryptedDatabase) {
            generateImageFromSeed(data.code, serial, data, encryptedDatabase);
        }

        async function initializeGrid() {
            await loadAppState();
            if (!currentSerial) {
                const initSeed = 'INIT' + serialCounter;
                const initCode = generateCrypticCode(initSeed);
                const initSerial = `HOLO-${String(serialCounter).padStart(6,'0')}-INIT`;
                if (!serialMap.has(initSerial)) {
                    serialMap.set(initSerial, { code: initCode, encryptedDatabase: '', strokes: [] });
                    await saveAppState();
                }
                currentSerial = initSerial;
                currentCode = initCode;
                database = [];
            }
            generateImageFromSeed(currentCode, currentSerial, { serial: currentSerial, entries: database, code: currentCode }, serialMap.get(currentSerial)?.encryptedDatabase || '');
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Initial grid: ${currentSerial} | ${currentCode}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            const helpText = `
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Available Commands:</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ADD [data] - Add entry to database</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>VIEW - Show all entries</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>CLEAR - Clear console and current session</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>REMOVE [index] - Remove entry at index (e.g., REMOVE 1)</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>GENERATE - Generate grid with encoded database</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HTML - Generate HTML data sheet and copy to clipboard</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SIGN - Sign the current Exoskeleton AI</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>UPLOAD - Upload a file to the database (max 5MB)</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>DOWNLOAD [index] - Download file at index (e.g., DOWNLOAD 5)</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>DATA - Show database storage usage</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HELP - Show this help</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Enter [serial] [code] to load grid (e.g., HOLO-000001-A7K Ω-CODE: ---111---)</div>
            `;
            consoleDiv.innerHTML += helpText;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function generateDatabase() {
            if (database.length === 0) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No data to generate</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            let newCode;
            do {
                newCode = generateCrypticCode('TEMP' + serialCounter + database.length);
            } while (Array.from(serialMap.values()).some(data => data.code === newCode));
            const serial = generateSerialNumber(newCode);
            if (!serial) return;
            const encodedData = encodeDatabase(database, serial);
            if (!encodedData) return;
            serialMap.set(serial, { code: newCode, encryptedDatabase: encodedData, strokes: serialMap.get(currentSerial)?.strokes || [] });
            saveAppState();
            currentSerial = serial;
            currentCode = newCode;
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Grid generated: ${serial} | ${newCode}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            navigator.clipboard.writeText(`${serial}\n${newCode}`).then(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Serial and code copied to clipboard</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }).catch(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to copy serial and code</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            });
            generateGrid(serial, { serial, entries: database, code: newCode }, encodedData);
        }

        function loadGridFromSerial(userSerial, userCode) {
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Attempting to load serial: ${userSerial} | code: ${userCode}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            if (!userSerial || !userCode) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Serial and code required</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            const serialData = serialMap.get(userSerial);
            if (!serialData) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Serial ${userSerial} not found in database</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (serialData.code !== userCode) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid code for serial ${userSerial}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (!serialData.encryptedDatabase) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>WARNING: No database associated with serial ${userSerial}</div>`;
                database = [];
            } else {
                database = decodeDatabase(serialData.encryptedDatabase, userSerial);
                if (database.length === 0 && serialData.encryptedDatabase) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to decode database for serial ${userSerial}</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
            }
            currentSerial = userSerial;
            currentCode = userCode;
            saveAppState();
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Grid loaded: ${userSerial} | ${userCode}</div>`;
            if (database.length > 0) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Database entries:</div>`;
                database.forEach((entry, index) => {
                    let displayText = entry.text;
                    if (entry.isFile) {
                        displayText = `${entry.text} (${(entry.fileSize / 1024).toFixed(2)} KB)`;
                    }
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>[${index}] ${entry.time.toLocaleString()} - ${displayText}</div>`;
                });
            } else {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>No entries in database</div>`;
            }
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            generateGrid(userSerial, { serial: userSerial, entries: database, code: userCode }, serialData.encryptedDatabase || '');
        }

        function generateHTMLSheet() {
            if (database.length === 0) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No data to generate HTML</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            let htmlContent = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exoskeleton AI Data Sheet</title>
    <style>
        body { font-family: 'Courier New', monospace; background: #000; color: #0f0; padding: 20px; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #0f0; padding: 8px; text-align: left; }
        th { background: rgba(0,255,0,0.1); }
        img.signature { max-width: 100px; vertical-align: middle; }
        h1 { text-align: center; text-shadow: 0 0 5px #0f0; }
    </style>
</head>
<body>
    <h1>Exoskeleton AI Data Sheet</h1>
    <table>
        <tr>
            <th>Index</th>
            <th>Timestamp</th>
            <th>Data</th>
            <th>Type</th>
        </tr>
`;
            database.forEach((entry, index) => {
                const type = entry.signature ? 'Signature' : entry.isFile ? 'File' : 'Text';
                let dataDisplay = entry.text;
                if (entry.signature) {
                    dataDisplay = `<img class="signature" src="${entry.miniSignature}" alt="Signature"> ${entry.text.split(' ').slice(2).join(' ')}`;
                } else if (entry.isFile) {
                    dataDisplay = `${entry.text} (${(entry.fileSize / 1024).toFixed(2)} KB)`;
                }
                htmlContent += `
        <tr>
            <td>${index}</td>
            <td>${entry.time.toLocaleString()}</td>
            <td>${dataDisplay}</td>
            <td>${type}</td>
        </tr>
`;
            });
            htmlContent += `
    </table>
</body>
</html>
`;
            navigator.clipboard.writeText(htmlContent).then(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HTML data sheet copied to clipboard</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }).catch(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to copy HTML data sheet</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            });
        }

        function clearConsole() {
            consoleDiv.innerHTML = '';
            database = [];
            currentSerial = '';
            currentCode = '';
            serialMap.clear();
            serialCounter = 1;
            saveAppState();
            initializeGrid();
        }

        function executeCommand() {
            const input = commandInput.value.trim();
            commandInput.value = '';
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>> ${input}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            const parts = input.split(' ');
            const command = parts[0].toUpperCase();
            const args = parts.slice(1).join(' ');

            if (command === 'HELP') {
                const helpText = `
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Available Commands:</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ADD [data] - Add entry to database</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>VIEW - Show all entries</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>CLEAR - Clear console and current session</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>REMOVE [index] - Remove entry at index (e.g., REMOVE 1)</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>GENERATE - Generate grid with encoded database</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HTML - Generate HTML data sheet and copy to clipboard</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SIGN - Sign the current Exoskeleton AI</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>UPLOAD - Upload a file to the database (max 5MB)</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>DOWNLOAD [index] - Download file at index (e.g., DOWNLOAD 5)</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>DATA - Show database storage usage</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HELP - Show this help</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Enter [serial] [code] to load grid (e.g., HOLO-000001-A7K Ω-CODE: ---111---)</div>
                `;
                consoleDiv.innerHTML += helpText;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } else if (command === 'ADD') {
                if (!args) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Data required for ADD</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                database.push({
                    text: args,
                    time: new Date(),
                    signature: false,
                    miniSignature: ''
                });
                saveAppState();
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Data added: ${args}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } else if (command === 'VIEW') {
                if (database.length === 0) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>No entries in database</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                database.forEach((entry, index) => {
                    let displayText = entry.text;
                    if (entry.isFile) {
                        displayText = `${entry.text} (${(entry.fileSize / 1024).toFixed(2)} KB)`;
                    }
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>[${index}] ${entry.time.toLocaleString()} - ${displayText}</div>`;
                });
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } else if (command === 'CLEAR') {
                clearConsole();
            } else if (command === 'REMOVE') {
                const index = parseInt(args, 10);
                if (isNaN(index)) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid index for REMOVE</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                removeEntry(index);
            } else if (command === 'GENERATE') {
                generateDatabase();
            } else if (command === 'HTML') {
                generateHTMLSheet();
            } else if (command === 'SIGN') {
                showSignPopup();
            } else if (command === 'UPLOAD') {
                showUploadPopup();
            } else if (command === 'DOWNLOAD') {
                const index = parseInt(args, 10);
                if (isNaN(index)) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid index for DOWNLOAD</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                downloadFile(index);
            } else if (command === 'DATA') {
                showDatabaseStats();
            } else if (input.match(/^HOLO-\d{6}-[A-Z0-9]{3}/)) {
                const [serial, ...codeParts] = input.split(' ');
                const code = codeParts.join(' ');
                if (!code.startsWith('Ω-CODE:')) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid code format. Use Ω-CODE: followed by code</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                loadGridFromSerial(serial, code);
            } else {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Unknown command '${command}'</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        initializeGrid();
    </script>
</body>
</html>
