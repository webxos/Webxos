<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebX Graph</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: #000000;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        #toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding: 5px;
            background: #000000;
            border-bottom: 2px solid #00ff00;
        }
        #toolbar button, #toolbar select {
            padding: 5px 10px;
            font-size: 14px;
            border: 1px solid #00ff00;
            border-radius: 3px;
            background: #000000;
            color: #00ff00;
            cursor: pointer;
            text-shadow: 0 0 5px #00ff00;
        }
        #toolbar button.active {
            background: #00ff00;
            color: #000000;
            text-shadow: none;
        }
        #canvas {
            flex: 1;
            background: #000000;
            border: 1px solid #00ff00;
        }
        #colorPicker {
            width: 40px;
            height: 25px;
            padding: 0;
            border: 1px solid #00ff00;
            background: #000000;
        }
        #toolbar select {
            background: #000000;
            appearance: none;
            padding-right: 20px;
        }
        #footer {
            position: absolute;
            bottom: 5px;
            left: 5px;
            color: #00ff00;
            font-size: 12px;
            text-shadow: 0 0 5px #00ff00;
        }
        #nftCode {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000000;
            border: 2px solid #00ff00;
            padding: 10px;
            color: #00ff00;
            font-size: 14px;
            text-shadow: 0 0 5px #00ff00;
            display: none;
            text-align: center;
            max-width: 80%;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <button id="pencil" class="active">Pencil</button>
        <button id="eraser">Eraser</button>
        <button id="line">Line</button>
        <button id="rect">Rectangle</button>
        <button id="circle">Circle</button>
        <button id="triangle">Triangle</button>
        <button id="star">Star</button>
        <select id="size">
            <option value="2">Small</option>
            <option value="5" selected>Medium</option>
            <option value="10">Large</option>
        </select>
        <input type="color" id="colorPicker" value="#00ff00">
        <button id="autoGenerate">Auto Generate</button>
        <button id="mintNFT">Mint NFT</button>
        <button id="invert">Invert</button>
        <button id="clear">Clear</button>
    </div>
    <canvas id="canvas"></canvas>
    <div id="footer">Â© WebX 2025</div>
    <div id="nftCode"></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const toolbar = document.getElementById('toolbar');
        const nftCodeDiv = document.getElementById('nftCode');
        let painting = false;
        let startX, startY;
        let tool = 'pencil';
        let isInverted = false;

        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - toolbar.offsetHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Tool selection
        toolbar.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON' && 
                e.target.id !== 'clear' && 
                e.target.id !== 'invert' && 
                e.target.id !== 'autoGenerate' && 
                e.target.id !== 'mintNFT') {
                document.querySelectorAll('#toolbar button').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                tool = e.target.id;
            }
        });

        // Get current settings
        function getSettings() {
            return {
                color: document.getElementById('colorPicker').value,
                size: parseInt(document.getElementById('size').value)
            };
        }

        // Touch events
        canvas.addEventListener('touchstart', startPainting);
        canvas.addEventListener('touchmove', paint);
        canvas.addEventListener('touchend', stopPainting);

        function startPainting(e) {
            e.preventDefault();
            painting = true;
            const touch = e.touches[0];
            startX = touch.clientX;
            startY = touch.clientY - toolbar.offsetHeight;
            ctx.beginPath();
            ctx.moveTo(startX, startY);
        }

        function paint(e) {
            if (!painting) return;
            e.preventDefault();
            const touch = e.touches[0];
            const x = touch.clientX;
            const y = touch.clientY - toolbar.offsetHeight;
            const { color, size } = getSettings();

            ctx.strokeStyle = tool === 'eraser' ? '#000000' : color;
            ctx.lineWidth = size;
            ctx.lineCap = 'round';

            if (tool === 'pencil' || tool === 'eraser') {
                ctx.lineTo(x, y);
                ctx.stroke();
            }
        }

        function stopPainting(e) {
            if (!painting) return;
            painting = false;
            const { color, size } = getSettings();
            const endX = e.changedTouches[0].clientX;
            const endY = e.changedTouches[0].clientY - toolbar.offsetHeight;

            ctx.strokeStyle = color;
            ctx.lineWidth = size;

            if (tool === 'line') {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            } else if (tool === 'rect') {
                ctx.strokeRect(startX, startY, endX - startX, endY - startY);
            } else if (tool === 'circle') {
                const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                ctx.beginPath();
                ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                ctx.stroke();
            } else if (tool === 'triangle') {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.lineTo(startX * 2 - endX, endY);
                ctx.closePath();
                ctx.stroke();
            } else if (tool === 'star') {
                drawStar(startX, startY, 5, Math.abs(endX - startX), Math.abs(endX - startX) / 2);
            }
        }

        function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            const step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            ctx.stroke();
        }

        // Auto Generate
        document.getElementById('autoGenerate').addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const { color } = getSettings();

            for (let i = 0; i < 5; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 50 + 20;
                const shape = Math.floor(Math.random() * 4);

                ctx.strokeStyle = color;
                ctx.lineWidth = 2;

                switch (shape) {
                    case 0: // Circle
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 1: // Rectangle
                        ctx.strokeRect(x - size / 2, y - size / 2, size, size);
                        break;
                    case 2: // Triangle
                        ctx.beginPath();
                        ctx.moveTo(x, y - size);
                        ctx.lineTo(x + size, y + size);
                        ctx.lineTo(x - size, y + size);
                        ctx.closePath();
                        ctx.stroke();
                        break;
                    case 3: // Star
                        drawStar(x, y, 5, size, size / 2);
                        break;
                }
            }

            ctx.font = '30px Arial';
            ctx.fillStyle = color;
            ctx.fillText('WebX', Math.random() * (canvas.width - 50), Math.random() * (canvas.height - 30));
        });

        // Mint NFT
        document.getElementById('mintNFT').addEventListener('click', () => {
            const imageData = canvas.toDataURL('image/png');
            const nftCode = `WEBX-${Math.random().toString(36).substr(2, 9).toUpperCase()}-${Date.now()}`;
            nftCodeDiv.innerHTML = `NFT Minted!<br>Your NFT Code: ${nftCode}<br>(Simulated for display only)<br>Tap to dismiss`;
            nftCodeDiv.style.display = 'block';
            nftCodeDiv.addEventListener('click', () => {
                nftCodeDiv.style.display = 'none';
            });
        });

        // Invert canvas
        document.getElementById('invert').addEventListener('click', () => {
            isInverted = !isInverted;
            ctx.globalCompositeOperation = 'difference';
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'source-over';
        });

        // Clear canvas
        document.getElementById('clear').addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            isInverted = false;
        });
    </script>
</body>
</html>