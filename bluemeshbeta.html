<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Bluemesh 2025: Secure Bluetooth Mesh Networking for edge devices with WebGL visualization and AI-driven diagnostics.">
    <meta name="keywords" content="Bluemesh, Bluetooth Mesh, WebGL, WebAssembly, PWA, decentralized, webxos, encryption">
    <meta name="author" content="WEBXOS Standardization">
    <meta name="robots" content="index, follow">
    <meta name="copyright" content="© 2025 WEBXOS Standardization">
    <title>Bluemesh 2025</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background: black;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .console {
            flex-grow: 1;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid currentColor;
            padding: 5px;
            margin: 0 10px 5px 10px;
            font-size: 0.7em;
            line-height: 1.1;
            text-shadow: 0 0 5px currentColor, 0 0 10px currentColor, 0 0 15px currentColor;
            overflow-y: auto;
        }
        .button-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            padding: 3px;
            font-size: 0.8em;
        }
        button {
            background: transparent;
            border: 1px solid currentColor;
            color: currentColor;
            padding: 3px 6px;
            margin: 1px;
            min-width: 120px;
            text-shadow: 0 0 3px currentColor, 0 0 6px currentColor;
            cursor: pointer;
        }
        button:hover {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 5px currentColor;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        footer {
            text-align: center;
            font-size: 10px;
            text-shadow: 0 0 3px currentColor;
            height: 5px;
        }
        .input-line {
            display: flex;
            align-items: center;
        }
        .input-line p {
            margin: 0 5px 0 0;
        }
        .input-line input {
            background: transparent;
            border: none;
            color: currentColor;
            font: inherit;
            flex-grow: 1;
        }
        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid currentColor;
            padding: 10px;
            text-shadow: 0 0 5px currentColor;
        }
        .popup.active {
            display: block;
        }
        .non-interactive {
            cursor: default;
            opacity: 0.7;
        }
        .diagnostic-section {
            margin-top: 10px;
            border-top: 1px dashed currentColor;
        }
        #webglCanvas {
            display: none;
            width: 100%;
            height: 200px;
        }
        @media (max-width: 600px) {
            .console { font-size: 0.6em; }
            .button-container { font-size: 0.7em; }
            button { padding: 2px 4px; }
            .input-line input { font-size: 0.6em; }
            .popup { width: 90%; }
            footer { font-size: 0.6em; }
        }
    </style>
</head>
<body>
    <div class="console" id="consoleOutput">
        <p>Bluemesh 2025</p>
        <p>Secure Bluetooth Mesh Networking</p>
        <div class="input-line">
            <p>> </p>
            <input type="text" id="commandInput" placeholder="Enter command...">
        </div>
    </div>
    <canvas id="webglCanvas"></canvas>
    <div class="button-container">
        <button onclick="ConsoleManager.execute()">Execute</button>
        <button onclick="BluetoothMesh.discover()">Discover</button>
        <button onclick="ConsoleManager.help()">Help</button>
        <button onclick="Troubleshooter.check()">Troubleshoot</button>
    </div>
    <div id="wizardPopup" class="popup">
        <div id="step1" class="wizard-step active">
            <p>Step 1: Set Node ID</p>
            <p id="connectivityStatus">Checking connectivity...</p>
            <input type="text" id="nodeId" placeholder="Enter node ID (e.g., alice@webxos)">
            <button onclick="WizardManager.nextStep(1)">Next</button>
            <button onclick="WizardManager.skip()">Skip</button>
        </div>
    </div>
    <div id="confirmPopup" class="popup">
        <p id="confirmMessage"></p>
        <button id="confirmYes" onclick="BluetoothMesh.confirmMerge(true)">Yes</button>
        <button onclick="BluetoothMesh.confirmMerge(false)">No</button>
    </div>
    <footer>BLUEMESH v1.0.0 © 2025 WEBXOS Standardization, Tested: 06:06 AM EDT, July 13, 2025</footer>
    <script>
        // Cache API Workaround
        if ('caches' in window) {
            const CACHE_NAME = 'bluemesh-cache-v1';
            window.addEventListener('load', async () => {
                try {
                    const cache = await caches.open(CACHE_NAME);
                    await cache.addAll(['/']);
                    ConsoleManager.log('Cache initialized');
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Verify Cache API initialization');
                }
            });
            const originalFetch = window.fetch;
            window.fetch = async (...args) => {
                try {
                    const cache = await caches.open(CACHE_NAME);
                    const cachedResponse = await cache.match(args[0]);
                    return cachedResponse || originalFetch(...args);
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Verify Cache API fetch handling');
                    return originalFetch(...args);
                }
            };
        }

        // NodeSync Module
        const NodeSync = {
            keys: new Map(),
            generateNodeKey(nodeId) {
                if (!this.keys.has(nodeId)) {
                    const key = Array(16).fill().map(() => String.fromCharCode(65 + Math.floor(Math.random() * 26))).join('');
                    this.keys.set(nodeId, key);
                }
                return this.keys.get(nodeId);
            },
            getNodeKey(nodeId) {
                return this.keys.get(nodeId) || this.generateNodeKey(nodeId);
            },
            compressData(data, nodeId) {
                try {
                    if (typeof data !== 'object') throw new Error('Data must be an object');
                    const str = JSON.stringify(data);
                    if (str.length > 10 * 1024 * 1024) throw new Error('Data exceeds 10MB limit');
                    const compressed = btoa(str); // Simplified compression
                    return compressed;
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Optimize compression');
                    throw e;
                }
            },
            decompressData(compressed, nodeId) {
                try {
                    const str = atob(compressed);
                    const data = JSON.parse(str);
                    if (!this.validateData(data)) throw new Error('Invalid JSON data');
                    return data;
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Verify decompression');
                    throw e;
                }
            },
            encryptData(data, nodeId) {
                try {
                    const key = this.getNodeKey(nodeId);
                    const compressed = this.compressData(data, nodeId);
                    let encrypted = '';
                    for (let i = 0; i < compressed.length; i++) {
                        encrypted += String.fromCharCode(compressed.charCodeAt(i) ^ key.charCodeAt(i % key.length));
                    }
                    return btoa(encrypted);
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Enhance encryption');
                    throw e;
                }
            },
            decryptData(encrypted, nodeId) {
                try {
                    const key = this.getNodeKey(nodeId);
                    const decoded = atob(encrypted);
                    let decrypted = '';
                    for (let i = 0; i < decoded.length; i++) {
                        decrypted += String.fromCharCode(decoded.charCodeAt(i) ^ key.charCodeAt(i % key.length));
                    }
                    return this.decompressData(decrypted, nodeId);
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Verify decryption');
                    throw e;
                }
            },
            generateSerial(nodeId) {
                return `WEBXOS-${Array(13).fill().map(() => String.fromCharCode(65 + Math.floor(Math.random() * 26))).join('')}`;
            },
            validateData(data) {
                try {
                    JSON.stringify(data);
                    return true;
                } catch {
                    return false;
                }
            },
            retrieveData(serial, nodeId) {
                try {
                    const encrypted = localStorage.getItem(serial);
                    if (!encrypted) throw new Error('No data found for serial');
                    return this.decryptData(encrypted, nodeId);
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Check localStorage retrieval');
                    throw e;
                }
            },
            encryptWASM(data, nodeId) {
                return this.encryptData(data, nodeId); // JavaScript fallback
            }
        };

        // BluetoothMesh Module
        const BluetoothMesh = {
            nodeId: null,
            dataset: { node: null },
            setNodeId(id) {
                if (!id || !id.includes('@webxos')) {
                    ConsoleManager.logError('Node ID is empty or invalid');
                    return false;
                }
                this.nodeId = id;
                NodeSync.generateNodeKey(id);
                ConsoleManager.log(`Node ID set: ${id}`);
                return true;
            },
            async discover() {
                if (!this.nodeId) {
                    ConsoleManager.logError('Set node ID before discovery');
                    return;
                }
                try {
                    const nodes = [];
                    if (navigator.bluetooth && await navigator.bluetooth.getAvailability()) {
                        nodes.push(`${this.nodeId}-neighbor@webxos`);
                    } else {
                        nodes.push('FalseNode@webxos');
                        ConsoleManager.log('FalseNode@webxos detected (diagnostic, non-selectable). Displayed in red in WebGL for diagnostics only. Select valid nodes under "Discovered Nodes" for merging.');
                    }
                    this._renderNodes(nodes);
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Check Web Bluetooth');
                }
            },
            showConfirmation(node) {
                if (!node || !node.includes('@webxos')) {
                    ConsoleManager.logError('No valid node selected for merge. Select a node from the discovered list.');
                    return;
                }
                if (node === 'FalseNode@webxos') {
                    ConsoleManager.logError('Offline mode: FalseNode@webxos detected. Web Bluetooth unavailable. Ensure HTTPS, enable device Bluetooth, and check browser settings (e.g., Chrome: Settings > Privacy and security > Site settings > Bluetooth).');
                    document.getElementById('confirmYes').disabled = true;
                } else {
                    document.getElementById('confirmYes').disabled = false;
                }
                this.dataset.node = node;
                document.getElementById('confirmMessage').textContent = `Merge with ${node}?`;
                document.getElementById('confirmPopup').classList.add('active');
            },
            confirmMerge(confirm) {
                const node = this.dataset.node;
                document.getElementById('confirmPopup').classList.remove('active');
                this.dataset.node = null;
                if (!confirm || !node || node === 'FalseNode@webxos') {
                    if (node === 'FalseNode@webxos') {
                        ConsoleManager.logError('Cannot initiate merge: FalseNode@webxos is a diagnostic node and not selectable.');
                    }
                    return;
                }
                this.merge(node);
            },
            merge(node) {
                try {
                    if (!node || !node.includes('@webxos')) {
                        ConsoleManager.logError('Invalid node for merge');
                        return;
                    }
                    const data = { nodeId: node, timestamp: Date.now() };
                    const serial = NodeSync.generateSerial(this.nodeId);
                    const encrypted = NodeSync.encryptData(data, this.nodeId);
                    localStorage.setItem(serial, encrypted);
                    ConsoleManager.log(`Merged with ${node}, serial: ${serial}`);
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Verify merge process');
                }
            },
            _renderNodes(nodes) {
                this.dataset.node = null;
                const consoleOutput = document.getElementById('consoleOutput');
                const validNodes = nodes.filter(node => node !== 'FalseNode@webxos');
                const diagnosticNodes = nodes.filter(node => node === 'FalseNode@webxos');
                if (validNodes.length > 0) {
                    const validDiv = document.createElement('div');
                    validDiv.innerHTML = '<p>Discovered Nodes:</p>' + validNodes.map(node => `<p onclick="BluetoothMesh.showConfirmation('${node}')" style="cursor: pointer;">${node}</p>`).join('');
                    consoleOutput.appendChild(validDiv);
                }
                if (diagnosticNodes.length > 0) {
                    const diagDiv = document.createElement('div');
                    diagDiv.className = 'diagnostic-section';
                    diagDiv.innerHTML = '<p>Diagnostic Nodes:</p>' + diagnosticNodes.map(node => `<p class="non-interactive">${node} (diagnostic, non-selectable)</p>`).join('');
                    consoleOutput.appendChild(diagDiv);
                    ConsoleManager.log('FalseNode@webxos detected (diagnostic, non-selectable). Displayed in red in WebGL for diagnostics only. Select valid nodes under "Discovered Nodes" for merging.');
                }
                WebGLViz.renderNodes(nodes);
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }
        };

        // WebGLViz Module
        const WebGLViz = {
            gl: null,
            program: null,
            positionLoc: null,
            colorLoc: null,
            buffer: null,
            init() {
                try {
                    const canvas = document.getElementById('webglCanvas');
                    this.gl = canvas.getContext('webgl');
                    if (!this.gl) throw new Error('WebGL not supported');
                    const vertexShaderSrc = `
                        attribute vec2 a_position;
                        void main() {
                            gl_Position = vec4(a_position, 0.0, 1.0);
                            gl_PointSize = 10.0;
                        }
                    `;
                    const fragmentShaderSrc = `
                        precision mediump float;
                        uniform vec4 u_color;
                        void main() {
                            gl_FragColor = u_color;
                        }
                    `;
                    const vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
                    this.gl.shaderSource(vertexShader, vertexShaderSrc);
                    this.gl.compileShader(vertexShader);
                    if (!this.gl.getShaderParameter(vertexShader, this.gl.COMPILE_STATUS)) {
                        throw new Error('Vertex shader compilation failed: ' + this.gl.getShaderInfoLog(vertexShader));
                    }
                    const fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
                    this.gl.shaderSource(fragmentShader, fragmentShaderSrc);
                    this.gl.compileShader(fragmentShader);
                    if (!this.gl.getShaderParameter(fragmentShader, this.gl.COMPILE_STATUS)) {
                        throw new Error('Fragment shader compilation failed: ' + this.gl.getShaderInfoLog(fragmentShader));
                    }
                    this.program = this.gl.createProgram();
                    this.gl.attachShader(this.program, vertexShader);
                    this.gl.attachShader(this.program, fragmentShader);
                    this.gl.linkProgram(this.program);
                    if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
                        throw new Error('Program linking failed: ' + this.gl.getProgramInfoLog(this.program));
                    }
                    this.gl.useProgram(this.program);
                    this.positionLoc = this.gl.getAttribLocation(this.program, 'a_position');
                    this.colorLoc = this.gl.getUniformLocation(this.program, 'u_color');
                    this.buffer = this.gl.createBuffer();
                    ConsoleManager.log('WebGL initialized');
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Optimize WebGL context for low-end devices');
                    ConsoleManager.logError(e.message);
                }
            },
            renderNodes(nodes) {
                try {
                    if (!this.gl || !this.program) throw new Error('WebGL not initialized');
                    const maxNodes = window.innerWidth <= 600 ? 2 : 10;
                    const validNodes = nodes.filter(node => node !== 'FalseNode@webxos');
                    const diagnosticNodes = nodes.filter(node => node === 'FalseNode@webxos');
                    const positions = [];
                    const nodeTypes = [];
                    for (let i = 0; i < Math.min(validNodes.length, maxNodes); i++) {
                        positions.push(Math.random() * 2 - 1, Math.random() * 2 - 1);
                        nodeTypes.push('valid');
                    }
                    for (let i = 0; i < Math.min(diagnosticNodes.length, maxNodes - validNodes.length); i++) {
                        positions.push(Math.random() * 2 - 1, Math.random() * 2 - 1);
                        nodeTypes.push('diagnostic');
                    }
                    if (positions.length === 0) {
                        ConsoleManager.logError('No nodes to render in WebGL');
                        return;
                    }
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);
                    this.gl.enableVertexAttribArray(this.positionLoc);
                    this.gl.vertexAttribPointer(this.positionLoc, 2, this.gl.FLOAT, false, 0, 0);
                    this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
                    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
                    for (let i = 0; i < positions.length / 2; i++) {
                        const isDiagnostic = nodeTypes[i] === 'diagnostic';
                        this.gl.uniform4f(this.colorLoc, isDiagnostic ? 1.0 : 0.0, isDiagnostic ? 0.0 : 1.0, 0.0, 1.0);
                        this.gl.drawArrays(this.gl.POINTS, i, 1);
                    }
                    const canvas = document.getElementById('webglCanvas');
                    canvas.style.display = 'block';
                    setTimeout(() => { canvas.style.display = 'none'; }, 5000);
                    ConsoleManager.log(`Rendered ${positions.length / 2} nodes (valid: ${validNodes.length}, diagnostic: ${diagnosticNodes.length})`);
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Optimize WebGL rendering for mobile');
                    ConsoleManager.logError(e.message);
                }
            }
        };

        // WizardManager Module
        const WizardManager = {
            open() {
                document.getElementById('wizardPopup').classList.add('active');
                this.testConnectivity();
            },
            async testConnectivity() {
                const status = document.getElementById('connectivityStatus');
                try {
                    if (navigator.bluetooth && await navigator.bluetooth.getAvailability()) {
                        status.textContent = 'Bluetooth available';
                        ConsoleManager.log('Bluetooth connectivity: Available');
                    } else {
                        status.textContent = 'Bluetooth unavailable. Using diagnostic node.';
                        ConsoleManager.log('Bluetooth unavailable. Ensure HTTPS and check browser settings (e.g., Chrome: Settings > Privacy and security > Site settings > Bluetooth).');
                    }
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Verify Bluetooth connectivity');
                    status.textContent = 'Error checking connectivity';
                }
            },
            nextStep(step) {
                const nodeId = document.getElementById('nodeId').value;
                if (!nodeId || !nodeId.includes('@webxos')) {
                    ConsoleManager.logError('Invalid node ID');
                    return;
                }
                BluetoothMesh.setNodeId(nodeId);
                document.getElementById('wizardPopup').classList.remove('active');
                this.finalize(nodeId);
            },
            skip() {
                const nodeId = `guest${Math.floor(Math.random() * 1000)}@webxos`;
                BluetoothMesh.setNodeId(nodeId);
                document.getElementById('wizardPopup').classList.remove('active');
                this.finalize(nodeId);
            },
            finalize(nodeId) {
                ConsoleManager.log(`Setup complete for ${nodeId}. Use the 'Discover' button or type 'discover' to find nodes.`);
                ConsoleManager.log(`If offline, FalseNode@webxos will appear under 'Diagnostic Nodes' and in red in WebGL for diagnostics only. It cannot be selected.`);
                ConsoleManager.log(`Select a valid node by clicking its name under 'Discovered Nodes' to initiate a merge.`);
            }
        };

        // ConsoleManager Module
        const ConsoleManager = {
            log(message) {
                const consoleOutput = document.getElementById('consoleOutput');
                const p = document.createElement('p');
                p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                consoleOutput.appendChild(p);
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            },
            logError(message) {
                this.log(`ERROR: ${message}`);
            },
            execute() {
                const input = document.getElementById('commandInput');
                const command = input.value.trim().toLowerCase();
                input.value = '';
                if (command === 'discover') {
                    BluetoothMesh.discover();
                } else if (command === 'help') {
                    this.help();
                } else if (command === 'troubleshoot') {
                    Troubleshooter.check();
                } else {
                    this.logError('Unknown command. Type "help" for commands.');
                }
            },
            help() {
                this.log('Commands: discover, help, troubleshoot');
                this.log('Use "Discover" button or "discover" command to find nodes. FalseNode@webxos appears under "Diagnostic Nodes" and in red in WebGL when offline. It cannot be selected or merged with.');
                this.log('Click a valid node name under "Discovered Nodes" to merge.');
                this.log('Ensure HTTPS and Bluetooth are enabled for full functionality.');
            },
            handleCommand(event) {
                if (event.key === 'Enter') {
                    this.execute();
                }
            }
        };

        // Troubleshooter Module
        const Troubleshooter = {
            check() {
                this.checkBluetooth();
                this.checkDOM();
                this.checkStorage();
                this.checkWebGL();
                this.checkWASM();
            },
            checkError(error, suggestion) {
                ConsoleManager.logError(`${error.message} | Suggestion: ${suggestion}`);
            },
            async checkBluetooth() {
                try {
                    if (!navigator.bluetooth) throw new Error('Web Bluetooth not supported');
                    const available = await navigator.bluetooth.getAvailability();
                    if (!available) throw new Error('Bluetooth unavailable. Ensure HTTPS and check browser settings.');
                    ConsoleManager.log('Bluetooth check: Passed');
                } catch (e) {
                    this.checkError(e, 'Prompt LLM: Enable Web Bluetooth via HTTPS or browser settings (e.g., Chrome: Settings > Privacy and security > Site settings > Bluetooth)');
                }
            },
            checkDOM() {
                try {
                    const elements = ['consoleOutput', 'commandInput', 'wizardPopup', 'confirmPopup', 'webglCanvas', 'connectivityStatus', 'confirmYes'];
                    elements.forEach(id => {
                        if (!document.getElementById(id)) throw new Error(`Missing DOM element: ${id}`);
                    });
                    ConsoleManager.log('DOM check: Passed');
                } catch (e) {
                    this.checkError(e, 'Prompt LLM: Verify DOM structure');
                }
            },
            checkStorage() {
                try {
                    localStorage.setItem('test', 'test');
                    localStorage.removeItem('test');
                    ConsoleManager.log('Storage check: Passed');
                } catch (e) {
                    this.checkError(e, 'Prompt LLM: Check localStorage access');
                }
            },
            checkWebGL() {
                try {
                    const canvas = document.createElement('canvas');
                    if (!canvas.getContext('webgl')) throw new Error('WebGL not supported');
                    ConsoleManager.log('WebGL check: Passed');
                } catch (e) {
                    this.checkError(e, 'Prompt LLM: Enable WebGL in browser settings');
                }
            },
            checkWASM() {
                try {
                    if (typeof WebAssembly === 'undefined') throw new Error('WebAssembly not supported');
                    ConsoleManager.log('WebAssembly check: Passed');
                } catch (e) {
                    this.checkError(e, 'Prompt LLM: Enable WebAssembly in browser settings');
                }
            }
        };

        // Initialization
        window.addEventListener('load', () => {
            WebGLViz.init();
            WizardManager.open();
            document.getElementById('commandInput').addEventListener('keydown', (e) => ConsoleManager.handleCommand(e));
        });
    </script>
</body>
</html>
