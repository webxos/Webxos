<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Bluemesh 2025: Secure Bluetooth mesh networking with P2P messaging, WebGL visualization, and diagnostics via FalseNode@webxos. Offline mode supported with limited functionality.">
    <meta name="keywords" content="Bluemesh, Bluetooth Mesh, P2P Messaging, WebGL, WebAssembly, NodeSync, edge computing, secure networking">
    <meta name="author" content="WEBXOS Standardization">
    <meta name="robots" content="index, follow">
    <meta name="copyright" content="© 2025 WEBXOS Standardization">
    <title>Bluemesh 2025</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            background: black;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .console {
            flex-grow: 1;
            background: rgba(0, 0, 0, 0.8);
            text-shadow: 0 0 5px currentColor, 0 0 10px currentColor, 0 0 15px currentColor;
            overflow-y: auto;
            position: relative;
            font-size: 0.7em;
            line-height: 1.1;
            margin: 0 10px 5px 10px;
            padding: 5px;
            border: 1px solid currentColor;
        }
        .input-line {
            display: flex;
            margin-top: 10px;
            position: sticky;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1;
            padding: 5px;
        }
        .input-line input {
            background: transparent;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-size: inherit;
            font-family: inherit;
            flex-grow: 1;
            padding: 2px;
            text-shadow: 0 0 3px currentColor;
        }
        .input-line input:focus {
            outline: none;
            box-shadow: 0 0 5px #00ff00;
        }
        .input-line input::placeholder {
            color: #00ff00;
            opacity: 0.7;
        }
        .button-container {
            display: flex;
            flex-wrap: wrap;
            font-size: 0.8em;
            padding: 3px;
        }
        button {
            background: transparent;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: inherit;
            min-width: 120px;
            padding: 3px 6px;
            margin: 1px;
            cursor: pointer;
            text-shadow: 0 0 3px currentColor;
        }
        button:hover {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 5px currentColor;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        footer {
            text-align: center;
            font-size: 10px;
            height: 5px;
            text-shadow: 0 0 3px currentColor;
        }
        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid currentColor;
            padding: 10px;
            color: #00ff00;
            text-shadow: 0 0 3px currentColor;
        }
        .popup.active {
            display: block;
        }
        .diagnostic-section {
            margin-top: 10px;
            border-top: 1px dashed currentColor;
        }
        .error {
            color: #ff0000;
            text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000;
        }
        .clickable-node {
            cursor: pointer;
            text-decoration: underline;
        }
        .clickable-node:hover {
            color: #00cc00;
            text-shadow: 0 0 5px #00cc00, 0 0 10px #00cc00;
        }
        @media (max-width: 600px) {
            .console { font-size: 0.6em; }
            .button-container { font-size: 0.7em; }
            button { padding: 2px 4px; }
            .input-line input { font-size: 0.6em; }
            .popup { width: 90%; }
            footer { font-size: 0.6em; }
        }
    </style>
</head>
<body>
    <div id="consoleOutput" class="console"></div>
    <div class="input-line">
        <span>> </span>
        <input id="commandInput" type="text" placeholder="Enter command or message (e.g., user@webxos Hello!)" autofocus>
    </div>
    <div class="button-container">
        <button id="executeBtn">Execute</button>
        <button id="discoverBtn">Discover</button>
        <button id="troubleshootBtn">Troubleshoot</button>
    </div>
    <canvas id="webglCanvas" style="display: none;"></canvas>
    <div id="wizardPopup" class="popup">
        <h3>Setup Node ID</h3>
        <p>Enter your node ID (e.g., user@webxos):</p>
        <input id="nodeIdInput" type="text" placeholder="user@webxos">
        <button id="nextBtn">Next</button>
        <button id="skipBtn">Skip</button>
    </div>
    <div id="confirmPopup" class="popup">
        <h3>Confirm Merge</h3>
        <p id="confirmMessage"></p>
        <button id="confirmYesBtn">Yes</button>
        <button id="confirmNoBtn">No</button>
    </div>
    <footer>BLUEMESH v1.0.0 © 2025 WEBXOS Standardization, Tested: 08:20 AM EDT, July 13, 2025</footer>

    <script>
        // NodeSync Module
        const NodeSync = {
            XOR_VALUE: 0xFF,
            nodeKeys: new Map(),
            generateNodeKey(nodeId) {
                if (!this.nodeKeys.has(nodeId)) {
                    const key = Array(16).fill().map(() => String.fromCharCode(65 + Math.floor(Math.random() * 26))).join('');
                    this.nodeKeys.set(nodeId, key);
                }
                return this.nodeKeys.get(nodeId);
            },
            getNodeKey(nodeId) {
                return this.nodeKeys.get(nodeId) || this.generateNodeKey(nodeId);
            },
            validateDataSize(data) {
                const size = new Blob([JSON.stringify(data)]).size;
                if (size > 10 * 1024 * 1024) throw new Error("Data exceeds 10MB limit");
                return true;
            },
            compressData(data, nodeId) {
                const str = JSON.stringify(data);
                this.validateDataSize(data);
                return this._pakoDeflate(str);
            },
            decompressData(compressed, nodeId) {
                const str = this._pakoInflate(compressed);
                try {
                    return JSON.parse(str);
                } catch (e) {
                    throw new Error("Invalid JSON in decompressed data");
                }
            },
            encryptData(data, nodeId) {
                const str = JSON.stringify(data);
                this.validateDataSize(data);
                return this._aesEncrypt(str, this.getNodeKey(nodeId));
            },
            decryptData(encrypted, nodeId) {
                const str = this._aesDecrypt(encrypted, this.getNodeKey(nodeId));
                try {
                    return JSON.parse(str);
                } catch (e) {
                    throw new Error("Invalid JSON in decrypted data");
                }
            },
            encryptMessage(message, senderId, recipientId) {
                const data = { sender: senderId, message, timestamp: Date.now() };
                return this.encryptData(data, recipientId);
            },
            decryptMessage(encrypted, recipientId) {
                return this.decryptData(encrypted, recipientId);
            },
            generateSerial(nodeId) {
                return `WEBXOS-${Array(13).fill().map(() => String.fromCharCode(65 + Math.floor(Math.random() * 26))).join('')}`;
            },
            generateMessageSerial(nodeId) {
                return `WEBXOS-MSG-${Array(13).fill().map(() => String.fromCharCode(65 + Math.floor(Math.random() * 26))).join('')}`;
            },
            validateData(data) {
                try {
                    JSON.parse(JSON.stringify(data));
                    return true;
                } catch (e) {
                    throw new Error("Invalid JSON data");
                }
            },
            retrieveData(serial, nodeId) {
                const encrypted = localStorage.getItem(serial);
                if (!encrypted) throw new Error("Data not found");
                return this.decryptData(encrypted, nodeId);
            },
            encryptWASM(data, nodeId) {
                return this.encryptData(data, nodeId); // Placeholder for WASM
            },
            validateCompressionConfig() {
                const testData = { test: "data" };
                const compressed = this.compressData(testData, "test@webxos");
                const decompressed = this.decompressData(compressed, "test@webxos");
                return JSON.stringify(testData) === JSON.stringify(decompressed);
            },
            _pakoDeflate(str) {
                return Array.from(str).map(c => String.fromCharCode(c.charCodeAt(0) ^ this.XOR_VALUE)).join('');
            },
            _pakoInflate(compressed) {
                return Array.from(compressed).map(c => String.fromCharCode(c.charCodeAt(0) ^ this.XOR_VALUE)).join('');
            },
            _aesEncrypt(data, key) {
                return Array.from(data).map((c, i) => String.fromCharCode(c.charCodeAt(0) ^ key.charCodeAt(i % key.length))).join('');
            },
            _aesDecrypt(encrypted, key) {
                return Array.from(encrypted).map((c, i) => String.fromCharCode(c.charCodeAt(0) ^ key.charCodeAt(i % key.length))).join('');
            }
        };

        // BluetoothMesh Module
        const BluetoothMesh = {
            nodeId: null,
            isOffline: !navigator.bluetooth,
            connectedNode: null,
            setNodeId(id) {
                const sanitized = id.replace(/[<>]/g, '');
                if (!sanitized.match(/^[a-zA-Z0-9]+@webxos$/)) throw new Error("Invalid node ID format");
                this.nodeId = sanitized;
            },
            discover() {
                if (this.isOffline) {
                    ConsoleManager.logError("Web Bluetooth unavailable: Running in offline mode. Discovery disabled.");
                    ConsoleManager.log("Diagnostic Nodes: <span class='clickable-node' data-node='FalseNode@webxos'>FalseNode@webxos</span>");
                    return;
                }
                ConsoleManager.log("Discovering networks...");
                const nodes = ["FalseNode@webxos", ...this.getUserNodesFromMessages()];
                this._renderNodes(nodes);
                WebGLViz.renderNodes(nodes);
                this.receiveMessages();
            },
            testNodeConnectivity(node) {
                if (this.isOffline) throw new Error("Bluetooth unavailable: Device offline");
                // Simulate connectivity check
                return true;
            },
            getUserNodesFromMessages() {
                const nodes = new Set();
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith("WEBXOS-MSG-")) {
                        try {
                            const msg = NodeSync.decryptMessage(localStorage.getItem(key), this.nodeId);
                            if (msg.sender !== this.nodeId) nodes.add(msg.sender);
                        } catch (e) {}
                    }
                }
                return Array.from(nodes);
            },
            sendMessage(recipientId, message) {
                const sanitized = message.replace(/[<>]/g, '');
                const serial = NodeSync.generateMessageSerial(this.nodeId);
                const encrypted = NodeSync.encryptMessage(sanitized, this.nodeId, recipientId);
                localStorage.setItem(serial, encrypted);
                ConsoleManager.log(`[${new Date().toLocaleTimeString()}] Message sent to <span class='clickable-node' data-node='${recipientId}'>${recipientId}</span>: ${sanitized}`);
                if (!this.isOffline) this._renderNodes(["FalseNode@webxos", ...this.getUserNodesFromMessages()]);
            },
            receiveMessages() {
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith("WEBXOS-MSG-")) {
                        try {
                            const msg = NodeSync.decryptMessage(localStorage.getItem(key), this.nodeId);
                            if (msg.sender !== this.nodeId) {
                                ConsoleManager.log(`[${new Date(msg.timestamp).toLocaleTimeString()}] Message from <span class='clickable-node' data-node='${msg.sender}'>${msg.sender}</span>: ${msg.message}`);
                            }
                        } catch (e) {}
                    }
                }
            },
            toggleConnection(node, forceConnect = false) {
                if (node === this.connectedNode && !forceConnect) {
                    ConsoleManager.log(`Disconnected from <span class='clickable-node' data-node='${node}'>${node}</span>`);
                    this.connectedNode = null;
                } else {
                    this.connectedNode = node;
                    ConsoleManager.log(`Connected to <span class='clickable-node' data-node='${node}'>${node}</span>`);
                    if (node === "FalseNode@webxos") Troubleshooter.falseNodeTroubleshoot();
                }
            },
            showConfirmation(node) {
                if (node === "FalseNode@webxos") {
                    ConsoleManager.logError("Merging with FalseNode@webxos is not allowed.");
                    return;
                }
                document.getElementById("confirmMessage").textContent = `Merge with ${node}?`;
                document.getElementById("confirmPopup").classList.add("active");
            },
            confirmMerge(confirm) {
                document.getElementById("confirmPopup").classList.remove("active");
                if (confirm) {
                    this.merge(this.connectedNode);
                }
            },
            merge(node) {
                if (node === "FalseNode@webxos") return;
                const serial = NodeSync.generateSerial(node);
                const data = { node, timestamp: Date.now() };
                localStorage.setItem(serial, NodeSync.encryptData(data, node));
                ConsoleManager.log(`Merged with ${node}. Serial: ${serial}`);
            },
            _renderNodes(nodes) {
                const diagnostic = nodes.includes("FalseNode@webxos") ? ["FalseNode@webxos"] : [];
                const others = nodes.filter(n => n !== "FalseNode@webxos");
                if (diagnostic.length) {
                    ConsoleManager.log(`Diagnostic Nodes: ${diagnostic.map(n => `<span class='clickable-node' data-node='${n}'>${n}</span>`).join(", ")}`, true);
                }
                if (others.length) {
                    ConsoleManager.log(`Discovered Nodes: ${others.map(n => `<span class='clickable-node' data-node='${n}'>${n}</span>`).join(", ")}`, true);
                }
            }
        };

        // WebGLViz Module
        const WebGLViz = {
            gl: null,
            program: null,
            init() {
                const canvas = document.getElementById("webglCanvas");
                this.gl = canvas.getContext("webgl");
                if (!this.gl) throw new Error("WebGL not supported");
                const vsSource = `
                    attribute vec4 position;
                    void main() {
                        gl_Position = position;
                        gl_PointSize = 10.0;
                    }
                `;
                const fsSource = `
                    precision mediump float;
                    uniform vec4 color;
                    void main() {
                        gl_FragColor = color;
                    }
                `;
                const vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
                this.gl.shaderSource(vertexShader, vsSource);
                this.gl.compileShader(vertexShader);
                const fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
                this.gl.shaderSource(fragmentShader, fsSource);
                this.gl.compileShader(fragmentShader);
                this.program = this.gl.createProgram();
                this.gl.attachShader(this.program, vertexShader);
                this.gl.attachShader(this.program, fragmentShader);
                this.gl.linkProgram(this.program);
                this.gl.useProgram(this.program);
            },
            validateRenderConfig(nodes) {
                if (!Array.isArray(nodes)) throw new Error("Nodes must be an array");
                if (!this.gl || !this.program) throw new Error("WebGL not initialized");
                return true;
            },
            renderNodes(nodes) {
                this.validateRenderConfig(nodes);
                const canvas = document.getElementById("webglCanvas");
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight / 2;
                canvas.style.display = "block";
                this.gl.viewport(0, 0, canvas.width, canvas.height);
                this.gl.clearColor(0, 0, 0, 1);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT);
                const maxNodes = window.innerWidth <= 600 || navigator.hardwareConcurrency < 4 ? 2 : 10;
                const renderNodes = nodes.slice(0, maxNodes);
                const positions = new Float32Array(renderNodes.length * 2);
                renderNodes.forEach((node, i) => {
                    positions[i * 2] = (Math.random() - 0.5) * 2;
                    positions[i * 2 + 1] = (Math.random() - 0.5) * 2;
                });
                const buffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);
                const positionLocation = this.gl.getAttribLocation(this.program, "position");
                this.gl.enableVertexAttribArray(positionLocation);
                this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
                const colorLocation = this.gl.getUniformLocation(this.program, "color");
                renderNodes.forEach((node, i) => {
                    const color = node === "FalseNode@webxos" ? [1, 0, 0, 1] : [0, 1, 0, 1];
                    this.gl.uniform4fv(colorLocation, color);
                    this.gl.drawArrays(this.gl.POINTS, i, 1);
                });
                setTimeout(() => canvas.style.display = "none", 5000);
            }
        };

        // WizardManager Module
        const WizardManager = {
            isOffline: !navigator.bluetooth,
            open() {
                document.getElementById("wizardPopup").classList.add("active");
                this.testConnectivity();
            },
            testConnectivity() {
                this.isOffline = !navigator.bluetooth;
                ConsoleManager.log(this.isOffline ?
                    "Web Bluetooth unavailable: Running in offline mode. Limited functionality (no discovery or real-time messaging). Connect to <span class='clickable-node' data-node='FalseNode@webxos'>FalseNode@webxos</span> for diagnostics and help." :
                    "Bluetooth online: Adapter active.", this.isOffline);
                document.getElementById("discoverBtn").disabled = this.isOffline;
            },
            nextStep() {
                const nodeId = document.getElementById("nodeIdInput").value.trim();
                try {
                    BluetoothMesh.setNodeId(nodeId);
                    this.finalize(nodeId);
                } catch (e) {
                    ConsoleManager.logError(`Node ID setup failed: ${e.message}`);
                }
            },
            skip() {
                const guestId = `guest${Math.random().toString(36).slice(2, 10)}@webxos`;
                BluetoothMesh.setNodeId(guestId);
                this.finalize(guestId);
            },
            finalize(nodeId) {
                document.getElementById("wizardPopup").classList.remove("active");
                ConsoleManager.log(`Node ID set to <span class='clickable-node' data-node='${nodeId}'>${nodeId}</span>. Use the console to:`);
                ConsoleManager.log("- Type 'discover' to find nodes.");
                ConsoleManager.log("- Type '<user@webxos> message' to send messages (e.g., user@webxos Hello!).");
                ConsoleManager.log("- Click <span class='clickable-node' data-node='FalseNode@webxos'>FalseNode@webxos</span> or user nodes to connect/disconnect.");
                ConsoleManager.log("- Use 'troubleshoot' or Troubleshoot button for diagnostics.");
                if (this.isOffline) {
                    ConsoleManager.logError("Offline mode: Discovery disabled. Connect to <span class='clickable-node' data-node='FalseNode@webxos'>FalseNode@webxos</span> for diagnostics.");
                }
            }
        };

        // ConsoleManager Module
        const ConsoleManager = {
            verbose: false,
            awaitingTroubleshootResponse: false,
            log(message, isDiagnostic = false) {
                const output = document.getElementById("consoleOutput");
                const div = document.createElement("div");
                div.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
                if (isDiagnostic) div.classList.add("diagnostic-section");
                output.insertBefore(div, output.querySelector(".input-line"));
                output.scrollTop = output.scrollHeight;
                this._makeNodesClickable(div);
                document.getElementById("commandInput").focus();
            },
            logError(message) {
                const output = document.getElementById("consoleOutput");
                const div = document.createElement("div");
                div.classList.add("error");
                div.innerHTML = `[${new Date().toLocaleTimeString()}] Error: ${message}`;
                output.insertBefore(div, output.querySelector(".input-line"));
                output.scrollTop = output.scrollHeight;
                this._makeNodesClickable(div);
                document.getElementById("commandInput").focus();
            },
            logVerbose(message) {
                if (this.verbose) this.log(message);
            },
            execute() {
                const input = document.getElementById("commandInput");
                const value = input.value.trim();
                input.value = "";
                if (!value) return;
                if (this.awaitingTroubleshootResponse) {
                    this.handleTroubleshootResponse(value);
                    return;
                }
                try {
                    if (value === "discover") {
                        BluetoothMesh.discover();
                    } else if (value === "troubleshoot") {
                        Troubleshooter.check();
                    } else if (value === "verbose") {
                        this.verbose = !this.verbose;
                        this.log(`Verbose mode ${this.verbose ? "enabled" : "disabled"}`);
                    } else if (value.match(/^[a-zA-Z0-9]+@webxos\s+.+$/)) {
                        const [recipient, ...msgParts] = value.split(" ");
                        const message = msgParts.join(" ");
                        BluetoothMesh.sendMessage(recipient, message);
                    } else {
                        this.logError("Invalid command or message format. Use 'discover', 'troubleshoot', 'verbose', or '<user@webxos> message'.");
                    }
                } catch (e) {
                    Troubleshooter.checkError(e, "Check command syntax or connectivity.");
                }
            },
            handleTroubleshootResponse(response) {
                this.awaitingTroubleshootResponse = false;
                if (response.toLowerCase() === "y") {
                    Troubleshooter.check();
                } else if (response.toLowerCase() === "n") {
                    ConsoleManager.log("Troubleshooting ended.");
                } else {
                    ConsoleManager.logError("Invalid response. Please enter 'y' or 'n'.");
                    ConsoleManager.log("Do you need more help? (y/n)");
                    this.awaitingTroubleshootResponse = true;
                }
            },
            handleCommand(event) {
                if (event.key === "Enter") this.execute();
            },
            _makeNodesClickable(element) {
                const nodes = element.querySelectorAll(".clickable-node");
                nodes.forEach(node => {
                    node.addEventListener("click", () => {
                        const nodeId = node.dataset.node;
                        this.awaitingTroubleshootResponse = false;
                        BluetoothMesh.toggleConnection(nodeId);
                    });
                });
            }
        };

        // Troubleshooter Module
        const Troubleshooter = {
            check() {
                if (BluetoothMesh.connectedNode && BluetoothMesh.connectedNode !== "FalseNode@webxos") {
                    ConsoleManager.log("Redirecting to FalseNode@webxos for diagnostics...");
                    BluetoothMesh.toggleConnection("FalseNode@webxos", true);
                    return;
                }
                try {
                    this.checkJavaScriptSyntax();
                    this.checkBluetooth();
                    this.checkDOM();
                    this.checkStorage();
                    this.checkWebGL();
                    this.checkWASM();
                    if (!NodeSync.validateCompressionConfig()) {
                        throw new Error("Compression configuration invalid");
                    }
                    ConsoleManager.log("Diagnostics completed successfully.");
                    if (BluetoothMesh.connectedNode === "FalseNode@webxos") {
                        this.falseNodeTroubleshoot();
                    }
                } catch (e) {
                    this.checkError(e, "Run diagnostics again or check browser settings.");
                }
            },
            checkError(error, suggestion) {
                ConsoleManager.logError(`${error.message}. Suggestion: ${suggestion}`);
                if (BluetoothMesh.connectedNode === "FalseNode@webxos") {
                    this.falseNodeTroubleshoot();
                }
            },
            checkJavaScriptSyntax() {
                try {
                    new Function("let x = 1; return x;")();
                } catch (e) {
                    throw new Error("JavaScript syntax check failed");
                }
            },
            checkBluetooth() {
                if (!navigator.bluetooth) {
                    throw new Error("Web Bluetooth unavailable: Device offline or disabled. Ensure HTTPS, enable device Bluetooth, and check browser settings (e.g., Chrome: Settings > Privacy and security > Site settings > Bluetooth).");
                }
                ConsoleManager.log("Bluetooth online: Adapter active.");
            },
            checkDOM() {
                const elements = ["consoleOutput", "commandInput", "webglCanvas", "wizardPopup", "confirmPopup"];
                elements.forEach(id => {
                    if (!document.getElementById(id)) throw new Error(`DOM element ${id} missing`);
                });
            },
            checkStorage() {
                try {
                    localStorage.setItem("test", "test");
                    localStorage.removeItem("test");
                } catch (e) {
                    throw new Error("localStorage unavailable");
                }
            },
            checkWebGL() {
                const canvas = document.createElement("canvas");
                if (!canvas.getContext("webgl")) throw new Error("WebGL not supported");
            },
            checkWASM() {
                if (typeof WebAssembly === "undefined") throw new Error("WebAssembly not supported");
            },
            falseNodeTroubleshoot() {
                ConsoleManager.log("FalseNode@webxos: Connectivity issues? Ensure HTTPS is used and Bluetooth is enabled on your device. Check browser settings (e.g., Chrome: Settings > Privacy and security > Site settings > Bluetooth).");
                ConsoleManager.log("FalseNode@webxos: Invalid node ID or message format? Use @webxos for node IDs (e.g., user@webxos) and <user@webxos> message for messages (e.g., user@webxos Hello!).");
                ConsoleManager.log("Do you need more help? (y/n)");
                ConsoleManager.awaitingTroubleshootResponse = true;
            }
        };

        // Service Worker Cache (Offline Support)
        if ("caches" in window) {
            caches.open("bluemesh-cache").then(cache => {
                cache.add("/").then(() => {
                    ConsoleManager.logVerbose("Cache initialized for offline support.");
                }).catch(e => {
                    ConsoleManager.logError(`Cache failed: ${e.message}`);
                });
            });
        }

        // Event Listeners
        window.addEventListener("load", () => {
            if (!navigator.bluetooth) {
                ConsoleManager.logError("Web Bluetooth unavailable: Running in offline mode. Limited functionality (no discovery or real-time messaging). Connect to <span class='clickable-node' data-node='FalseNode@webxos'>FalseNode@webxos</span> for diagnostics and help.");
                document.getElementById("discoverBtn").disabled = true;
            }
            WebGLViz.init();
            WizardManager.open();
        });

        document.getElementById("executeBtn").addEventListener("click", () => ConsoleManager.execute());
        document.getElementById("discoverBtn").addEventListener("click", () => BluetoothMesh.discover());
        document.getElementById("troubleshootBtn").addEventListener("click", () => Troubleshooter.check());
        document.getElementById("nextBtn").addEventListener("click", () => WizardManager.nextStep());
        document.getElementById("skipBtn").addEventListener("click", () => WizardManager.skip());
        document.getElementById("confirmYesBtn").addEventListener("click", () => BluetoothMesh.confirmMerge(true));
        document.getElementById("confirmNoBtn").addEventListener("click", () => BluetoothMesh.confirmMerge(false));
        document.getElementById("commandInput").addEventListener("keydown", e => ConsoleManager.handleCommand(e));
    </script>
</body>
</html>
