<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Bluemesh 2025: Secure Bluetooth mesh networking for edge devices with WebGL visualization and AI-driven diagnostics.">
    <meta name="keywords" content="Bluemesh, Bluetooth Mesh, WebGL, WebAssembly, NodeSync, edge computing, secure networking">
    <meta name="author" content="WEBXOS Standardization">
    <meta name="robots" content="index, follow">
    <meta name="copyright" content="© 2025 WEBXOS Standardization">
    <title>Bluemesh 2025</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background: black;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .console {
            flex-grow: 1;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid currentColor;
            padding: 5px;
            margin: 0 10px 5px 10px;
            font-size: 0.7em;
            line-height: 1.1;
            text-shadow: 0 0 5px currentColor, 0 0 10px currentColor, 0 0 15px currentColor;
            overflow-y: auto;
        }
        .button-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            padding: 3px;
            font-size: 0.8em;
        }
        button {
            background: transparent;
            border: 1px solid currentColor;
            color: currentColor;
            padding: 3px 6px;
            margin: 1px;
            min-width: 120px;
            text-shadow: 0 0 3px currentColor, 0 0 6px currentColor;
            cursor: pointer;
        }
        button:hover {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 5px currentColor;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        footer {
            text-align: center;
            font-size: 10px;
            text-shadow: 0 0 3px currentColor;
            height: 5px;
        }
        .input-line {
            display: flex;
            align-items: center;
        }
        .input-line p {
            margin: 0 5px 0 0;
        }
        .input-line input {
            background: transparent;
            border: none;
            color: currentColor;
            font-family: inherit;
            font-size: inherit;
            flex-grow: 1;
        }
        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid currentColor;
            padding: 10px;
        }
        .popup.active {
            display: block;
        }
        .non-interactive {
            cursor: default;
            opacity: 0.7;
        }
        .diagnostic-section {
            margin-top: 10px;
            border-top: 1px dashed currentColor;
        }
        @media (max-width: 600px) {
            .console { font-size: 0.6em; }
            .button-container { font-size: 0.7em; }
            button { padding: 2px 4px; }
            .input-line input { font-size: 0.6em; }
            .popup { width: 90%; }
            footer { font-size: 0.6em; }
        }
    </style>
</head>
<body>
    <div class="console" id="consoleOutput">
        <p>Bluemesh 2025</p>
        <p>Secure Bluetooth Mesh Networking</p>
        <div class="input-line">
            <p>> </p>
            <input type="text" id="commandInput" placeholder="Enter command..." onkeydown="ConsoleManager.handleCommand(event)">
        </div>
    </div>
    <canvas id="webglCanvas" style="display: none;"></canvas>
    <div class="button-container">
        <button onclick="ConsoleManager.execute()">Execute</button>
        <button onclick="BluetoothMesh.discover()">Discover</button>
        <button onclick="ConsoleManager.help()">Help</button>
        <button onclick="Troubleshooter.check()">Troubleshoot</button>
    </div>
    <div id="wizardPopup" class="popup">
        <div id="step1" class="wizard-step active">
            <p>Step 1: Set Node ID</p>
            <p id="connectivityStatus">Checking connectivity...</p>
            <input type="text" id="nodeId" placeholder="Enter node ID (e.g., alice@webxos)">
            <button onclick="WizardManager.nextStep(1)">Next</button>
            <button onclick="WizardManager.skip()">Skip</button>
        </div>
    </div>
    <div id="confirmPopup" class="popup">
        <p id="confirmMessage"></p>
        <button id="confirmYes" onclick="BluetoothMesh.confirmMerge(true)">Yes</button>
        <button onclick="BluetoothMesh.confirmMerge(false)">No</button>
    </div>
    <footer>BLUEMESH v1.0.0 © 2025 WEBXOS Standardization, Tested: 06:06 AM EDT, July 13, 2025</footer>
    <script>
        // Cache API Workaround
        if ('caches' in window) {
            const CACHE_NAME = 'bluemesh-cache-v1';
            window.addEventListener('load', async () => {
                try {
                    const cache = await caches.open(CACHE_NAME);
                    await cache.addAll(['/']);
                    ConsoleManager.log('Cache initialized');
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Verify Cache API initialization');
                }
            });
            const originalFetch = window.fetch;
            window.fetch = async (...args) => {
                try {
                    const cache = await caches.open(CACHE_NAME);
                    const cachedResponse = await cache.match(args[0]);
                    return cachedResponse || originalFetch(...args);
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Verify Cache API fetch handling');
                    return originalFetch(...args);
                }
            };
        }

        const NodeSync = {
            nodeKeys: new Map(),
            XOR_VALUE: 0xFF,
            generateNodeKey(nodeId) {
                if (!this.nodeKeys.has(nodeId)) {
                    const key = Array(16).fill().map(() => String.fromCharCode(65 + Math.floor(Math.random() * 26))).join('');
                    this.nodeKeys.set(nodeId, key);
                    return key;
                }
                return this.nodeKeys.get(nodeId);
            },
            getNodeKey(nodeId) {
                return this.nodeKeys.has(nodeId) ? this.nodeKeys.get(nodeId) : this.generateNodeKey(nodeId);
            },
            validateDataSize(data) {
                const size = new TextEncoder().encode(JSON.stringify(data)).length;
                if (size > 10 * 1024 * 1024) {
                    throw new Error(`Data exceeds 10MB limit: ${size} bytes`);
                }
                return true;
            },
            compressData(data, nodeId) {
                if (!this.validateData(data)) throw new Error('Invalid JSON for node: ' + nodeId);
                this.validateDataSize(data);
                const str = JSON.stringify(data);
                return this._pakoDeflate(str);
            },
            decompressData(compressed, nodeId) {
                const decompressed = this._pakoInflate(compressed);
                if (!this.validateData(decompressed)) throw new Error('Invalid decompressed JSON for node: ' + nodeId);
                return JSON.parse(decompressed);
            },
            encryptData(data, nodeId) {
                const key = this.getNodeKey(nodeId);
                return this._aesEncrypt(data, key);
            },
            decryptData(encrypted, nodeId) {
                const key = this.getNodeKey(nodeId);
                return this._aesDecrypt(encrypted, key);
            },
            generateSerial(nodeId) {
                return `WEBXOS-${Array(13).fill().map(() => String.fromCharCode(65 + Math.floor(Math.random() * 26))).join('')}`;
            },
            validateData(data) {
                try {
                    JSON.parse(JSON.stringify(data));
                    return true;
                } catch {
                    return false;
                }
            },
            retrieveData(serial, nodeId) {
                const encrypted = localStorage.getItem(serial);
                if (!encrypted) throw new Error('No data found for serial: ' + serial);
                const decrypted = this.decryptData(encrypted, nodeId);
                return this.decompressData(decrypted, nodeId);
            },
            encryptWASM(data, nodeId) {
                return this.encryptData(data, nodeId);
            },
            validateCompressionConfig() {
                try {
                    const testStr = 'test';
                    const compressed = this._pakoDeflate(testStr);
                    const decompressed = this._pakoInflate(compressed);
                    if (testStr !== decompressed) {
                        throw new Error('Compression configuration mismatch');
                    }
                    ConsoleManager.log('Compression configuration validated');
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Verify compression XOR value');
                }
            },
            _pakoDeflate(str) {
                let compressed = '';
                for (let i = 0; i < str.length; i++) {
                    compressed += String.fromCharCode(str.charCodeAt(i) ^ this.XOR_VALUE);
                }
                return compressed;
            },
            _pakoInflate(compressed) {
                let decompressed = '';
                for (let i = 0; i < compressed.length; i++) {
                    decompressed += String.fromCharCode(compressed.charCodeAt(i) ^ this.XOR_VALUE);
                }
                return decompressed;
            },
            _aesEncrypt(data, key) {
                let encrypted = '';
                for (let i = 0; i < data.length; i++) {
                    encrypted += String.fromCharCode(data.charCodeAt(i) ^ key.charCodeAt(i % key.length));
                }
                return encrypted;
            },
            _aesDecrypt(encrypted, key) {
                let decrypted = '';
                for (let i = 0; i < encrypted.length; i++) {
                    decrypted += String.fromCharCode(encrypted.charCodeAt(i) ^ key.charCodeAt(i % key.length));
                }
                return decrypted;
            }
        };

        const BluetoothMesh = {
            nodeId: null,
            dataset: { node: null },
            setNodeId(id) {
                const sanitizedId = id.replace(/[<>]/g, '');
                if (!sanitizedId || !sanitizedId.includes('@webxos')) {
                    ConsoleManager.logError('Node ID is empty or invalid');
                    return false;
                }
                this.nodeId = sanitizedId;
                NodeSync.generateNodeKey(sanitizedId);
                ConsoleManager.log(`Node ID set to ${sanitizedId}`);
                return true;
            },
            async discover() {
                if (!this.nodeId) {
                    ConsoleManager.logError('Set node ID before discovery');
                    return;
                }
                try {
                    const nodes = navigator.bluetooth ? ['alice@webxos', 'bob@webxos'] : ['FalseNode@webxos'];
                    for (const node of nodes) {
                        await this.testNodeConnectivity(node);
                    }
                    if (nodes.includes('FalseNode@webxos')) {
                        ConsoleManager.log('FalseNode@webxos detected (diagnostic, non-selectable). Displayed in red in WebGL for diagnostics only. Select valid nodes under "Discovered Nodes" for merging.');
                    }
                    this._renderNodes(nodes);
                    WebGLViz.renderNodes(nodes);
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Verify Bluetooth discovery');
                    ConsoleManager.logError(e.message);
                }
            },
            async testNodeConnectivity(node) {
                try {
                    if (!navigator.bluetooth) {
                        throw new Error(`No connectivity for ${node}: Web Bluetooth unavailable`);
                    }
                    ConsoleManager.logVerbose(`Connectivity check passed for ${node}`);
                } catch (e) {
                    ConsoleManager.logError(e.message);
                }
            },
            showConfirmation(node) {
                const sanitizedNode = node.replace(/[<>]/g, '');
                if (!sanitizedNode || !sanitizedNode.includes('@webxos')) {
                    ConsoleManager.logError('No valid node selected for merge. Select a node from the discovered list.');
                    return;
                }
                if (sanitizedNode === 'FalseNode@webxos') {
                    ConsoleManager.logError('Offline mode: FalseNode@webxos detected. Web Bluetooth unavailable. Ensure HTTPS, enable device Bluetooth, and check browser settings (e.g., Chrome: Settings > Privacy and security > Site settings > Bluetooth).');
                    document.getElementById('confirmYes').disabled = true;
                } else {
                    document.getElementById('confirmYes').disabled = false;
                }
                this.dataset.node = sanitizedNode;
                document.getElementById('confirmMessage').textContent = `Merge with ${sanitizedNode}?`;
                document.getElementById('confirmPopup').classList.add('active');
            },
            confirmMerge(confirm) {
                const node = this.dataset.node;
                if (!confirm || !node || !node.includes('@webxos')) {
                    ConsoleManager.logError('No valid node selected for merge. Select a node from the discovered list.');
                    this.dataset.node = null;
                    document.getElementById('confirmPopup').classList.remove('active');
                    return;
                }
                if (node === 'FalseNode@webxos') {
                    ConsoleManager.logError('Cannot initiate merge: FalseNode@webxos is a diagnostic node and not selectable.');
                    this.dataset.node = null;
                    document.getElementById('confirmPopup').classList.remove('active');
                    return;
                }
                this.merge(node);
                this.dataset.node = null;
                document.getElementById('confirmPopup').classList.remove('active');
            },
            merge(node) {
                try {
                    const data = { nodeId: node, timestamp: Date.now() };
                    const compressed = NodeSync.compressData(data, this.nodeId);
                    const encrypted = NodeSync.encryptData(compressed, this.nodeId);
                    const serial = NodeSync.generateSerial(this.nodeId);
                    localStorage.setItem(serial, encrypted);
                    ConsoleManager.log(`Merged with ${node}, serial: ${serial}`);
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Verify merge encryption');
                    ConsoleManager.logError(e.message);
                }
            },
            _renderNodes(nodes) {
                this.dataset.node = null;
                const consoleOutput = document.getElementById('consoleOutput');
                const validNodes = nodes.filter(node => node !== 'FalseNode@webxos');
                const diagnosticNodes = nodes.filter(node => node === 'FalseNode@webxos');
                if (validNodes.length > 0) {
                    const validDiv = document.createElement('div');
                    validDiv.innerHTML = '<p>Discovered Nodes:</p>' + validNodes.map(node => `<p style="cursor: pointer;" onclick="BluetoothMesh.showConfirmation('${node.replace(/[<>]/g, '')}')">${node}</p>`).join('');
                    consoleOutput.appendChild(validDiv);
                }
                if (diagnosticNodes.length > 0) {
                    const diagDiv = document.createElement('div');
                    diagDiv.className = 'diagnostic-section';
                    diagDiv.innerHTML = '<p>Diagnostic Nodes:</p>' + diagnosticNodes.map(node => `<p class="non-interactive">${node} (diagnostic, non-selectable)</p>`).join('');
                    consoleOutput.appendChild(diagDiv);
                    ConsoleManager.log('FalseNode@webxos detected (diagnostic, non-selectable). Displayed in red in WebGL for diagnostics only. Select valid nodes under "Discovered Nodes" for merging.');
                }
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }
        };

        const WebGLViz = {
            gl: null,
            program: null,
            positionLoc: null,
            colorLoc: null,
            buffer: null,
            init() {
                try {
                    const canvas = document.getElementById('webglCanvas');
                    this.gl = canvas.getContext('webgl');
                    if (!this.gl) throw new Error('WebGL not supported');
                    const vertexShaderSrc = `
                        attribute vec2 a_position;
                        void main() {
                            gl_Position = vec4(a_position, 0.0, 1.0);
                            gl_PointSize = 10.0;
                        }
                    `;
                    const fragmentShaderSrc = `
                        precision mediump float;
                        uniform vec4 u_color;
                        void main() {
                            gl_FragColor = u_color;
                        }
                    `;
                    const vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
                    this.gl.shaderSource(vertexShader, vertexShaderSrc);
                    this.gl.compileShader(vertexShader);
                    if (!this.gl.getShaderParameter(vertexShader, this.gl.COMPILE_STATUS)) {
                        throw new Error('Vertex shader compilation failed: ' + this.gl.getShaderInfoLog(vertexShader));
                    }
                    const fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
                    this.gl.shaderSource(fragmentShader, fragmentShaderSrc);
                    this.gl.compileShader(fragmentShader);
                    if (!this.gl.getShaderParameter(fragmentShader, this.gl.COMPILE_STATUS)) {
                        throw new Error('Fragment shader compilation failed: ' + this.gl.getShaderInfoLog(fragmentShader));
                    }
                    this.program = this.gl.createProgram();
                    this.gl.attachShader(this.program, vertexShader);
                    this.gl.attachShader(this.program, fragmentShader);
                    this.gl.linkProgram(this.program);
                    if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
                        throw new Error('Program linking failed: ' + this.gl.getProgramInfoLog(this.program));
                    }
                    this.gl.useProgram(this.program);
                    this.positionLoc = this.gl.getAttribLocation(this.program, 'a_position');
                    this.colorLoc = this.gl.getUniformLocation(this.program, 'u_color');
                    this.buffer = this.gl.createBuffer();
                    ConsoleManager.log('WebGL initialized');
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Optimize WebGL context for low-end devices');
                    ConsoleManager.logError(e.message);
                }
            },
            validateRenderConfig(nodes) {
                if (!Array.isArray(nodes)) {
                    throw new Error('Invalid node array for rendering');
                }
                if (!document.getElementById('webglCanvas')) {
                    throw new Error('WebGL canvas element missing');
                }
                if (!this.gl || !this.program) {
                    throw new Error('WebGL not initialized');
                }
                return true;
            },
            renderNodes(nodes) {
                try {
                    this.validateRenderConfig(nodes);
                    const isLowEndDevice = window.innerWidth <= 600 || !navigator.hardwareConcurrency || navigator.hardwareConcurrency < 4;
                    const maxNodes = isLowEndDevice ? 2 : 10;
                    const validNodes = nodes.filter(node => node !== 'FalseNode@webxos');
                    const diagnosticNodes = nodes.filter(node => node === 'FalseNode@webxos');
                    const positions = [];
                    const nodeTypes = [];
                    for (let i = 0; i < Math.min(validNodes.length, maxNodes); i++) {
                        positions.push(Math.random() * 2 - 1, Math.random() * 2 - 1);
                        nodeTypes.push('valid');
                    }
                    for (let i = 0; i < Math.min(diagnosticNodes.length, maxNodes - validNodes.length); i++) {
                        positions.push(Math.random() * 2 - 1, Math.random() * 2 - 1);
                        nodeTypes.push('diagnostic');
                    }
                    if (positions.length === 0) {
                        ConsoleManager.logError('No nodes to render in WebGL');
                        return;
                    }
                    if (nodeTypes.length !== positions.length / 2) {
                        throw new Error('Mismatch between node types and positions');
                    }
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);
                    this.gl.enableVertexAttribArray(this.positionLoc);
                    this.gl.vertexAttribPointer(this.positionLoc, 2, this.gl.FLOAT, false, 0, 0);
                    this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
                    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
                    for (let i = 0; i < positions.length / 2; i++) {
                        const isDiagnostic = nodeTypes[i] === 'diagnostic';
                        this.gl.uniform4f(this.colorLoc, isDiagnostic ? 1.0 : 0.0, isDiagnostic ? 0.0 : 1.0, 0.0, 1.0);
                        this.gl.drawArrays(this.gl.POINTS, i, 1);
                    }
                    const canvas = document.getElementById('webglCanvas');
                    canvas.style.display = 'block';
                    setTimeout(() => { canvas.style.display = 'none'; }, 5000);
                    ConsoleManager.log(`Rendered ${positions.length / 2} nodes (valid: ${validNodes.length}, diagnostic: ${diagnosticNodes.length})`);
                } catch (e) {
                    Troubleshooter.checkError(e, 'Prompt LLM: Optimize WebGL rendering for mobile');
                    ConsoleManager.logError(e.message);
                }
            }
        };

        const WizardManager = {
            open() {
                document.getElementById('wizardPopup').classList.add('active');
                this.testConnectivity();
            },
            async testConnectivity() {
                const status = document.getElementById('connectivityStatus');
                try {
                    if (!navigator.bluetooth) {
                        throw new Error('Web Bluetooth unavailable. Ensure HTTPS, enable device Bluetooth, and check browser settings (e.g., Chrome: Settings > Privacy and security > Site settings > Bluetooth).');
                    }
                    status.textContent = 'Bluetooth available';
                    ConsoleManager.log('Bluetooth connectivity confirmed');
                } catch (e) {
                    status.textContent = e.message;
                    ConsoleManager.logError(e.message);
                    Troubleshooter.checkError(e, 'Prompt LLM: Verify Bluetooth settings');
                }
            },
            nextStep(step) {
                const nodeId = document.getElementById('nodeId').value;
                if (BluetoothMesh.setNodeId(nodeId)) {
                    document.getElementById('wizardPopup').classList.remove('active');
                    this.finalize(nodeId);
                }
            },
            skip() {
                const guestId = `guest${Math.floor(Math.random() * 1000)}@webxos`;
                if (BluetoothMesh.setNodeId(guestId)) {
                    document.getElementById('wizardPopup').classList.remove('active');
                    this.finalize(guestId);
                }
            },
            finalize(nodeId) {
                ConsoleManager.log(`Setup complete for ${nodeId}. Use the 'Discover' button or type 'discover' to find nodes.`);
                ConsoleManager.log(`If offline, FalseNode@webxos will appear under 'Diagnostic Nodes' and in red in WebGL for diagnostics only. It cannot be selected.`);
                ConsoleManager.log(`Select a valid node by clicking its name under 'Discovered Nodes' to initiate a merge.`);
            }
        };

        const ConsoleManager = {
            verboseMode: false,
            log(message) {
                const consoleOutput = document.getElementById('consoleOutput');
                const p = document.createElement('p');
                p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                consoleOutput.appendChild(p);
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            },
            logError(message) {
                const error = new Error(message);
                this.log(`ERROR: ${message} (Stack: ${error.stack})`);
            },
            logVerbose(message) {
                if (this.verboseMode) {
                    this.log(`VERBOSE: ${message}`);
                }
            },
            execute() {
                const input = document.getElementById('commandInput');
                const command = input.value.trim().toLowerCase();
                input.value = '';
                if (command === 'discover') {
                    BluetoothMesh.discover();
                } else if (command === 'help') {
                    this.help();
                } else if (command === 'troubleshoot') {
                    Troubleshooter.check();
                } else if (command === 'verbose') {
                    this.verboseMode = !this.verboseMode;
                    this.log(`Verbose mode ${this.verboseMode ? 'enabled' : 'disabled'}`);
                } else {
                    this.logError('Unknown command. Type "help" for commands.');
                }
            },
            help() {
                this.log('Commands: discover, help, troubleshoot, verbose');
                this.log('Use "Discover" button or "discover" command to find nodes.');
                this.log('FalseNode@webxos appears under "Diagnostic Nodes" and in red in WebGL when offline. It cannot be selected or merged with.');
                this.log('Click a valid node name under "Discovered Nodes" to merge.');
                this.log('Ensure HTTPS and Bluetooth are enabled for full functionality.');
                this.log('Use "verbose" to toggle detailed debugging logs.');
            },
            handleCommand(event) {
                if (event.key === 'Enter') {
                    this.execute();
                }
            }
        };

        const Troubleshooter = {
            check() {
                this.checkJavaScriptSyntax();
                this.checkBluetooth();
                this.checkDOM();
                this.checkStorage();
                this.checkWebGL();
                this.checkWASM();
                NodeSync.validateCompressionConfig();
            },
            checkError(error, suggestion) {
                ConsoleManager.logError(`${error.message} (${suggestion}, Stack: ${error.stack})`);
            },
            checkJavaScriptSyntax() {
                try {
                    const testFn = new Function('return true;');
                    testFn();
                    ConsoleManager.log('JavaScript syntax check passed');
                } catch (e) {
                    this.checkError(e, 'Prompt LLM: Verify JavaScript syntax for invalid tokens');
                }
            },
            async checkBluetooth() {
                try {
                    if (!navigator.bluetooth) {
                        throw new Error('Web Bluetooth unavailable. Ensure HTTPS, enable device Bluetooth, and check browser settings (e.g., Chrome: Settings > Privacy and security > Site settings > Bluetooth).');
                    }
                    ConsoleManager.log('Bluetooth check passed');
                } catch (e) {
                    this.checkError(e, 'Prompt LLM: Verify Bluetooth settings');
                }
            },
            checkDOM() {
                const elements = ['consoleOutput', 'commandInput', 'wizardPopup', 'confirmPopup', 'webglCanvas', 'connectivityStatus', 'confirmYes'];
                elements.forEach(id => {
                    if (!document.getElementById(id)) {
                        this.checkError(new Error(`DOM element ${id} missing`), 'Prompt LLM: Verify DOM structure');
                    }
                });
                ConsoleManager.log('DOM check passed');
            },
            checkStorage() {
                try {
                    localStorage.setItem('test', 'test');
                    localStorage.removeItem('test');
                    ConsoleManager.log('localStorage check passed');
                } catch (e) {
                    this.checkError(e, 'Prompt LLM: Verify localStorage access');
                }
            },
            checkWebGL() {
                try {
                    const canvas = document.createElement('canvas');
                    if (!canvas.getContext('webgl')) {
                        throw new Error('WebGL not supported');
                    }
                    ConsoleManager.log('WebGL check passed');
                } catch (e) {
                    this.checkError(e, 'Prompt LLM: Verify WebGL support');
                }
            },
            checkWASM() {
                try {
                    if (typeof WebAssembly === 'undefined') {
                        throw new Error('WebAssembly not supported');
                    }
                    ConsoleManager.log('WebAssembly check passed');
                } catch (e) {
                    this.checkError(e, 'Prompt LLM: Verify WebAssembly support');
                }
            }
        };

        // Initialization
        window.addEventListener('load', () => {
            Troubleshooter.check();
            WebGLViz.init();
            WizardManager.open();
        });
    </script>
</body>
</html>
