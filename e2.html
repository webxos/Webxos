<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Exoskeleton AI: A futuristic app for managing text and file databases with holographic 3D grid visualization, encoded in serials and codes.">
    <meta name="keywords" content="Exoskeleton AI, holographic database, text storage, file storage, cyberpunk app, WebXOS, secure database">
    <meta name="author" content="WebXOS">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="Exoskeleton AI - Holographic Database">
    <meta property="og:description" content="Store and visualize text and file data with a cyberpunk-inspired holographic 3D grid, encoded in serials and codes.">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Exoskeleton AI - Holographic Database">
    <meta name="twitter:description" content="Store and visualize text and file data with a cyberpunk-inspired holographic 3D grid.">
    <title>Exoskeleton AI</title>
    <meta name="theme-color" content="#000000">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #0f0;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            overscroll-behavior: none;
        }
        .header {
            width: 100%;
            max-width: 320px;
            text-align: center;
            padding: 8px;
            font-size: 16px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0, 0 0 10px #0f0;
            height: 40px;
            position: fixed;
            top: 0;
            background: rgba(0,0,0,0.8);
            z-index: 20;
        }
        .app-container {
            width: 100%;
            max-width: 320px;
            height: 320px;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 40px;
            margin-bottom: 10px;
        }
        .hologram-container {
            width: 360px;
            height: 320px;
            position: relative;
            overflow: hidden;
        }
        .hologram {
            width: 320px;
            height: 320px;
            position: absolute;
            top: 0;
            left: 20px;
            transform-style: preserve-3d;
            animation: rotateHologram 30s infinite linear;
        }
        .grid-square {
            position: absolute;
            background: rgba(0,255,0,0.6);
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
            animation: pulseSquare 4s infinite;
        }
        .signature-layer {
            position: absolute;
            width: 200px;
            height: 100px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.6;
            z-index: 10;
            filter: drop-shadow(0 0 5px #0f0);
        }
        .signature-layer canvas {
            width: 100%;
            height: 100%;
        }
        .bottom-section {
            width: 100%;
            max-width: 320px;
            position: fixed;
            bottom: 0;
            display: flex;
            flex-direction: column;
            background: rgba(0,0,0,0.8);
            box-shadow: 0 0 10px #0f0;
            z-index: 10;
        }
        .console-section {
            width: 100%;
            max-height: calc(100vh - 40px - 320px - 52px - 20px);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #console {
            width: 100%;
            flex: 1;
            overflow-y: auto;
            touch-action: auto;
            font-size: 14px;
            padding: 8px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: #0f0 rgba(0,0,0,0.8);
            overscroll-behavior: contain;
        }
        #console::-webkit-scrollbar {
            width: 8px;
        }
        #console::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.8);
        }
        #console::-webkit-scrollbar-thumb {
            background: #0f0;
            border-radius: 4px;
            box-shadow: 0 0 5px #0f0;
        }
        .entry {
            margin: 4px 0;
            word-wrap: break-word;
        }
        .timestamp {
            color: #080;
            margin-right: 8px;
        }
        .input-area {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            width: 100%;
            padding: 8px;
            background: rgba(0,0,0,0.8);
            border-top: 1px solid #0f0;
            min-height: 52px;
        }
        input {
            flex: 1;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            padding: 8px;
            box-shadow: 0 0 5px #0f0;
            min-height: 36px;
            min-width: 100px;
            touch-action: auto;
        }
        button {
            flex: 0 0 auto;
            background: rgba(0,255,0,0.1);
            color: #0f0;
            border: 2px solid #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            padding: 8px;
            border-radius: 8px;
            min-height: 36px;
            min-width: 70px;
            text-transform: uppercase;
            transition: all 0.2s ease;
            box-shadow: 0 0 8px #0f0;
            touch-action: auto;
        }
        button:hover {
            background: #0f0;
            color: #000;
            cursor: pointer;
            box-shadow: 0 0 12px #0f0;
            transform: scale(1.05);
        }
        button:active {
            transform: scale(0.95);
            box-shadow: 0 0 5px #0f0;
        }
        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            padding: 12px;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 1000;
            box-shadow: 0 0 10px #0f0;
            touch-action: auto;
        }
        .popup h3 {
            margin: 0 0 10px;
            font-size: 14px;
            text-shadow: 0 0 5px #0f0;
        }
        .popup canvas {
            width: 100%;
            height: 150px;
            background: #000;
            border: 1px solid #0f0;
            margin-bottom: 8px;
            touch-action: auto;
        }
        .popup input[type="file"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            font-size: 12px;
        }
        .popup .btn {
            width: 100%;
            margin: 5px 0;
            padding: 8px;
            background: rgba(0,255,0,0.1);
            color: #0f0;
            border: 2px solid #0f0;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 8px #0f0;
            transition: all 0.2s ease;
            touch-action: auto;
        }
        .popup .btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 12px #0f0;
        }
        .popup .btn:active {
            transform: scale(0.95);
        }
        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 999;
            touch-action: none;
        }
        footer {
            width: 100%;
            text-align: center;
            font-size: 10px;
            color: #0f0;
            padding: 4px 0;
            text-shadow: 0 0 3px #0f0;
            height: 20px;
            background: rgba(0,0,0,0.8);
            border-top: 1px solid #0f0;
        }
        @media (max-width: 480px) {
            .header {
                max-width: 280px;
                font-size: 14px;
                padding: 6px;
                height: 36px;
            }
            .app-container {
                max-width: 280px;
                height: 280px;
                margin-top: 36px;
            }
            .hologram-container {
                width: 300px;
                height: 280px;
            }
            .hologram {
                width: 280px;
                height: 280px;
                left: 10px;
            }
            .signature-layer {
                width: 150px;
                height: 75px;
            }
            .bottom-section {
                max-width: 100%;
            }
            .console-section {
                max-height: calc(100vh - 36px - 280px - 48px - 18px);
            }
            #console {
                font-size: 12px;
                padding: 6px;
            }
            .input-area {
                gap: 5px;
                padding: 6px;
                min-height: 48px;
            }
            input {
                font-size: 12px;
                padding: 6px;
                min-height: 32px;
                min-width: 90px;
            }
            button {
                font-size: 12px;
                padding: 6px;
                min-height: 32px;
                min-width: 60px;
                border-radius: 6px;
            }
            .popup {
                width: 260px;
            }
            .popup .btn {
                font-size: 12px;
                padding: 6px;
            }
            footer {
                font-size: 9px;
                padding: 3px;
                height: 18px;
            }
        }
        @keyframes rotateHologram {
            0% { transform: rotateY(0deg) rotateX(15deg); }
            100% { transform: rotateY(360deg) rotateX(15deg); }
        }
        @keyframes pulseSquare {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <div class="header">Exoskeleton AI</div>
    <div class="app-container">
        <div class="hologram-container">
            <div class="hologram" id="hologram"></div>
        </div>
    </div>
    <div class="bottom-section">
        <div class="console-section">
            <div id="console">
                <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Exoskeleton AI v1.0 - Holographic Console initialized</div>
                <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Type 'HELP' for commands</div>
                <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Serials and codes encode data algorithmically; stored in localStorage and IndexedDB</div>
            </div>
        </div>
        <div class="input-area">
            <input type="text" id="commandInput" placeholder="Enter command..." onkeydown="if(event.key === 'Enter') executeCommand()">
            <button onclick="executeCommand()">Execute</button>
            <button onclick="clearConsole()">Clear</button>
        </div>
        <footer>WebXOS 2025</footer>
    </div>
    <div class="popup-overlay" id="signOverlay"></div>
    <div class="popup" id="signPopup">
        <h3>Sign Exoskeleton AI</h3>
        <canvas id="signCanvas"></canvas>
        <button class="btn" onclick="submitSignature()">Submit</button>
        <button class="btn" onclick="closeSignPopup()">Cancel</button>
    </div>
    <div class="popup-overlay" id="uploadOverlay"></div>
    <div class="popup" id="uploadPopup">
        <h3>Upload File</h3>
        <p>Max file size: 5MB per file</p>
        <p id="storageInfo">Checking storage...</p>
        <input type="file" id="fileInput">
        <button class="btn" onclick="submitUpload()">Upload</button>
        <button class="btn" onclick="closeUploadPopup()">Cancel</button>
    </div>
    <script>
        let database = [];
        let currentSerial = '', currentCode = '';
        let serialCounter = 1;
        let serialMap = new Map();
        const hologram = document.getElementById('hologram');
        const commandInput = document.getElementById('commandInput');
        const consoleDiv = document.getElementById('console');
        const signCanvas = document.getElementById('signCanvas');
        const signCtx = signCanvas.getContext('2d');
        const signPopup = document.getElementById('signPopup');
        const signOverlay = document.getElementById('signOverlay');
        const uploadPopup = document.getElementById('uploadPopup');
        const uploadOverlay = document.getElementById('uploadOverlay');
        const fileInput = document.getElementById('fileInput');
        const storageInfo = document.getElementById('storageInfo');
        let painting = false;
        let strokes = [];
        let currentStroke = [];
        const DB_NAME = 'ExoskeletonAI';
        const STORE_NAME = 'Files';
        const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
        const MAX_DB_SIZE = 50 * 1024 * 1024; // 50MB per database

        // Initialize canvas
        signCanvas.width = 280;
        signCanvas.height = 150;
        signCtx.lineWidth = 3;
        signCtx.lineCap = 'round';
        signCtx.lineJoin = 'round';
        signCtx.strokeStyle = '#0f0';

        // Prevent page scrolling on touch
        document.addEventListener('touchmove', (e) => {
            if (!e.target.closest('#console') && !e.target.closest('.popup') && !e.target.closest('.input-area')) {
                e.preventDefault();
            }
        }, { passive: false });

        // Ensure console scrolling is smooth
        consoleDiv.addEventListener('touchstart', () => {
            consoleDiv.style.scrollBehavior = 'smooth';
        });

        // IndexedDB Setup
        let dbPromise = null;
        function openDB() {
            if (dbPromise) return dbPromise;
            dbPromise = new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                };
                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };
                request.onerror = (event) => {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to open IndexedDB - ${event.target.error.message}</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    reject(event.target.error);
                };
            });
            return dbPromise;
        }

        async function storeFile(serial, file, index) {
            try {
                const db = await openDB();
                const reader = new FileReader();
                return new Promise((resolve, reject) => {
                    reader.onload = async () => {
                        const arrayBuffer = reader.result;
                        const transaction = db.transaction([STORE_NAME], 'readwrite');
                        const store = transaction.objectStore(STORE_NAME);
                        const fileData = {
                            id: `${serial}_${index}`,
                            serial,
                            index,
                            name: file.name,
                            type: file.type,
                            size: file.size,
                            data: arrayBuffer
                        };
                        const request = store.put(fileData);
                        request.onsuccess = () => resolve(fileData);
                        request.onerror = () => {
                            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to store file - ${request.error.message}</div>`;
                            consoleDiv.scrollTop = consoleDiv.scrollHeight;
                            reject(request.error);
                        };
                    };
                    reader.onerror = () => {
                        consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to read file</div>`;
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        reject(reader.error);
                    };
                    reader.readAsArrayBuffer(file);
                });
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to store file - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                throw error;
            }
        }

        async function getFile(serial, index) {
            try {
                const db = await openDB();
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(`${serial}_${index}`);
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => {
                        consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to retrieve file - ${request.error.message}</div>`;
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        reject(request.error);
                    };
                });
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to retrieve file - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                throw error;
            }
        }

        async function getDatabaseSize(serial) {
            try {
                const db = await openDB();
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        const files = request.result.filter(file => file.serial === serial);
                        const totalSize = files.reduce((sum, file) => sum + file.size, 0);
                        resolve(totalSize);
                    };
                    request.onerror = () => {
                        consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to calculate database size - ${request.error.message}</div>`;
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        reject(request.error);
                    };
                });
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to calculate database size - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                throw error;
            }
        }

        async function clearDatabase(serial) {
            try {
                const db = await openDB();
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        const files = request.result.filter(file => file.serial === serial);
                        const deletePromises = files.map(file => {
                            const deleteRequest = store.delete(file.id);
                            return new Promise((res, rej) => {
                                deleteRequest.onsuccess = () => res();
                                deleteRequest.onerror = () => rej(deleteRequest.error);
                            });
                        });
                        Promise.all(deletePromises).then(resolve).catch(error => {
                            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to clear database - ${error.message}</div>`;
                            consoleDiv.scrollTop = consoleDiv.scrollHeight;
                            reject(error);
                        });
                    };
                    request.onerror = () => {
                        consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to clear database - ${request.error.message}</div>`;
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        reject(request.error);
                    };
                });
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to clear database - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                throw error;
            }
        }

        function getFullTimestamp() {
            return new Date().toLocaleString();
        }

        function hashCode(str, salt = '') {
            let hash = 2166136261;
            const saltedStr = str + salt;
            for (let i = 0; i < saltedStr.length; i++) {
                hash ^= saltedStr.charCodeAt(i);
                hash *= 16777619;
            }
            return Math.abs(hash);
        }

        function seededRandom(seed) {
            let x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        function saveState() {
            try {
                localStorage.setItem('exoskeletonAISerialMap', JSON.stringify([...serialMap]));
                localStorage.setItem('exoskeletonAISerialCounter', serialCounter);
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to save state - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        function loadState() {
            try {
                const savedMap = localStorage.getItem('exoskeletonAISerialMap');
                const savedCounter = localStorage.getItem('exoskeletonAISerialCounter');
                if (savedMap) {
                    serialMap = new Map(JSON.parse(savedMap));
                }
                serialCounter = parseInt(savedCounter) || 1;
                if (serialCounter < 1 || serialCounter > 999999) {
                    serialCounter = 1;
                }
                const maxSerial = Math.max(...Array.from(serialMap.keys())
                    .filter(s => s.startsWith('HOLO-'))
                    .map(s => parseInt(s.split('-')[1]) || 0), 0);
                if (maxSerial >= serialCounter) {
                    serialCounter = maxSerial + 1;
                }
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to load state - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        function compressDatabase(entries) {
            return JSON.stringify(entries.map(entry => ({
                text: entry.text,
                time: entry.time.toISOString(),
                signature: entry.signature,
                miniSignature: entry.miniSignature,
                isFile: entry.isFile || false,
                fileName: entry.fileName || '',
                fileSize: entry.fileSize || 0
            })));
        }

        function decompressDatabase(compressed, seed) {
            try {
                const entries = JSON.parse(compressed);
                return entries.map(entry => ({
                    text: entry.text,
                    time: new Date(entry.time),
                    signature: entry.signature || false,
                    miniSignature: entry.miniSignature || '',
                    isFile: entry.isFile || false,
                    fileName: entry.fileName || '',
                    fileSize: entry.fileSize || 0
                }));
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Decompression failed - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return [];
            }
        }

        function encodeDatabase(entries, serial) {
            try {
                const compressed = compressDatabase(entries);
                const seed = hashCode(serial);
                let encoded = '';
                for (let i = 0; i < compressed.length; i++) {
                    const charCode = compressed.charCodeAt(i);
                    const shift = (seed >> (i % 32)) & 0xFF;
                    encoded += String.fromCharCode((charCode + shift) % 256);
                }
                return btoa(encoded);
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Encoding failed - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return '';
            }
        }

        function decodeDatabase(encoded, serial) {
            try {
                const seed = hashCode(serial);
                const decoded = atob(encoded);
                let decompressed = '';
                for (let i = 0; i < decoded.length; i++) {
                    const charCode = decoded.charCodeAt(i);
                    const shift = (seed >> (i % 32)) & 0xFF;
                    decompressed += String.fromCharCode((charCode - shift + 256) % 256);
                }
                return decompressDatabase(decompressed, seed);
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Decoding failed - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return [];
            }
        }

        function generateRandomSuffix() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let suffix = '';
            for (let i = 0; i < 3; i++) {
                suffix += chars.charAt(Math.floor(seededRandom(hashCode(suffix + i)) * chars.length));
            }
            return suffix.toUpperCase();
        }

        function generateSerialNumber(code) {
            let serial;
            let attempts = 0;
            const maxAttempts = 1000;
            do {
                if (serialCounter > 999999) {
                    serialCounter = 1;
                }
                const paddedNumber = String(serialCounter++).padStart(6, '0');
                const suffix = generateRandomSuffix();
                serial = `HOLO-${paddedNumber}-${suffix}`;
                attempts++;
                if (attempts > maxAttempts) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to generate unique serial</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return null;
                }
            } while (serialMap.has(serial));
            serialMap.set(serial, { code, encryptedDatabase: '', strokes: [] });
            saveState();
            return serial;
        }

        function generateCrypticCode(serial) {
            const glyphs = 'ΔΩΨΘΣΦΩΓΛΞΠΩ0123456789#@&%*+-=<>';
            let code = '';
            const seedValue = hashCode(serial + 'CODE');
            for (let i = 0; i < 9; i++) {
                code += glyphs.charAt(Math.floor(seededRandom(seedValue + i) * glyphs.length));
            }
            return `Ω-CODE: ${code}`;
        }

        function generateCodeSign(serial, timestamp) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let sign = '';
            const seedValue = hashCode(serial + timestamp);
            for (let i = 0; i < 8; i++) {
                sign += chars.charAt(Math.floor(seededRandom(seedValue + i) * chars.length));
                if (i === 3) sign += '-';
            }
            return `Ω-SIGN: ${sign}`;
        }

        function createStrokeReplica(codesign) {
            const glyphMap = {
                'A': 'Λ', 'B': 'β', 'C': 'C', 'D': 'Δ', 'E': 'Σ', 'F': 'F', 'G': 'Γ', 'H': 'H',
                'I': 'I', 'J': 'J', 'K': 'K', 'L': 'L', 'M': 'M', 'N': 'N', 'O': 'O', 'P': 'Π',
                'Q': 'Q', 'R': 'R', 'S': 'S', 'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X',
                'Y': 'Y', 'Z': 'Z', '0': '0', '1': '|', '2': '2', '3': '3', '4': '4', '5': '5',
                '6': '6', '7': '7', '8': '8', '9': '9', '-': '-'
            };
            return codesign.replace(/./g, c => glyphMap[c] || c);
        }

        function startPainting(e) {
            painting = true;
            const rect = signCanvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            currentStroke = [{ x, y }];
            signCtx.beginPath();
            signCtx.moveTo(x, y);
        }

        function stopPainting() {
            if (painting) {
                painting = false;
                if (currentStroke.length > 1) {
                    strokes.push([...currentStroke]);
                }
                currentStroke = [];
                signCtx.beginPath();
            }
        }

        function draw(e) {
            if (!painting) return;
            e.preventDefault();
            const rect = signCanvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            currentStroke.push({ x, y });
            signCtx.lineTo(x, y);
            signCtx.stroke();
            signCtx.beginPath();
            signCtx.moveTo(x, y);
        }

        signCanvas.addEventListener('mousedown', startPainting);
        signCanvas.addEventListener('mouseup', stopPainting);
        signCanvas.addEventListener('mousemove', draw);
        signCanvas.addEventListener('touchstart', startPainting);
        signCanvas.addEventListener('touchend', stopPainting);
        signCanvas.addEventListener('touchmove', draw);
        signCanvas.addEventListener('mouseleave', stopPainting);

        function clearSignCanvas() {
            signCtx.clearRect(0, 0, signCanvas.width, signCanvas.height);
            strokes = [];
            currentStroke = [];
            painting = false;
            signCtx.beginPath();
        }

        function drawSignatureStrokes(canvas, ctx, strokes, width, height) {
            ctx.clearRect(0, 0, width, height);
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = '#0f0';
            strokes.forEach(stroke => {
                if (stroke.length < 2) return;
                ctx.beginPath();
                stroke.forEach((point, idx) => {
                    const x = (point.x / 280) * width;
                    const y = (point.y / 150) * height;
                    if (idx === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            });
        }

        function submitSignature() {
            if (strokes.length === 0 && currentStroke.length <= 1) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Draw a signature first</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (strokes.reduce((sum, stroke) => sum + stroke.length, 0) + currentStroke.length < 5) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Signature too short</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (currentStroke.length > 1) {
                strokes.push([...currentStroke]);
            }
            const timestamp = Date.now().toString();
            const codesign = generateCodeSign(currentSerial, timestamp);
            const strokeReplica = createStrokeReplica(codesign);
            const fullImage = signCanvas.toDataURL('image/png');
            const miniCanvas = document.createElement('canvas');
            miniCanvas.width = 50;
            miniCanvas.height = 50;
            const miniCtx = miniCanvas.getContext('2d');
            drawSignatureStrokes(miniCanvas, miniCtx, strokes, 50, 50);
            const miniImage = miniCanvas.toDataURL('image/png');
            database.push({
                text: `Signed by: ${fullImage} ${codesign} (${strokeReplica})`,
                time: new Date(),
                signature: true,
                miniSignature: miniImage
            });
            serialMap.get(currentSerial).strokes = strokes;
            saveState();
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Signature added: ${codesign}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            closeSignPopup();
            generateGrid(currentSerial, { serial: currentSerial, entries: database, code: currentCode }, serialMap.get(currentSerial).encryptedDatabase);
        }

        function showSignPopup() {
            if (database.some(entry => entry.signature)) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Exoskeleton AI already signed</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            clearSignCanvas();
            signPopup.style.display = 'block';
            signOverlay.style.display = 'block';
        }

        function closeSignPopup() {
            signPopup.style.display = 'none';
            signOverlay.style.display = 'none';
            clearSignCanvas();
        }

        async function showUploadPopup() {
            fileInput.value = '';
            try {
                const totalSize = await getDatabaseSize(currentSerial);
                const remaining = MAX_DB_SIZE - totalSize;
                storageInfo.textContent = `Used: ${(totalSize / (1024 * 1024)).toFixed(2)} MB | Remaining: ${(remaining / (1024 * 1024)).toFixed(2)} MB`;
                uploadPopup.style.display = 'block';
                uploadOverlay.style.display = 'block';
            } catch (error) {
                storageInfo.textContent = 'ERROR: Unable to check storage';
                uploadPopup.style.display = 'block';
                uploadOverlay.style.display = 'block';
            }
        }

        function closeUploadPopup() {
            uploadPopup.style.display = 'none';
            uploadOverlay.style.display = 'none';
            fileInput.value = '';
        }

        async function submitUpload() {
            const file = fileInput.files[0];
            if (!file) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No file selected</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (file.size > MAX_FILE_SIZE) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: File size exceeds 5MB limit</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            try {
                const totalSize = await getDatabaseSize(currentSerial);
                if (totalSize + file.size > MAX_DB_SIZE) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Insufficient database storage</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                const index = database.length;
                await storeFile(currentSerial, file, index);
                database.push({
                    text: `File: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`,
                    time: new Date(),
                    signature: false,
                    miniSignature: '',
                    isFile: true,
                    fileName: file.name,
                    fileSize: file.size
                });
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>File uploaded: ${file.name} (${(file.size / 1024).toFixed(2)} KB)</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                closeUploadPopup();
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to upload file - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        async function downloadFile(index) {
            if (isNaN(index) || index < 0 || index >= database.length) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid index ${index}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            const entry = database[index];
            if (!entry.isFile) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Entry at index ${index} is not a downloadable file</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            try {
                const fileData = await getFile(currentSerial, index);
                if (!fileData) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: File not found in database</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                const blob = new Blob([fileData.data], { type: fileData.type });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileData.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>File downloaded: ${fileData.name}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to download file - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        async function showDatabaseStats() {
            try {
                const totalSize = await getDatabaseSize(currentSerial);
                const remaining = MAX_DB_SIZE - totalSize;
                const output = `
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Database Stats:</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Total Used: ${(totalSize / (1024 * 1024)).toFixed(2)} MB</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Remaining: ${(remaining / (1024 * 1024)).toFixed(2)} MB</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Max Database Size: ${(MAX_DB_SIZE / (1024 * 1024)).toFixed(2)} MB</div>
                `;
                consoleDiv.innerHTML += output;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to retrieve database stats - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        function initializeGrid() {
            loadState();
            const initSeed = 'INIT' + serialCounter;
            const initCode = generateCrypticCode(initSeed);
            const initSerial = `HOLO-${String(serialCounter).padStart(6,'0')}-INIT`;
            if (!serialMap.has(initSerial)) {
                serialMap.set(initSerial, { code: initCode, encryptedDatabase: '', strokes: [] });
                saveState();
            }
            currentSerial = initSerial;
            currentCode = initCode;
            database = [];
            generateImageFromSeed(initCode, initSerial, {});
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Initial grid: ${initSerial} | ${initCode}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            // Display HELP at startup
            const helpText = `
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Available Commands:</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ADD [data] - Add entry to database</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>VIEW - Show all entries</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SEARCH [term] - Search entries</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>CLEAR - Clear console and current session</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SORT TIME-ASC - Sort by time ascending</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SORT TIME-DESC - Sort by time descending</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SORT ALPHA-ASC - Sort alphabetically ascending</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SORT ALPHA-DESC - Sort alphabetically descending</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>REPLACE# [data] - Replace entry at index # (e.g., REPLACE1 user1)</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>GENERATE - Generate grid with encoded database</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HTML - Generate HTML data sheet and copy to clipboard</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SIGN - Sign the current Exoskeleton AI</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>UPLOAD - Upload a file to the database (max 5MB)</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>DOWNLOAD [index] - Download file at index (e.g., DOWNLOAD 5)</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>DATA - Show database storage usage</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HELP - Show this help</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Enter [serial] [code] to load grid (e.g., HOLO-000001-A7K Ω-CODE: ---111---)</div>
            `;
            consoleDiv.innerHTML += helpText;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function generateDatabase() {
            if (database.length === 0) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No data to generate</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            let newCode;
            do {
                newCode = generateCrypticCode('TEMP' + serialCounter + database.length);
            } while (Array.from(serialMap.values()).some(data => data.code === newCode));
            const serial = generateSerialNumber(newCode);
            if (!serial) return;
            const encodedData = encodeDatabase(database, serial);
            if (!encodedData) return;
            serialMap.set(serial, { code: newCode, encryptedDatabase: encodedData, strokes: serialMap.get(currentSerial).strokes });
            saveState();
            currentSerial = serial;
            currentCode = newCode;
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Grid generated: ${serial} | ${newCode}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            navigator.clipboard.writeText(`${serial}\n${newCode}`).then(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Serial and code copied to clipboard</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }).catch(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to copy serial and code</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            });
            generateGrid(serial, { serial, entries: database, code: newCode }, encodedData);
        }

        function loadGridFromSerial(userSerial, userCode) {
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Attempting to load serial: ${userSerial} | code: ${userCode}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            if (!userSerial || !userCode) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Serial and code required</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            const serialMatch = userSerial.match(/^HOLO-\d{6}-[A-Z0-9]{3}$/);
            const validSerial = serialMatch ? serialMatch[0] : null;
            if (!validSerial) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid serial format. Use HOLO-XXXXXX-XXX (e.g., HOLO-000001-A7K)</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            const codeMatch = userCode.match(/^Ω-CODE: [ΔΩΨΘΣΦΩΓΛΞΠΩ0123456789#@&%*+=\-<>]{9}$/);
            const validCode = codeMatch ? codeMatch[0] : null;
            if (!validCode) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid code format. Use Ω-CODE: followed by 9 glyphs (e.g., Ω-CODE: ---111---). Allowed glyphs: ΔΩΨΘΣΦΩΓΛΞΠΩ0123456789#@&%*+=-<></div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (serialMap.has(validSerial)) {
                const { code, encryptedDatabase, strokes } = serialMap.get(validSerial);
                if (code !== validCode) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid code for serial ${validSerial}. Expected: ${code}</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                database = encryptedDatabase ? decodeDatabase(encryptedDatabase, validSerial) : [];
                currentSerial = validSerial;
                currentCode = validCode;
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Grid loaded: ${validSerial} | ${validCode}</div>`;
                displayEntries(database, `Loaded database contents:`);
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                generateGrid(validSerial, { serial: validSerial, entries: database, code: validCode }, encryptedDatabase);
            } else {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Serial ${validSerial} not found</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        function addToDatabase(data) {
            if (!data.trim()) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No data provided</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            database.push({ text: data, time: new Date(), signature: false, miniSignature: '', isFile: false });
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Added: ${data}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function replaceInDatabase(index, data) {
            if (isNaN(index) || index < 0 || index >= database.length) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid index ${index}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (!data.trim()) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No data provided</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (database[index].signature || database[index].isFile) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Cannot replace signature or file entry</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            database[index] = { text: data, time: new Date(), signature: false, miniSignature: '', isFile: false };
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Replaced entry at index ${index}: ${data}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function generateHTML() {
            if (database.length === 0) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No data to generate HTML</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            let listContent = 'Exoskeleton AI Data Sheet\n------------------\n';
            database.forEach((entry, index) => {
                const time = entry.time.toLocaleTimeString();
                const date = entry.time.toISOString().split('T')[0];
                const text = entry.signature ? `<img src="${entry.text.split(' ')[2]}" alt="Signature" width="100">` : 
                             entry.isFile ? `File: ${entry.fileName} (${(entry.fileSize / 1024).toFixed(2)} KB)` : entry.text;
                listContent += `${index}. Time: ${time}  Date: ${date}  Data: ${text}\n`;
            });
            const htmlContent = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exoskeleton AI Data Sheet</title>
    <style>
        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            margin: 20px;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        pre {
            font-size: 14px;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-width: 800px;
            text-align: left;
        }
        h1 {
            font-size: 20px;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 5px #0f0;
        }
        img {
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <h1>WebXOS 2025 Exoskeleton AI</h1>
    <pre>${listContent}</pre>
</body>
</html>`;
            navigator.clipboard.writeText(htmlContent).then(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HTML data sheet copied to clipboard</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }).catch(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to copy HTML</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            });
        }

        function displayEntries(entries, header = 'Database contents:') {
            const timestamp = getFullTimestamp();
            let output = `<div class="entry"><span class="timestamp">[${timestamp}]</span>${header}</div>`;
            if (entries.length === 0) {
                output += `<div class="entry"><span class="timestamp">[${timestamp}]</span>No entries found</div>`;
            } else {
                entries.forEach((entry, index) => {
                    const displayText = entry.signature ? `<img src="${entry.miniSignature}" alt="Signature" width="50"> ${entry.text.split(' ').slice(3).join(' ')}` : 
                                       entry.isFile ? `File: ${entry.fileName} (${(entry.fileSize / 1024).toFixed(2)} KB)` : entry.text;
                    output += `<div class="entry"><span class="timestamp">[${entry.time.toLocaleString()}]</span>[${index}] ${displayText}</div>`;
                });
            }
            consoleDiv.innerHTML += output;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function sortEntries(method) {
            let sorted = [...database];
            if (method === 'time-asc') {
                sorted.sort((a, b) => a.time - b.time);
            } else if (method === 'time-desc') {
                sorted.sort((a, b) => b.time - b.time);
            } else if (method === 'alpha-asc') {
                sorted.sort((a, b) => a.text.localeCompare(b.text));
            } else if (method === 'alpha-desc') {
                sorted.sort((a, b) => b.text.localeCompare(b.text));
            }
            database = sorted;
            displayEntries(database, 'Sorted database:');
        }

        function generateGrid(serial, dbData, encodedData) {
            currentSerial = serial;
            currentCode = dbData.code;
            generateImageFromSeed(dbData.code, serial, dbData, encodedData);
        }

        function generateImageFromSeed(code, serial, dbData = {}, encodedData = '') {
            hologram.innerHTML = '';
            const hash = hashCode(serial + encodedData);
            let seedValue = hash;
            const rand = (min, max) => {
                seedValue = hashCode(String(seedValue));
                return min + (seedValue % (max - min + 1));
            };
            const randFloat = (min, max) => {
                seedValue = hashCode(String(seedValue));
                return min + ((seedValue % 10000) / 10000) * (max - min);
            };
            const squareCount = rand(20, 50);
            const scale = 0.82; // Scale down by 18%
            for (let i = 0; i < squareCount; i++) {
                const square = document.createElement('div');
                square.className = 'grid-square';
                const size = randFloat(30, 80) * scale;
                square.style.width = `${size}px`;
                square.style.height = `${size}px`;
                const left = randFloat(0, 320 - size) * scale;
                const top = randFloat(0, 320 - size) * scale;
                const z = randFloat(-100, 100) * scale;
                const rotateX = randFloat(-30, 30);
                const rotateY = randFloat(-30, 30);
                square.style.left = `${left}px`;
                square.style.top = `${top}px`;
                square.style.transform = `translateZ(${z}px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
                square.style.opacity = randFloat(0.4, 0.8);
                square.style.background = `rgba(0,${rand(192, 255)},0,${randFloat(0.5, 0.8)})`;
                hologram.appendChild(square);
            }
            const strokes = serialMap.get(serial)?.strokes || [];
            if (strokes.length > 0) {
                const sigLayer = document.createElement('div');
                sigLayer.className = 'signature-layer';
                const sigCanvas = document.createElement('canvas');
                sigCanvas.width = 200;
                sigCanvas.height = 100;
                const sigCtx = sigCanvas.getContext('2d');
                drawSignatureStrokes(sigCanvas, sigCtx, strokes, 200, 100);
                sigLayer.appendChild(sigCanvas);
                hologram.appendChild(sigLayer);
            }
        }

        async function clearConsole() {
            try {
                await clearDatabase(currentSerial);
                database = [];
                currentSerial = '';
                currentCode = '';
                consoleDiv.innerHTML = `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Console and database cleared</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                initializeGrid();
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to clear database - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        function copyContent() {
            if (currentSerial && currentCode) {
                const content = `${currentSerial}\n${currentCode}`;
                navigator.clipboard.writeText(content).then(() => {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Serial and code copied to clipboard</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                }).catch(() => {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to copy</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                });
            } else {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No serial or code to copy</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        function executeCommand() {
            const input = commandInput.value.trim();
            commandInput.value = '';
            if (!input) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Enter a command</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Command: ${input}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            const inputUpper = input.toUpperCase();
            if (inputUpper === 'HELP') {
                const helpText = `
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Available Commands:</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ADD [data] - Add entry to database</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>VIEW - Show all entries</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SEARCH [term] - Search entries</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>CLEAR - Clear console and current session</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SORT TIME-ASC - Sort by time ascending</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SORT TIME-DESC - Sort by time descending</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SORT ALPHA-ASC - Sort alphabetically ascending</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SORT ALPHA-DESC - Sort alphabetically descending</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>REPLACE# [data] - Replace entry at index # (e.g., REPLACE1 user1)</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>GENERATE - Generate grid with encoded database</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HTML - Generate HTML data sheet and copy to clipboard</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SIGN - Sign the current Exoskeleton AI</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>UPLOAD - Upload a file to the database (max 5MB)</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>DOWNLOAD [index] - Download file at index (e.g., DOWNLOAD 5)</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>DATA - Show database storage usage</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HELP - Show this help</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Enter [serial] [code] to load grid (e.g., HOLO-000001-A7K Ω-CODE: ---111---)</div>
                `;
                consoleDiv.innerHTML += helpText;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } else if (inputUpper === 'SIGN') {
                showSignPopup();
            } else if (inputUpper === 'UPLOAD') {
                showUploadPopup();
            } else if (inputUpper.startsWith('DOWNLOAD ')) {
                const index = parseInt(input.substring(9));
                if (isNaN(index)) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid index format</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                downloadFile(index);
            } else if (inputUpper === 'DATA') {
                showDatabaseStats();
            } else if (inputUpper.startsWith('ADD ')) {
                const data = input.substring(4);
                addToDatabase(data);
            } else if (inputUpper.startsWith('REPLACE')) {
                const match = inputUpper.match(/^REPLACE(\d+)\s+(.+)$/);
                if (!match) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid REPLACE format. Use REPLACE# [data]</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                const index = parseInt(match[1]);
                const data = match[2];
                replaceInDatabase(index, data);
            } else if (inputUpper === 'VIEW') {
                displayEntries(database);
            } else if (inputUpper.startsWith('SEARCH ')) {
                const term = input.substring(7).toLowerCase();
                const results = database.filter(entry => entry.text.toLowerCase().includes(term));
                displayEntries(results, `Search results for "${term}":`);
            } else if (inputUpper === 'CLEAR') {
                clearConsole();
            } else if (inputUpper === 'SORT TIME-ASC') {
                sortEntries('time-asc');
            } else if (inputUpper === 'SORT TIME-DESC') {
                sortEntries('time-desc');
            } else if (inputUpper === 'SORT ALPHA-ASC') {
                sortEntries('alpha-asc');
            } else if (inputUpper === 'SORT ALPHA-DESC') {
                sortEntries('alpha-desc');
            } else if (inputUpper === 'GENERATE') {
                generateDatabase();
            } else if (inputUpper === 'HTML') {
                generateHTML();
            } else {
                const args = input.trim();
                const match = args.match(/^(\S+)\s+(.+)$/);
                if (match) {
                    const userSerial = match[1];
                    const userCode = match[2];
                    loadGridFromSerial(userSerial, userCode);
                } else {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Unknown command or invalid serial/code format</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                }
            }
        }

        initializeGrid();
    </script>
</body>
</html>
