
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Exoskeleton AI: A futuristic app for managing text databases with holographic 3D grid visualization, encoded in serials and codes.">
    <meta name="keywords" content="Exoskeleton AI, holographic database, text storage, cyberpunk app, WebXOS, secure database">
    <meta name="author" content="WebXOS">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="Exoskeleton AI - Holographic Database">
    <meta property="og:description" content="Store and visualize text data with a cyberpunk-inspired holographic 3D grid, encoded in serials and codes.">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Exoskeleton AI - Holographic Database">
    <meta name="twitter:description" content="Store and visualize text data with a cyberpunk-inspired holographic 3D grid.">
    <title>Exoskeleton AI</title>
    <meta name="theme-color" content="#000000">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #0f0;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            overscroll-behavior: none;
        }
        .header {
            width: 100%;
            max-width: 320px;
            text-align: center;
            padding: 8px;
            font-size: 16px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0, 0 0 10px #0f0;
            height: 40px;
            position: fixed;
            top: 0;
            background: rgba(0,0,0,0.8);
            z-index: 20;
        }
        .app-container {
            width: 100%;
            max-width: 320px;
            height: 320px;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 40px;
            margin-bottom: 10px;
        }
        .hologram-container {
            width: 360px;
            height: 320px;
            position: relative;
            overflow: hidden;
        }
        .hologram {
            width: 320px;
            height: 320px;
            position: absolute;
            top: 0;
            left: 20px;
            transform-style: preserve-3d;
            animation: rotateHologram 30s infinite linear;
        }
        .grid-square {
            position: absolute;
            background: rgba(0,255,0,0.6);
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
            animation: pulseSquare 4s infinite;
        }
        .signature-layer {
            position: absolute;
            width: 200px;
            height: 100px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.6;
            z-index: 10;
            filter: drop-shadow(0 0 5px #0f0);
        }
        .signature-layer canvas {
            width: 100%;
            height: 100%;
        }
        .bottom-section {
            width: 100%;
            max-width: 320px;
            position: fixed;
            bottom: 0;
            display: flex;
            flex-direction: column;
            background: rgba(0,0,0,0.8);
            box-shadow: 0 0 10px #0f0;
            z-index: 10;
        }
        .console-section {
            width: 100%;
            max-height: calc(100vh - 40px - 320px - 52px - 20px);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #console {
            width: 100%;
            flex: 1;
            overflow-y: auto;
            touch-action: auto;
            font-size: 14px;
            padding: 8px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: #0f0 rgba(0,0,0,0.8);
            overscroll-behavior: contain;
        }
        #console::-webkit-scrollbar {
            width: 8px;
        }
        #console::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.8);
        }
        #console::-webkit-scrollbar-thumb {
            background: #0f0;
            border-radius: 4px;
            box-shadow: 0 0 5px #0f0;
        }
        .entry {
            margin: 4px 0;
            word-wrap: break-word;
        }
        .timestamp {
            color: #080;
            margin-right: 8px;
        }
        .input-area {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            width: 100%;
            padding: 8px;
            background: rgba(0,0,0,0.8);
            border-top: 1px solid #0f0;
            min-height: 52px;
        }
        input {
            flex: 1;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            padding: 8px;
            box-shadow: 0 0 5px #0f0;
            min-height: 36px;
            min-width: 100px;
            touch-action: auto;
        }
        button {
            flex: 0 0 auto;
            background: rgba(0,255,0,0.1);
            color: #0f0;
            border: 2px solid #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            padding: 8px;
            border-radius: 8px;
            min-height: 36px;
            min-width: 70px;
            text-transform: uppercase;
            transition: all 0.2s ease;
            box-shadow: 0 0 8px #0f0;
            touch-action: auto;
        }
        button:hover {
            background: #0f0;
            color: #000;
            cursor: pointer;
            box-shadow: 0 0 12px #0f0;
            transform: scale(1.05);
        }
        button:active {
            transform: scale(0.95);
            box-shadow: 0 0 5px #0f0;
        }
        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            padding: 12px;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 1000;
            box-shadow: 0 0 10px #0f0;
            touch-action: auto;
        }
        .popup h3 {
            margin: 0 0 10px;
            font-size: 14px;
            text-shadow: 0 0 5px #0f0;
        }
        .popup canvas {
            width: 100%;
            height: 150px;
            background: #000;
            border: 1px solid #0f0;
            margin-bottom: 8px;
            touch-action: auto;
        }
        .popup .btn {
            width: 100%;
            margin: 5px 0;
            padding: 8px;
            background: rgba(0,255,0,0.1);
            color: #0f0;
            border: 2px solid #0f0;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 8px #0f0;
            transition: all 0.2s ease;
            touch-action: auto;
        }
        .popup .btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 12px #0f0;
        }
        .popup .btn:active {
            transform: scale(0.95);
        }
        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 999;
            touch-action: none;
        }
        footer {
            width: 100%;
            text-align: center;
            font-size: 10px;
            color: #0f0;
            padding: 4px 0;
            text-shadow: 0 0 3px #0f0;
            height: 20px;
            background: rgba(0,0,0,0.8);
            border-top: 1px solid #0f0;
        }
        @media (max-width: 480px) {
            .header {
                max-width: 280px;
                font-size: 14px;
                padding: 6px;
                height: 36px;
            }
            .app-container {
                max-width: 280px;
                height: 280px;
                margin-top: 36px;
            }
            .hologram-container {
                width: 300px;
                height: 280px;
            }
            .hologram {
                width: 280px;
                height: 280px;
                left: 10px;
            }
            .signature-layer {
                width: 150px;
                height: 75px;
            }
            .bottom-section {
                max-width: 100%;
            }
            .console-section {
                max-height: calc(100vh - 36px - 280px - 48px - 18px);
            }
            #console {
                font-size: 12px;
                padding: 6px;
            }
            .input-area {
                gap: 5px;
                padding: 6px;
                min-height: 48px;
            }
            input {
                font-size: 12px;
                padding: 6px;
                min-height: 32px;
                min-width: 90px;
            }
            button {
                font-size: 12px;
                padding: 6px;
                min-height: 32px;
                min-width: 60px;
                border-radius: 6px;
            }
            .popup {
                width: 260px;
            }
            .popup .btn {
                font-size: 12px;
                padding: 6px;
            }
            footer {
                font-size: 9px;
                padding: 3px;
                height: 18px;
            }
        }
        @keyframes rotateHologram {
            0% { transform: rotateY(0deg) rotateX(15deg); }
            100% { transform: rotateY(360deg) rotateX(15deg); }
        }
        @keyframes pulseSquare {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <div class="header">Exoskeleton AI</div>
    <div class="app-container">
        <div class="hologram-container">
            <div class="hologram" id="hologram"></div>
        </div>
    </div>
    <div class="bottom-section">
        <div class="console-section">
            <div id="console">
                <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Exoskeleton AI v1.0 - Holographic Console initialized</div>
                <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Type 'HELP' for commands</div>
                <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Serials and codes encode data algorithmically; stored in localStorage</div>
            </div>
        </div>
        <div class="input-area">
            <input type="text" id="commandInput" placeholder="Enter command..." onkeydown="if(event.key === 'Enter') executeCommand()">
            <button onclick="executeCommand()">Execute</button>
            <button onclick="clearConsole()">Clear</button>
        </div>
        <footer>WebXOS 2025</footer>
    </div>
    <div class="popup-overlay" id="signOverlay"></div>
    <div class="popup" id="signPopup">
        <h3>Sign Exoskeleton AI</h3>
        <canvas id="signCanvas"></canvas>
        <button class="btn" onclick="submitSignature()">Submit</button>
        <button class="btn" onclick="closeSignPopup()">Cancel</button>
    </div>
    <script>
        let database = [];
        let currentSerial = '', currentCode = '';
        let serialCounter = 1;
        let serialMap = new Map();
        const hologram = document.getElementById('hologram');
        const commandInput = document.getElementById('commandInput');
        const consoleDiv = document.getElementById('console');
        const signCanvas = document.getElementById('signCanvas');
        const signCtx = signCanvas.getContext('2d');
        const signPopup = document.getElementById('signPopup');
        const signOverlay = document.getElementById('signOverlay');
        let painting = false;
        let strokes = [];
        let currentStroke = [];

        // Initialize canvas
        signCanvas.width = 280;
        signCanvas.height = 150;
        signCtx.lineWidth = 3;
        signCtx.lineCap = 'round';
        signCtx.lineJoin = 'round';
        signCtx.strokeStyle = '#0f0';

        // Prevent page scrolling on touch
        document.addEventListener('touchmove', (e) => {
            if (!e.target.closest('#console') && !e.target.closest('.popup') && !e.target.closest('.input-area')) {
                e.preventDefault();
            }
        }, { passive: false });

        // Ensure console scrolling is smooth
        consoleDiv.addEventListener('touchstart', () => {
            consoleDiv.style.scrollBehavior = 'smooth';
        });

        function getFullTimestamp() {
            return new Date().toLocaleString();
        }

        function hashCode(str, salt = '') {
            let hash = 2166136261;
            const saltedStr = str + salt;
            for (let i = 0; i < saltedStr.length; i++) {
                hash ^= saltedStr.charCodeAt(i);
                hash *= 16777619;
            }
            return Math.abs(hash);
        }

        function seededRandom(seed) {
            let x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        function saveState() {
            try {
                localStorage.setItem('exoskeletonAISerialMap', JSON.stringify([...serialMap]));
                localStorage.setItem('exoskeletonAISerialCounter', serialCounter);
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to save state - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        function loadState() {
            try {
                const savedMap = localStorage.getItem('exoskeletonAISerialMap');
                const savedCounter = localStorage.getItem('exoskeletonAISerialCounter');
                if (savedMap) {
                    serialMap = new Map(JSON.parse(savedMap));
                }
                serialCounter = parseInt(savedCounter) || 1;
                if (serialCounter < 1 || serialCounter > 999999) {
                    serialCounter = 1;
                }
                const maxSerial = Math.max(...Array.from(serialMap.keys())
                    .filter(s => s.startsWith('HOLO-'))
                    .map(s => parseInt(s.split('-')[1]) || 0), 0);
                if (maxSerial >= serialCounter) {
                    serialCounter = maxSerial + 1;
                }
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to load state - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        function compressDatabase(entries) {
            return JSON.stringify(entries.map(entry => ({
                text: entry.text,
                time: entry.time.toISOString(),
                signature: entry.signature,
                miniSignature: entry.miniSignature
            })));
        }

        function decompressDatabase(compressed, seed) {
            try {
                const entries = JSON.parse(compressed);
                return entries.map(entry => ({
                    text: entry.text,
                    time: new Date(entry.time),
                    signature: entry.signature || false,
                    miniSignature: entry.miniSignature || ''
                }));
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Decompression failed - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return [];
            }
        }

        function encodeDatabase(entries, serial) {
            try {
                const compressed = compressDatabase(entries);
                const seed = hashCode(serial);
                let encoded = '';
                for (let i = 0; i < compressed.length; i++) {
                    const charCode = compressed.charCodeAt(i);
                    const shift = (seed >> (i % 32)) & 0xFF;
                    encoded += String.fromCharCode((charCode + shift) % 256);
                }
                return btoa(encoded);
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Encoding failed - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return '';
            }
        }

        function decodeDatabase(encoded, serial) {
            try {
                const seed = hashCode(serial);
                const decoded = atob(encoded);
                let decompressed = '';
                for (let i = 0; i < decoded.length; i++) {
                    const charCode = decoded.charCodeAt(i);
                    const shift = (seed >> (i % 32)) & 0xFF;
                    decompressed += String.fromCharCode((charCode - shift + 256) % 256);
                }
                return decompressDatabase(decompressed, seed);
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Decoding failed - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return [];
            }
        }

        function generateRandomSuffix() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let suffix = '';
            for (let i = 0; i < 3; i++) {
                suffix += chars.charAt(Math.floor(seededRandom(hashCode(suffix + i)) * chars.length));
            }
            return suffix.toUpperCase();
        }

        function generateSerialNumber(code) {
            let serial;
            let attempts = 0;
            const maxAttempts = 1000;
            do {
                if (serialCounter > 999999) {
                    serialCounter = 1;
                }
                const paddedNumber = String(serialCounter++).padStart(6, '0');
                const suffix = generateRandomSuffix();
                serial = `HOLO-${paddedNumber}-${suffix}`;
                attempts++;
                if (attempts > maxAttempts) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to generate unique serial</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return null;
                }
            } while (serialMap.has(serial));
            serialMap.set(serial, { code, encryptedDatabase: '', strokes: [] });
            saveState();
            return serial;
        }

        function generateCrypticCode(serial) {
            const glyphs = 'ΔΩΨΘΣΦΩΓΛΞΠΩ0123456789#@&%*+-=<>';
            let code = '';
            const seedValue = hashCode(serial + 'CODE');
            for (let i = 0; i < 9; i++) {
                code += glyphs.charAt(Math.floor(seededRandom(seedValue + i) * glyphs.length));
            }
            return `Ω-CODE: ${code}`;
        }

        function generateCodeSign(serial, timestamp) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let sign = '';
            const seedValue = hashCode(serial + timestamp);
            for (let i = 0; i < 8; i++) {
                sign += chars.charAt(Math.floor(seededRandom(seedValue + i) * chars.length));
                if (i === 3) sign += '-';
            }
            return `Ω-SIGN: ${sign}`;
        }

        function createStrokeReplica(codesign) {
            const glyphMap = {
                'A': 'Λ', 'B': 'β', 'C': 'C', 'D': 'Δ', 'E': 'Σ', 'F': 'F', 'G': 'Γ', 'H': 'H',
                'I': 'I', 'J': 'J', 'K': 'K', 'L': 'L', 'M': 'M', 'N': 'N', 'O': 'O', 'P': 'Π',
                'Q': 'Q', 'R': 'R', 'S': 'S', 'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X',
                'Y': 'Y', 'Z': 'Z', '0': '0', '1': '|', '2': '2', '3': '3', '4': '4', '5': '5',
                '6': '6', '7': '7', '8': '8', '9': '9', '-': '-'
            };
            return codesign.replace(/./g, c => glyphMap[c] || c);
        }

        function startPainting(e) {
            painting = true;
            const rect = signCanvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            currentStroke = [{ x, y }];
            signCtx.beginPath();
            signCtx.moveTo(x, y);
        }

        function stopPainting() {
            if (painting) {
                painting = false;
                if (currentStroke.length > 1) {
                    strokes.push([...currentStroke]);
                }
                currentStroke = [];
                signCtx.beginPath();
            }
        }

        function draw(e) {
            if (!painting) return;
            e.preventDefault();
            const rect = signCanvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            currentStroke.push({ x, y });
            signCtx.lineTo(x, y);
            signCtx.stroke();
            signCtx.beginPath();
            signCtx.moveTo(x, y);
        }

        signCanvas.addEventListener('mousedown', startPainting);
        signCanvas.addEventListener('mouseup', stopPainting);
        signCanvas.addEventListener('mousemove', draw);
        signCanvas.addEventListener('touchstart', startPainting);
        signCanvas.addEventListener('touchend', stopPainting);
        signCanvas.addEventListener('touchmove', draw);
        signCanvas.addEventListener('mouseleave', stopPainting);

        function clearSignCanvas() {
            signCtx.clearRect(0, 0, signCanvas.width, signCanvas.height);
            strokes = [];
            currentStroke = [];
            painting = false;
            signCtx.beginPath();
        }

        function drawSignatureStrokes(canvas, ctx, strokes, width, height) {
            ctx.clearRect(0, 0, width, height);
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = '#0f0';
            strokes.forEach(stroke => {
                if (stroke.length < 2) return;
                ctx.beginPath();
                stroke.forEach((point, idx) => {
                    const x = (point.x / 280) * width;
                    const y = (point.y / 150) * height;
                    if (idx === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            });
        }

        function submitSignature() {
            if (strokes.length === 0 && currentStroke.length <= 1) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Draw a signature first</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (strokes.reduce((sum, stroke) => sum + stroke.length, 0) + currentStroke.length < 5) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Signature too short</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (currentStroke.length > 1) {
                strokes.push([...currentStroke]);
            }
            const timestamp = Date.now().toString();
            const codesign = generateCodeSign(currentSerial, timestamp);
            const strokeReplica = createStrokeReplica(codesign);
            const fullImage = signCanvas.toDataURL('image/png');
            const miniCanvas = document.createElement('canvas');
            miniCanvas.width = 50;
            miniCanvas.height = 50;
            const miniCtx = miniCanvas.getContext('2d');
            drawSignatureStrokes(miniCanvas, miniCtx, strokes, 50, 50);
            const miniImage = miniCanvas.toDataURL('image/png');
            database.push({
                text: `Signed by: ${fullImage} ${codesign} (${strokeReplica})`,
                time: new Date(),
                signature: true,
                miniSignature: miniImage
            });
            serialMap.get(currentSerial).strokes = strokes;
            saveState();
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Signature added: ${codesign}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            closeSignPopup();
            generateGrid(currentSerial, { serial: currentSerial, entries: database, code: currentCode }, serialMap.get(currentSerial).encryptedDatabase);
        }

        function showSignPopup() {
            if (database.some(entry => entry.signature)) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Exoskeleton AI already signed</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            clearSignCanvas();
            signPopup.style.display = 'block';
            signOverlay.style.display = 'block';
        }

        function closeSignPopup() {
            signPopup.style.display = 'none';
            signOverlay.style.display = 'none';
            clearSignCanvas();
        }

        function initializeGrid() {
            loadState();
            const initSeed = 'INIT' + serialCounter;
            const initCode = generateCrypticCode(initSeed);
            const initSerial = `HOLO-${String(serialCounter).padStart(6,'0')}-INIT`;
            if (!serialMap.has(initSerial)) {
                serialMap.set(initSerial, { code: initCode, encryptedDatabase: '', strokes: [] });
                saveState();
            }
            currentSerial = initSerial;
            currentCode = initCode;
            database = [];
            generateImageFromSeed(initCode, initSerial, {});
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Initial grid: ${initSerial} | ${initCode}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            // Display HELP at startup
            const helpText = `
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Available Commands:</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ADD [data] - Add entry to database</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>VIEW - Show all entries</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SEARCH [term] - Search entries</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>CLEAR - Clear console and current session</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SORT TIME-ASC - Sort by time ascending</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SORT TIME-DESC - Sort by time descending</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SORT ALPHA-ASC - Sort alphabetically ascending</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SORT ALPHA-DESC - Sort alphabetically descending</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>REPLACE# [data] - Replace entry at index # (e.g., REPLACE1 user1)</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>GENERATE - Generate grid with encoded database</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HTML - Generate HTML data sheet and copy to clipboard</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SIGN - Sign the current Exoskeleton AI</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HELP - Show this help</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Enter [serial] [code] to load grid (e.g., HOLO-000001-A7K Ω-CODE: ---111---)</div>
            `;
            consoleDiv.innerHTML += helpText;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function generateDatabase() {
            if (database.length === 0) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No data to generate</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            let newCode;
            do {
                newCode = generateCrypticCode('TEMP' + serialCounter + database.length);
            } while (Array.from(serialMap.values()).some(data => data.code === newCode));
            const serial = generateSerialNumber(newCode);
            if (!serial) return;
            const encodedData = encodeDatabase(database, serial);
            if (!encodedData) return;
            serialMap.set(serial, { code: newCode, encryptedDatabase: encodedData, strokes: serialMap.get(currentSerial).strokes });
            saveState();
            currentSerial = serial;
            currentCode = newCode;
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Grid generated: ${serial} | ${newCode}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            navigator.clipboard.writeText(`${serial}\n${newCode}`).then(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Serial and code copied to clipboard</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }).catch(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to copy serial and code</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            });
            generateGrid(serial, { serial, entries: database, code: newCode }, encodedData);
        }

        function loadGridFromSerial(userSerial, userCode) {
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Attempting to load serial: ${userSerial} | code: ${userCode}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            if (!userSerial || !userCode) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Serial and code required</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            const serialMatch = userSerial.match(/^HOLO-\d{6}-[A-Z0-9]{3}$/);
            const validSerial = serialMatch ? serialMatch[0] : null;
            if (!validSerial) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid serial format. Use HOLO-XXXXXX-XXX (e.g., HOLO-000001-A7K)</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            const codeMatch = userCode.match(/^Ω-CODE: [ΔΩΨΘΣΦΩΓΛΞΠΩ0123456789#@&%*+=\-<>]{9}$/);
            const validCode = codeMatch ? codeMatch[0] : null;
            if (!validCode) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid code format. Use Ω-CODE: followed by 9 glyphs (e.g., Ω-CODE: ---111---). Allowed glyphs: ΔΩΨΘΣΦΩΓΛΞΠΩ0123456789#@&%*+=-<></div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (serialMap.has(validSerial)) {
                const { code, encryptedDatabase, strokes } = serialMap.get(validSerial);
                if (code !== validCode) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid code for serial ${validSerial}. Expected: ${code}</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                database = encryptedDatabase ? decodeDatabase(encryptedDatabase, validSerial) : [];
                currentSerial = validSerial;
                currentCode = validCode;
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Grid loaded: ${validSerial} | ${validCode}</div>`;
                displayEntries(database, `Loaded database contents:`);
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                generateGrid(validSerial, { serial: validSerial, entries: database, code: validCode }, encryptedDatabase);
            } else {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Serial ${validSerial} not found</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        function addToDatabase(data) {
            if (!data.trim()) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No data provided</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            database.push({ text: data, time: new Date(), signature: false, miniSignature: '' });
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Added: ${data}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function replaceInDatabase(index, data) {
            if (isNaN(index) || index < 0 || index >= database.length) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid index ${index}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (!data.trim()) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No data provided</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (database[index].signature) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Cannot replace signature</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            database[index] = { text: data, time: new Date(), signature: false, miniSignature: '' };
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Replaced entry at index ${index}: ${data}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function generateHTML() {
            if (database.length === 0) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No data to generate HTML</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            let listContent = 'Exoskeleton AI Data Sheet\n------------------\n';
            database.forEach((entry, index) => {
                const time = entry.time.toLocaleTimeString();
                const date = entry.time.toISOString().split('T')[0];
                const text = entry.signature ? `<img src="${entry.text.split(' ')[2]}" alt="Signature" width="100">` : entry.text;
                listContent += `${index}. Time: ${time}  Date: ${date}  Data: ${text}\n`;
            });
            const htmlContent = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exoskeleton AI Data Sheet</title>
    <style>
        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            margin: 20px;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        pre {
            font-size: 14px;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-width: 800px;
            text-align: left;
        }
        h1 {
            font-size: 20px;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 5px #0f0;
        }
        img {
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <h1>WebXOS 2025 Exoskeleton AI</h1>
    <pre>${listContent}</pre>
</body>
</html>`;
            navigator.clipboard.writeText(htmlContent).then(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HTML data sheet copied to clipboard</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }).catch(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to copy HTML</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            });
        }

        function displayEntries(entries, header = 'Database contents:') {
            const timestamp = getFullTimestamp();
            let output = `<div class="entry"><span class="timestamp">[${timestamp}]</span>${header}</div>`;
            if (entries.length === 0) {
                output += `<div class="entry"><span class="timestamp">[${timestamp}]</span>No entries found</div>`;
            } else {
                entries.forEach((entry, index) => {
                    const displayText = entry.signature ? `<img src="${entry.miniSignature}" alt="Signature" width="50"> ${entry.text.split(' ').slice(3).join(' ')}` : entry.text;
                    output += `<div class="entry"><span class="timestamp">[${entry.time.toLocaleString()}]</span>[${index}] ${displayText}</div>`;
                });
            }
            consoleDiv.innerHTML += output;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function sortEntries(method) {
            let sorted = [...database];
            if (method === 'time-asc') {
                sorted.sort((a, b) => a.time - b.time);
            } else if (method === 'time-desc') {
                sorted.sort((a, b) => b.time - b.time);
            } else if (method === 'alpha-asc') {
                sorted.sort((a, b) => a.text.localeCompare(b.text));
            } else if (method === 'alpha-desc') {
                sorted.sort((a, b) => b.text.localeCompare(b.text));
            }
            database = sorted;
            displayEntries(database, 'Sorted database:');
        }

        function generateGrid(serial, dbData, encodedData) {
            currentSerial = serial;
            currentCode = dbData.code;
            generateImageFromSeed(dbData.code, serial, dbData, encodedData);
        }

        function generateImageFromSeed(code, serial, dbData = {}, encodedData = '') {
            hologram.innerHTML = '';
            const hash = hashCode(serial + encodedData);
            let seedValue = hash;
            const rand = (min, max) => {
                seedValue = hashCode(String(seedValue));
                return min + (seedValue % (max - min + 1));
            };
            const randFloat = (min, max) => {
                seedValue = hashCode(String(seedValue));
                return min + ((seedValue % 10000) / 10000) * (max - min);
            };
            const squareCount = rand(20, 50);
            const scale = 0.82; // Scale down by 18%
            for (let i = 0; i < squareCount; i++) {
                const square = document.createElement('div');
                square.className = 'grid-square';
                const size = randFloat(30, 80) * scale;
                square.style.width = `${size}px`;
                square.style.height = `${size}px`;
                const left = randFloat(0, 320 - size) * scale;
                const top = randFloat(0, 320 - size) * scale;
                const z = randFloat(-100, 100) * scale;
                const rotateX = randFloat(-30, 30);
                const rotateY = randFloat(-30, 30);
                square.style.left = `${left}px`;
                square.style.top = `${top}px`;
                square.style.transform = `translateZ(${z}px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
                square.style.opacity = randFloat(0.4, 0.8);
                square.style.background = `rgba(0,${rand(192, 255)},0,${randFloat(0.5, 0.8)})`;
                hologram.appendChild(square);
            }
            const strokes = serialMap.get(serial)?.strokes || [];
            if (strokes.length > 0) {
                const sigLayer = document.createElement('div');
                sigLayer.className = 'signature-layer';
                const sigCanvas = document.createElement('canvas');
                sigCanvas.width = 200;
                sigCanvas.height = 100;
                const sigCtx = sigCanvas.getContext('2d');
                drawSignatureStrokes(sigCanvas, sigCtx, strokes, 200, 100);
                sigLayer.appendChild(sigCanvas);
                hologram.appendChild(sigLayer);
            }
        }

        function clearConsole() {
            database = [];
            currentSerial = '';
            currentCode = '';
            consoleDiv.innerHTML = `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Console cleared</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            initializeGrid();
        }

        function copyContent() {
            if (currentSerial && currentCode) {
                const content = `${currentSerial}\n${currentCode}`;
                navigator.clipboard.writeText(content).then(() => {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Serial and code copied to clipboard</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                }).catch(() => {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to copy</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                });
            } else {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No serial or code to copy</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        function executeCommand() {
            const input = commandInput.value.trim();
            commandInput.value = '';
            if (!input) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Enter a command</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Command: ${input}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            const inputUpper = input.toUpperCase();
            if (inputUpper === 'HELP') {
                const helpText = `
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Available Commands:</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ADD [data] - Add entry to database</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>VIEW - Show all entries</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SEARCH [term] - Search entries</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>CLEAR - Clear console and current session</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SORT TIME-ASC - Sort by time ascending</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SORT TIME-DESC - Sort by time descending</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SORT ALPHA-ASC - Sort alphabetically ascending</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SORT ALPHA-DESC - Sort alphabetically descending</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>REPLACE# [data] - Replace entry at index # (e.g., REPLACE1 user1)</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>GENERATE - Generate grid with encoded database</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HTML - Generate HTML data sheet and copy to clipboard</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SIGN - Sign the current Exoskeleton AI</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HELP - Show this help</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Enter [serial] [code] to load grid (e.g., HOLO-000001-A7K Ω-CODE: ---111---)</div>
                `;
                consoleDiv.innerHTML += helpText;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } else if (inputUpper === 'SIGN') {
                showSignPopup();
            } else if (inputUpper.startsWith('ADD ')) {
                const data = input.substring(4);
                addToDatabase(data);
            } else if (inputUpper.startsWith('REPLACE')) {
                const match = inputUpper.match(/^REPLACE(\d+)\s+(.+)$/);
                if (!match) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid REPLACE format. Use REPLACE# [data]</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                const index = parseInt(match[1]);
                const data = match[2];
                replaceInDatabase(index, data);
            } else if (inputUpper === 'VIEW') {
                displayEntries(database);
            } else if (inputUpper.startsWith('SEARCH ')) {
                const term = input.substring(7).toLowerCase();
                const results = database.filter(entry => entry.text.toLowerCase().includes(term));
                displayEntries(results, `Search results for "${term}":`);
            } else if (inputUpper === 'CLEAR') {
                clearConsole();
            } else if (inputUpper === 'SORT TIME-ASC') {
                sortEntries('time-asc');
            } else if (inputUpper === 'SORT TIME-DESC') {
                sortEntries('time-desc');
            } else if (inputUpper === 'SORT ALPHA-ASC') {
                sortEntries('alpha-asc');
            } else if (inputUpper === 'SORT ALPHA-DESC') {
                sortEntries('alpha-desc');
            } else if (inputUpper === 'GENERATE') {
                generateDatabase();
            } else if (inputUpper === 'HTML') {
                generateHTML();
            } else {
                const args = input.trim();
                const match = args.match(/^(\S+)\s+(.+)$/);
                if (match) {
                    const userSerial = match[1];
                    const userCode = match[2];
                    loadGridFromSerial(userSerial, userCode);
                } else {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Unknown command or invalid serial/code format</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                }
            }
        }

        initializeGrid();
    </script>
</body>
</html>
