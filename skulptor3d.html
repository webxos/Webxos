<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Permissions-Policy" content="clipboard-write=(self)">
    <title>Skulptor3D</title>
    <style>
        body { font-family: monospace; margin: 0; padding: 10px; background: #000; color: #0f0; }
        #console, #error-console, #command-input, #py-input, canvas { border: 1px solid #0f0; background: #000; color: #0f0; }
        #console { width: 100%; height: 200px; overflow-y: auto; padding: 10px; font-size: 14px; }
        #error-console { width: 100%; height: 150px; overflow-y: auto; padding: 10px; font-size: 14px; margin-top: 10px; }
        #input-area { margin-top: 10px; display: flex; flex-direction: column; gap: 10px; }
        #command-input { padding: 10px; font-size: 16px; width: 100%; box-sizing: border-box; }
        #py-popup, #skulptor3d-popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 2px solid #0f0; padding: 15px; z-index: 1000; background: #000; }
        #py-input { width: 100%; height: 250px; font-family: monospace; font-size: 14px; box-sizing: border-box; }
        button { padding: 12px; font-size: 16px; cursor: pointer; width: 100%; box-sizing: border-box; background: #0f0; color: #000; }
        button:hover:not(:disabled) { background: #0c0; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #close-3d-popup { position: absolute; top: 5px; right: 5px; font-weight: bold; padding: 8px; font-size: 14px; background: #f00; color: #fff; }
        #close-3d-popup:hover { background: #c00; }
        #status-area { margin-bottom: 10px; }
        select { width: 100%; padding: 10px; border: 1px solid #0f0; font-size: 16px; box-sizing: border-box; background: #000; color: #0f0; }
        @media (min-width: 768px) {
            #input-area { flex-direction: row; }
            button { width: auto; }
            #command-input { width: 70%; }
            select { width: auto; }
        }
        .log-info { color: #0f0; }
        .log-error { color: #f00; }
        .log-warning { color: #ff0; }
        #log-output { display: none; margin-top: 10px; width: 100%; height: 100px; font-family: monospace; }
        .hidden { display: none; }
    </style>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.26.0/full/pyodide.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
</head>
<body>
    <div id="console" class="border" role="log" aria-live="polite"></div>
    <div id="error-console" class="border" role="log" aria-live="assertive"></div>
    <button id="copy-log-btn" disabled aria-label="Copy error log to clipboard">Copy Log</button>
    <div id="status-area">
        <span id="pyodide-status">Loading...</span> |
        <span id="webgpu-status">Checking...</span> |
        <span id="fps">0.00</span> FPS | <span id="memory">0.00</span> MB
    </div>
    <select id="game-mode" aria-label="Select game mode">
        <option value="3d">3D Mode</option>
        <option value="mars-trails">Mars Trails</option>
        <option value="snake">Snake</option>
    </select>
    <div id="input-area" class="flex flex-col md:flex-row gap-2">
        <input id="command-input" type="text" placeholder="Enter command" class="border" aria-label="Enter command">
        <button id="execute-btn" disabled aria-label="Execute command">Execute</button>
        <button id="inject-btn" disabled aria-label="Open code input popup">Inject</button>
        <button id="close-btn" disabled aria-label="Close code input popup">Close</button>
        <button id="troubleshoot-btn" disabled aria-label="Run troubleshooting diagnostics">Troubleshoot</button>
    </div>
    <div id="py-popup" class="hidden">
        <select id="code-type" aria-label="Select code type">
            <option value="py">Python (.py)</option>
            <option value="py3d">Skulptor3D (.py3d)</option>
        </select>
        <textarea id="py-input" placeholder="Paste Python or .py3d code" class="border" aria-label="Code input"></textarea><br>
        <button onclick="injectScript()" class="mt-2" aria-label="Inject code">Inject</button>
        <button onclick="closePopup()" class="mt-2" aria-label="Close code popup">Close</button>
    </div>
    <div id="skulptor3d-popup" class="hidden">
        <button id="close-3d-popup" onclick="close3DPopup()" aria-label="Close 3D canvas popup">X</button>
        <canvas id="skulptor3d-canvas" aria-label="3D rendering canvas"></canvas>
    </div>
    <textarea id="log-output" readonly placeholder="Error log for manual copy" aria-label="Error log output"></textarea>
    <script>
        let pyodide;
        let pyodideReady = false;
        let globalErrorLog = [];
        let glContext = null;
        let renderLoopRunning = false;
        let sceneObjects = [];
        let animations = [];
        let aliases = {};
        let groups = {};

        function addToErrorLog(level, message) {
            globalErrorLog.push({ timestamp: new Date().toISOString(), level, message });
            if (globalErrorLog.length > 100) globalErrorLog.shift();
            document.getElementById('error-console').innerHTML += `<div class="log-${level.toLowerCase()}">[${level}] ${message}</div>`;
            document.getElementById('error-console').scrollTop = document.getElementById('error-console').scrollHeight;
        }

        function simpleBPEEncode(code, iterations) {
            let tokens = code.split(/(\s+|[^\w\s])/).filter(t => t);
            let pairCounts = {};
            for (let i = 0; i < tokens.length - 1; i++) {
                const pair = `${tokens[i]} ${tokens[i + 1]}`;
                pairCounts[pair] = (pairCounts[pair] || 0) + 1;
            }
            for (let iter = 0; iter < iterations; iter++) {
                let maxPair = null;
                let maxCount = 0;
                for (const pair in pairCounts) {
                    if (pairCounts[pair] > maxCount) {
                        maxCount = pairCounts[pair];
                        maxPair = pair;
                    }
                }
                if (!maxPair) break;
                const [first, second] = maxPair.split(' ');
                const newToken = first + second;
                const newTokens = [];
                for (let i = 0; i < tokens.length; i++) {
                    if (i < tokens.length - 1 && tokens[i] === first && tokens[i + 1] === second) {
                        newTokens.push(newToken);
                        i++;
                    } else {
                        newTokens.push(tokens[i]);
                    }
                }
                tokens = newTokens;
                pairCounts = {};
                for (let i = 0; i < tokens.length - 1; i++) {
                    const pair = `${tokens[i]} ${tokens[i + 1]}`;
                    pairCounts[pair] = (pairCounts[pair] || 0) + 1;
                }
            }
            return tokens.join('');
        }

        function simpleBPEDecode(code) {
            return code;
        }

        async function loadPyodideWithFallback() {
            try {
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Loading Pyodide...</div>';
                pyodide = await loadPyodide({ indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.26.0/full/' });
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Pyodide loaded successfully</div>';
                return true;
            } catch (e) {
                addToErrorLog('ERROR', `${e.message}. Retrying...`);
                return await tryPyodideWorkaround();
            }
        }

        async function tryPyodideWorkaround() {
            try {
                const script = document.createElement('script');
                script.src = `https://cdn.jsdelivr.net/pyodide/v0.26.0/full/pyodide.js?t=${Date.now()}`;
                script.async = false;
                document.head.appendChild(script);
                await new Promise((resolve, reject) => {
                    script.onload = () => resolve();
                    script.onerror = () => reject(new Error('Failed to reload pyodide.js'));
                });
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Pyodide script reloaded, initializing...</div>';
                pyodide = await loadPyodide({ indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.26.0/full/' });
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Pyodide workaround successful</div>';
                return true;
            } catch (e) {
                addToErrorLog('ERROR', `Workaround failed: ${e.message}`);
                return false;
            }
        }

        async function initPy3D() {
            try {
                await pyodide.runPythonAsync(`
                    import js
                    from pyodide.ffi import create_proxy
                    import traceback

                    class Py3D:
                        def __init__(self):
                            try:
                                self.canvas = js.document.getElementById("skulptor3d-canvas")
                                self.shapes = []
                                self.animations = js.animations
                                self.groups = js.groups
                                js.console.log("Py3D initialized successfully")
                            except Exception as e:
                                js.addToErrorLog("ERROR", f"Py3D initialization failed: {str(e)}")

                        def add_cube(self, name, position, size, color, dimensions=3):
                            try:
                                if dimensions < 1 or dimensions > 8:
                                    raise ValueError("Dimensions must be between 1 and 8")
                                position = list(position) + [0] * (dimensions - len(position)) if len(position) < dimensions else position[:dimensions]
                                position = position[:3] if dimensions > 3 else position
                                shape = {
                                    "name": name,
                                    "type": "cube",
                                    "position": position,
                                    "size": size,
                                    "color": color,
                                    "dimensions": dimensions
                                }
                                self.shapes.append(shape)
                                js.sceneObjects.append(shape)
                                js.console.log(f"Added cube: {name}, dimensions: {dimensions}")
                            except Exception as e:
                                js.addToErrorLog("ERROR", f"Failed to add cube {name}: {str(e)}")

                        def add_point_cloud(self, name, points, colors, size, intensity=None):
                            try:
                                if len(points) != len(colors):
                                    raise ValueError("Points and colors must have the same length")
                                intensity = intensity or [1.0] * len(points)
                                shape = {
                                    "name": name,
                                    "type": "point_cloud",
                                    "points": points,
                                    "colors": colors,
                                    "size": size,
                                    "intensity": intensity
                                }
                                self.shapes.append(shape)
                                js.sceneObjects.append(shape)
                                js.console.log(f"Added point cloud: {name}, points: {len(points)}")
                            except Exception as e:
                                js.addToErrorLog("ERROR", f"Failed to add point cloud {name}: {str(e)}")

                        def set_camera(self, position, rotation):
                            try:
                                js.cameraPosition = list(position)[:3]
                                js.cameraRotation = list(rotation)[:3]
                                js.console.log(f"Camera set to position: {position}, rotation: {rotation}")
                            except Exception as e:
                                js.addToErrorLog("ERROR", f"Failed to set camera: {str(e)}")

                        def animate(self, name, position, duration, dimensions=3):
                            try:
                                if dimensions < 1 or dimensions > 8:
                                    raise ValueError("Dimensions must be between 1 and 8")
                                position = list(position) + [0] * (dimensions - len(position)) if len(position) < dimensions else position[:dimensions]
                                position = position[:3] if dimensions > 3 else position
                                animation = {
                                    "name": name,
                                    "target_position": position,
                                    "duration": duration,
                                    "start_time": js.performance.now() / 1000
                                }
                                self.animations.append(animation)
                                js.console.log(f"Animation added for {name} to position {position}")
                            except Exception as e:
                                js.addToErrorLog("ERROR", f"Failed to animate {name}: {str(e)}")

                        def group_objects(self, name, objects):
                            try:
                                self.groups[name] = objects
                                js.console.log(f"Group created: {name} with objects {objects}")
                            except Exception as e:
                                js.addToErrorLog("ERROR", f"Failed to create group {name}: {str(e)}")

                        def log_message(self, level, message):
                            try:
                                js.addToErrorLog(level, message)
                                js.console.log(f"Logged {level}: {message}")
                            except Exception as e:
                                js.addToErrorLog("ERROR", f"Failed to log message: {str(e)}")

                        def test_feature(self, name, command):
                            try:
                                exec(command)
                                js.addToErrorLog("INFO", f"Feature {name} test passed")
                            except Exception as e:
                                tb = ''.join(traceback.format_exception(type(e), e, e.__traceback__))
                                js.addToErrorLog("ERROR", f"Feature {name} test failed: {str(e)}\\nTraceback:\\n{tb}")

                        def clear_scene(self):
                            try:
                                self.shapes = []
                                self.groups = {}
                                js.sceneObjects = []
                                js.animations = []
                                js.groups = {}
                                js.console.log("Scene cleared")
                            except Exception as e:
                                js.addToErrorLog("ERROR", f"Failed to clear scene: {str(e)}")

                        async def test_suite(self):
                            try:
                                js.document.getElementById("console").innerHTML += '<div class="log-info">[INFO] Py3D test suite passed</div>'
                                js.console.log("Py3D test suite passed")
                            except Exception as e:
                                js.addToErrorLog("ERROR", f"Test suite failed: {str(e)}")

                    globals()['Py3D'] = Py3D
                `);
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Py3D module initialized</div>';
            } catch (e) {
                addToErrorLog('ERROR', `Py3D initialization failed: ${e.message}`);
            }
        }

        async function initPyodide() {
            try {
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Initializing Pyodide...</div>';
                const loaded = await loadPyodideWithFallback();
                if (!loaded) {
                    throw new Error('Pyodide initialization failed after retry attempts.');
                }
                await initPy3D();
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Pyodide initialized</div>';
                pyodideReady = true;
                document.getElementById('pyodide-status').textContent = 'Loaded';
                ['execute-btn', 'inject-btn', 'close-btn', 'troubleshoot-btn', 'copy-log-btn'].forEach(id => {
                    document.getElementById(id).disabled = false;
                });
                initWebGL();
                updatePerformance();
            } catch (e) {
                addToErrorLog('ERROR', `Pyodide init failed: ${e.message}`);
                document.getElementById('pyodide-status').textContent = 'Failed';
                disableInteractiveFeatures();
            }
        }

        function disableInteractiveFeatures() {
            ['execute-btn', 'inject-btn', 'close-btn', 'troubleshoot-btn', 'copy-log-btn'].forEach(id => {
                document.getElementById(id).disabled = true;
            });
        }

        function initWebGL() {
            if (!window.mat4) {
                addToErrorLog('ERROR', 'gl-matrix library not loaded correctly');
                document.getElementById('webgpu-status').textContent = 'Failed';
                return;
            }
            const canvas = document.getElementById('skulptor3d-canvas');
            glContext = canvas.getContext('webgl') || canvas.getContext('webgl2');
            if (glContext) {
                document.getElementById('webgpu-status').textContent = 'WebGL';
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] WebGL supported</div>';
                setupWebGL();
                startRenderLoop();
            } else {
                document.getElementById('webgpu-status').textContent = 'Not Supported';
                addToErrorLog('ERROR', 'Neither WebGPU nor WebGL supported');
            }
        }

        function setupWebGL() {
            const gl = glContext;
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);
            const vertexShaderSource = `
                attribute vec3 aPosition;
                attribute vec3 aColor;
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;
                uniform float uPointSize;
                varying vec3 vColor;
                void main() {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                    gl_PointSize = uPointSize;
                    vColor = aColor;
                }
            `;
            const fragmentShaderSource = `
                precision mediump float;
                varying vec3 vColor;
                void main() {
                    gl_FragColor = vec4(vColor, 1.0);
                }
            `;
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                addToErrorLog('ERROR', `Vertex shader compilation failed: ${gl.getShaderInfoLog(vertexShader)}`);
            }
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentShaderSource);
            gl.compileShader(fragmentShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                addToErrorLog('ERROR', `Fragment shader compilation failed: ${gl.getShaderInfoLog(fragmentShader)}`);
            }
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                addToErrorLog('ERROR', `Shader program linking failed: ${gl.getProgramInfoLog(program)}`);
            }
            gl.useProgram(program);
            glContext.program = program;
            glContext.aPosition = gl.getAttribLocation(program, 'aPosition');
            glContext.aColor = gl.getAttribLocation(program, 'aColor');
            glContext.uModelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
            glContext.uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');
            glContext.uPointSize = gl.getUniformLocation(program, 'uPointSize');
            const cubeVertices = new Float32Array([
                -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5,
                -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5,
                -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5,
                -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5,
                -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5,
                0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5, -0.5
            ]);
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);
            glContext.cubeVertexBuffer = vertexBuffer;
        }

        function startRenderLoop() {
            if (renderLoopRunning) return;
            renderLoopRunning = true;
            const gl = glContext;
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            const fov = 45 * Math.PI / 180;
            const aspect = gl.canvas.width / gl.canvas.height;
            const projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, fov, aspect, 0.1, 100.0);
            function render() {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                const viewMatrix = mat4.create();
                mat4.translate(viewMatrix, viewMatrix, window.cameraPosition || [0, 0, 5]);
                mat4.rotateX(viewMatrix, viewMatrix, (window.cameraRotation || [0, 0, 0])[0]);
                mat4.rotateY(viewMatrix, viewMatrix, (window.cameraRotation || [0, 0, 0])[1]);
                mat4.rotateZ(viewMatrix, viewMatrix, (window.cameraRotation || [0, 0, 0])[2]);
                const modelMatrix = mat4.create();
                const currentTime = performance.now() / 1000;
                animations.forEach(anim => {
                    const t = Math.min((currentTime - anim.start_time) / anim.duration, 1);
                    const shape = sceneObjects.find(obj => obj.name === anim.name);
                    if (shape) {
                        const startPos = shape.position;
                        const endPos = anim.target_position;
                        shape.position = [
                            startPos[0] + (endPos[0] - startPos[0]) * t,
                            startPos[1] + (endPos[1] - startPos[1]) * t,
                            startPos[2] + (endPos[2] - startPos[2]) * t
                        ];
                        if (t === 1) animations.splice(animations.indexOf(anim), 1);
                    }
                });
                sceneObjects.forEach(obj => {
                    if (obj.type === 'cube') {
                        mat4.identity(modelMatrix);
                        mat4.translate(modelMatrix, modelMatrix, obj.position);
                        mat4.scale(modelMatrix, modelMatrix, [obj.size, obj.size, obj.size]);
                        const modelViewMatrix = mat4.create();
                        mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);
                        gl.uniformMatrix4fv(glContext.uModelViewMatrix, false, modelViewMatrix);
                        gl.uniformMatrix4fv(glContext.uProjectionMatrix, false, projectionMatrix);
                        gl.uniform1f(glContext.uPointSize, 1.0);
                        gl.bindBuffer(gl.ARRAY_BUFFER, glContext.cubeVertexBuffer);
                        gl.vertexAttribPointer(glContext.aPosition, 3, gl.FLOAT, false, 0, 0);
                        gl.enableVertexAttribArray(glContext.aPosition);
                        gl.disableVertexAttribArray(glContext.aColor);
                        gl.vertexAttrib3f(glContext.aColor, obj.color[0], obj.color[1], obj.color[2]);
                        gl.drawArrays(gl.TRIANGLE_FAN, 0, 24);
                    } else if (obj.type === 'point_cloud') {
                        const vertices = new Float32Array(obj.points.flat());
                        const colors = new Float32Array(obj.colors.flat());
                        const pointBuffer = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                        const colorBuffer = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
                        mat4.identity(modelMatrix);
                        const modelViewMatrix = mat4.create();
                        mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);
                        gl.uniformMatrix4fv(glContext.uModelViewMatrix, false, modelViewMatrix);
                        gl.uniformMatrix4fv(glContext.uProjectionMatrix, false, projectionMatrix);
                        gl.uniform1f(glContext.uPointSize, obj.size * 10.0);
                        gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
                        gl.vertexAttribPointer(glContext.aPosition, 3, gl.FLOAT, false, 0, 0);
                        gl.enableVertexAttribArray(glContext.aPosition);
                        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                        gl.vertexAttribPointer(glContext.aColor, 3, gl.FLOAT, false, 0, 0);
                        gl.enableVertexAttribArray(glContext.aColor);
                        gl.drawArrays(gl.POINTS, 0, obj.points.length);
                        gl.deleteBuffer(pointBuffer);
                        gl.deleteBuffer(colorBuffer);
                    }
                });
                Object.keys(groups).forEach(groupName => {
                    const group = groups[groupName];
                    group.forEach(objName => {
                        const obj = sceneObjects.find(o => o.name === objName);
                        if (obj && obj.type === 'cube') {
                            mat4.identity(modelMatrix);
                            mat4.translate(modelMatrix, modelMatrix, obj.position);
                            mat4.scale(modelMatrix, modelMatrix, [obj.size, obj.size, obj.size]);
                            const modelViewMatrix = mat4.create();
                            mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);
                            gl.uniformMatrix4fv(glContext.uModelViewMatrix, false, modelViewMatrix);
                            gl.uniformMatrix4fv(glContext.uProjectionMatrix, false, projectionMatrix);
                            gl.uniform1f(glContext.uPointSize, 1.0);
                            gl.bindBuffer(gl.ARRAY_BUFFER, glContext.cubeVertexBuffer);
                            gl.vertexAttribPointer(glContext.aPosition, 3, gl.FLOAT, false, 0, 0);
                            gl.enableVertexAttribArray(glContext.aPosition);
                            gl.disableVertexAttribArray(glContext.aColor);
                            gl.vertexAttrib3f(glContext.aColor, obj.color[0], obj.color[1], obj.color[2]);
                            gl.drawArrays(gl.TRIANGLE_FAN, 0, 24);
                        }
                    });
                });
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }

        function updatePerformance() {
            let lastTime = performance.now();
            let frameCount = 0;
            function loop(currentTime) {
                frameCount++;
                const delta = currentTime - lastTime;
                if (delta >= 1000) {
                    const fps = (frameCount * 1000 / delta).toFixed(2);
                    document.getElementById('fps').textContent = fps;
                    if (performance.memory) {
                        const memory = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2);
                        document.getElementById('memory').textContent = memory;
                    }
                    frameCount = 0;
                    lastTime = currentTime;
                }
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        }

        function parsePy3D(code) {
            let bpeIterations = 0;
            const lines = code.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith('#'));
            const commands = [];
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                try {
                    if (line.startsWith('tokenize bpe')) {
                        const match = line.match(/tokenize bpe\s*,\s*iterations=(\d+)/);
                        if (!match) throw new Error('Invalid tokenize syntax');
                        bpeIterations = parseInt(match[1]);
                        continue;
                    }
                    if (bpeIterations > 0) {
                        line = simpleBPEDecode(simpleBPEEncode(line, bpeIterations));
                    }
                    if (line.startsWith('alias')) {
                        const match = line.match(/alias\s+name=(\w+)\s*,\s*command="([^"]+)"/);
                        if (!match) throw new Error('Invalid alias syntax');
                        const [, aliasName, command] = match;
                        aliases[aliasName] = command;
                        continue;
                    }
                    if (line.startsWith('group')) {
                        const match = line.match(/group\s+name=(\w+)\s*,\s*objects=\[([^\]]+)\]/);
                        if (!match) throw new Error('Invalid group syntax');
                        const [, groupName, objects] = match;
                        commands.push(`Py3D().group_objects("${groupName}", [${objects.split(',').map(o => `"${o.trim()}"`).join(',')}]);`);
                        continue;
                    }
                    if (line.startsWith('log_message')) {
                        const match = line.match(/log_message\s+level=(\w+)\s*,\s*message="([^"]+)"/);
                        if (!match) throw new Error('Invalid log_message syntax');
                        const [, level, message] = match;
                        if (!['INFO', 'ERROR', 'WARNING'].includes(level)) throw new Error('Invalid log level');
                        commands.push(`Py3D().log_message("${level}", "${message}");`);
                        continue;
                    }
                    if (line.startsWith('test_feature')) {
                        const match = line.match(/test_feature\s+name=(\w+)\s*,\s*command="([^"]+)"/);
                        if (!match) throw new Error('Invalid test_feature syntax');
                        const [, name, command] = match;
                        commands.push(`Py3D().test_feature("${name}", "${command.replace(/"/g, '\\"')}");`);
                        continue;
                    }
                    for (const alias in aliases) {
                        if (line.startsWith(alias)) {
                            const params = line.slice(alias.length).trim().split(/\s*,\s*/);
                            let cmd = aliases[alias];
                            params.forEach((param, idx) => {
                                cmd = cmd.replace(`$${idx + 1}`, param);
                            });
                            line = cmd;
                        }
                    }
                    if (line.startsWith('add_shape')) {
                        const match = line.match(/add_shape\s+(\w+)\s*,\s*name=(\w+)\s*,\s*position=\(([^)]+)\)\s*,\s*size=(\d+\.?\d*)\s*,\s*color=\(([^)]+)\)(?:\s*,\s*dimensions=(\d+))?/);
                        if (!match) throw new Error('Invalid add_shape syntax');
                        const [, type, name, position, size, color, dimensions = '3'] = match;
                        if (type !== 'cube' && type !== 'hypercube') throw new Error(`Unsupported shape type: ${type}`);
                        commands.push(`Py3D().add_cube("${name}", [${position}], ${size}, [${color}], ${dimensions});`);
                    } else if (line.startsWith('add_point_cloud')) {
                        const match = line.match(/add_point_cloud\s+name=(\w+)\s*,\s*points=\[([^\]]+)\]\s*,\s*colors=\[([^\]]+)\]\s*,\s*size=(\d+\.?\d*)(?:\s*,\s*intensity=\[([^\]]+)\])?/);
                        if (!match) throw new Error('Invalid add_point_cloud syntax');
                        const [, name, points, colors, size, intensity] = match;
                        const pointList = points.split('),(').map(p => p.replace(/[()]/g, '').split(',').map(Number));
                        const colorList = colors.split('),(').map(c => c.replace(/[()]/g, '').split(',').map(Number));
                        const intensityList = intensity ? intensity.split(',').map(Number) : null;
                        commands.push(`Py3D().add_point_cloud("${name}", ${JSON.stringify(pointList)}, ${JSON.stringify(colorList)}, ${size}, ${intensityList ? JSON.stringify(intensityList) : 'null'});`);
                    } else if (line.startsWith('set_camera')) {
                        const match = line.match(/set_camera\s*position=\(([^)]+)\)\s*,\s*rotation=\(([^)]+)\)/);
                        if (!match) throw new Error('Invalid set_camera syntax');
                        const [, position, rotation] = match;
                        commands.push(`Py3D().set_camera([${position}], [${rotation}]);`);
                    } else if (line.startsWith('animate')) {
                        const match = line.match(/animate\s+name=(\w+)\s*,\s*position=\(([^)]+)\)\s*,\s*duration=(\d+\.?\d*)(?:\s*,\s*dimensions=(\d+))?/);
                        if (!match) throw new Error('Invalid animate syntax');
                        const [, name, position, duration, dimensions = '3'] = match;
                        commands.push(`Py3D().animate("${name}", [${position}], ${duration}, ${dimensions});`);
                    } else if (line.startsWith('clear_scene')) {
                        commands.push(`Py3D().clear_scene();`);
                    } else {
                        throw new Error(`Unknown command: ${line}`);
                    }
                } catch (e) {
                    addToErrorLog('ERROR', `Line ${i + 1}: ${e.message}`);
                    continue;
                }
            }
            return commands.join('\n');
        }

        function showPopup() {
            if (!pyodideReady) {
                addToErrorLog('ERROR', 'Pyodide not ready');
                return;
            }
            document.getElementById('py-popup').style.display = 'block';
        }

        function closePopup() {
            document.getElementById('py-popup').style.display = 'none';
            document.getElementById('py-input').value = '';
        }

        function show3DPopup() {
            document.getElementById('skulptor3d-popup').style.display = 'block';
            resizeCanvas();
        }

        function close3DPopup() {
            document.getElementById('skulptor3d-popup').style.display = 'none';
        }

        async function executeCommand() {
            if (!pyodideReady) {
                addToErrorLog('ERROR', 'Pyodide not ready');
                return;
            }
            const cmd = document.getElementById('command-input').value.trim();
            try {
                if (cmd === '/test') {
                    await pyodide.runPythonAsync(`await Py3D().test_suite()`);
                } else if (cmd === '/show3d') {
                    show3DPopup();
                } else {
                    await pyodide.runPythonAsync(cmd);
                }
                document.getElementById('console').innerHTML += `<div class="log-info">[INFO] Command executed successfully</div>`;
            } catch (err) {
                addToErrorLog('ERROR', err.message);
            }
            document.getElementById('command-input').value = '';
            document.getElementById('console').scrollTop = document.getElementById('console').scrollHeight;
        }

        async function injectScript() {
            if (!pyodideReady) {
                addToErrorLog('ERROR', 'Pyodide not ready');
                return;
            }
            const code = document.getElementById('py-input').value.trim();
            const codeType = document.getElementById('code-type').value;
            if (!code) {
                document.getElementById('console').innerHTML += '<div class="log-warning">[WARNING] No code to inject</div>';
                return;
            }
            try {
                const py3dAvailable = await pyodide.runPythonAsync(`'Py3D' in globals()`);
                if (!py3dAvailable) {
                    throw new Error('Py3D class not initialized');
                }
                if (codeType === 'py3d') {
                    const parsed = parsePy3D(code);
                    if (!parsed) throw new Error('Failed to parse .py3d code');
                    await pyodide.runPythonAsync(parsed);
                    show3DPopup();
                } else {
                    await pyodide.runPythonAsync(code);
                }
                document.getElementById('console').innerHTML += `<div class="log-info">[INFO] Script injected successfully</div>`;
                closePopup();
            } catch (err) {
                addToErrorLog('ERROR', `🐍 ${err.message}`);
            }
        }

        async function runTroubleshoot() {
            if (!pyodideReady) {
                addToErrorLog('ERROR', 'Pyodide not ready');
                return;
            }
            document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Initiating troubleshooting...</div>';
            const checks = [
                { id: 1, test: 'WebGL initialization', fn: () => glContext ? 'OK' : 'Failed' },
                { id: 2, test: 'Vertex shader', fn: () => glContext && glContext.program ? 'OK' : 'Failed' },
                { id: 3, test: 'Fragment shader', fn: () => glContext && glContext.program ? 'OK' : 'Failed' },
                { id: 4, test: 'Scene rendering', fn: () => sceneObjects.length > 0 ? 'OK' : 'No objects' },
                { id: 5, test: 'Animation', fn: () => animations.length > 0 ? 'OK' : 'No animations' },
                { id: 6, test: 'gl-matrix', fn: () => window.mat4 ? 'OK' : 'Failed' },
                { id: 7, test: 'Clipboard API', fn: async () => {
                    try {
                        await navigator.permissions.query({ name: 'clipboard-write' });
                        return 'OK';
                    } catch {
                        return 'Blocked';
                    }
                }},
                { id: 8, test: 'Point cloud rendering', fn: () => sceneObjects.some(obj => obj.type === 'point_cloud') ? 'OK' : 'No point clouds' }
            ];
            for (const check of checks) {
                const result = await check.fn();
                if (result === 'OK') {
                    document.getElementById('console').innerHTML += `<div class="log-info">[CHECK ${check.id}] ${check.test}: ${result}</div>`;
                } else {
                    addToErrorLog('ERROR', `[CHECK ${check.id}] ${check.test}: ${result}`);
                }
            }
            document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Troubleshooting completed</div>';
        }

        async function copyErrorLog() {
            if (!globalErrorLog.length) {
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] No errors to copy</div>';
                return;
            }
            const logText = globalErrorLog.map(entry => `[${entry.timestamp}] [${entry.level}] ${entry.message}`).join('\n');
            const logOutput = document.getElementById('log-output');
            logOutput.value = logText;
            logOutput.style.display = 'block';
            document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Error log displayed for manual copy. Copy from textarea if clipboard is blocked.</div>';
            try {
                await navigator.clipboard.writeText(logText);
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Error log copied to clipboard</div>';
                logOutput.style.display = 'none';
            } catch (err) {
                addToErrorLog('ERROR', `Clipboard write failed: ${err.message}. Please copy the log manually from the displayed textarea. See https://crbug.com/414348233 for details.`);
            }
        }

        function resizeCanvas() {
            const canvas = document.getElementById('skulptor3d-canvas');
            if (canvas) {
                const dpr = window.devicePixelRatio || 1;
                const width = Math.min(window.innerWidth - 40, 800);
                const height = Math.min(window.innerHeight - 300, 600);
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = `${width}px`;
                canvas.style.height = `${height}px`;
                if (glContext) {
                    glContext.viewport(0, 0, canvas.width, canvas.height);
                }
            }
        }

        window.addEventListener('resize', resizeCanvas);
        document.getElementById('execute-btn').onclick = executeCommand;
        document.getElementById('inject-btn').onclick = showPopup;
        document.getElementById('close-btn').onclick = closePopup;
        document.getElementById('troubleshoot-btn').onclick = runTroubleshoot;
        document.getElementById('copy-log-btn').onclick = copyErrorLog;
        document.getElementById('game-mode').onchange = function() {
            if (this.value === 'snake') {
                document.getElementById('code-type').value = 'py3d';
                document.getElementById('py-input').value = document.getElementById('snake-agent').textContent;
                showPopup();
            }
        };
        initPyodide();
        resizeCanvas();
    </script>
    <script type="text/py3d" id="snake-agent">
# snake.py3d - Solid Snake Test Agent
# One-shot mission to uncover errors and weaknesses in Skulptor3D

alias name=cube, command="add_shape cube, name=$1, position=$2, size=$3, color=$4"
log_message level=INFO, message="Reporting in, Chief! Agent Snake infiltrating Skulptor3D with agentic speed..."
clear_scene
log_message level=INFO, message="Mission: Test all .py3d features, expose weaknesses, and deploy a visualization. Codec ready!"

# Test camera setup
test_feature name=camera, command="Py3D().set_camera([0, 2, 5], [0.4, 0.6, 0])"

# Test cube creation
test_feature name=cube, command="Py3D().add_cube('snake_head', [0, 0, 0], 0.5, [0, 1, 0], 3)"

# Test point cloud with LiDAR-inspired data
test_feature name=point_cloud, command="Py3D().add_point_cloud('scan', [[1,1,1],[-1,1,-1],[1,-1,1],[-1,-1,-1]], [[1,0,0],[0,1,0],[0,0,1],[1,1,0]], 0.1, [1,0.8,0.6,0.4])"

# Test 4D hypercube
test_feature name=hypercube, command="Py3D().add_cube('tesseract', [2,0,0,0], 0.8, [0.5,0.5,1], 4)"

# Test animation
test_feature name=animation, command="Py3D().animate('snake_head', [1, 0.5, 0], 2, 3)"

# Test grouping
test_feature name=group, command="Py3D().group_objects('snake', ['snake_head'])"

# Test BPE tokenization
test_feature name=tokenize, command="Py3D().log_message('INFO', simpleBPEDecode(simpleBPEEncode('add_shape cube, name=test, position=(0,0,0), size=0.5, color=(0,1,0)', 5)))"

# Deploy visualization
cube snake_head, (0, 0, 0), 0.5, (0, 1, 0)
cube snake_body, (-0.6, 0, 0), 0.5, (0, 0.8, 0)
add_point_cloud name=scan, points=[(1,1,1),(-1,1,-1),(1,-1,1),(-1,-1,-1)], colors=[(1,0,0),(0,1,0),(0,0,1),(1,1,0)], size=0.1
add_shape hypercube, name=tesseract, position=(2,0,0,0), size=0.8, color=(0.5,0.5,1), dimensions=4
animate name=snake_head, position=(1, 0.5, 0), duration=2
group name=snake, objects=[snake_head, snake_body]

# Mini-review
log_message level=INFO, message="Snake here. Strengths: Solid WebGL integration, flexible .py3d syntax, LLM-friendly design."
log_message level=WARNING, message="Weaknesses: Basic BPE tokenization, regex parser is fragile, no WebGPU support yet."
log_message level=INFO, message="Mission complete. If hostiles (errors) persist, check the traceback in the log. *Snake out.*"
    </script>
</body>
</html>
