<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Skulptor3D</title>
    <style>
        body { font-family: monospace; background: #000; color: #0f0; margin: 0; padding: 10px; }
        #console { width: 100%; height: 200px; overflow-y: auto; border: 1px solid #0f0; padding: 10px; background: #000; font-size: 14px; }
        #input-area { margin-top: 10px; display: flex; flex-direction: column; gap: 10px; }
        #command-input { padding: 10px; background: #000; color: #0f0; border: 1px solid #0f0; font-size: 16px; width: 100%; box-sizing: border-box; }
        #py-popup, #skulptor3d-popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #000; border: 2px solid #0f0; padding: 15px; z-index: 1000; }
        #py-input { width: 100%; height: 250px; background: #000; color: #0f0; border: 1px solid #0f0; font-family: monospace; font-size: 14px; box-sizing: border-box; }
        button { background: #0f0; color: #000; border: none; padding: 12px; font-size: 16px; cursor: pointer; width: 100%; box-sizing: border-box; }
        button:hover { background: #0c0; }
        #close-3d-popup { position: absolute; top: 5px; right: 5px; background: #f00; color: #fff; font-weight: bold; padding: 8px; font-size: 14px; }
        #close-3d-popup:hover { background: #c00; }
        #mode-selector { margin-top: 10px; width: 100%; padding: 10px; background: #000; color: #0f0; border: 1px solid #0f0; font-size: 16px; box-sizing: border-box; }
        canvas { border: 1px solid #0f0; background: #000; width: 100%; max-width: 800px; box-sizing: border-box; }
        @media (min-width: 768px) {
            #input-area { flex-direction: row; }
            button { width: auto; }
            #command-input { width: 70%; }
            #mode-selector { width: auto; }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.28.0/full/pyodide.js"></script>
</head>
<body>
    <div id="console"></div>
    <div id="mode-selector">
        <select id="game-mode">
            <option value="3d">3D Mode</option>
            <option value="mars-trails">Mars Trails</option>
        </select>
    </div>
    <div id="input-area">
        <input id="command-input" type="text" placeholder="Enter command">
        <button id="execute-btn">Execute</button>
        <button id="inject-btn">Inject</button>
        <button id="eject-btn">Eject</button>
        <button id="troubleshoot-btn">Troubleshoot</button>
    </div>
    <div id="py-popup">
        <textarea id="py-input" placeholder="Paste Python code here"></textarea><br>
        <button onclick="injectScript()">Inject</button>
        <button onclick="closePopup()">Close</button>
    </div>
    <div id="skulptor3d-popup">
        <button id="close-3d-popup" onclick="close3DPopup()">X</button>
        <canvas id="skulptor3d-canvas"></canvas>
    </div>
    <script type="text/pyodide">
import asyncio
import platform
import json
from datetime import datetime
import numpy as np
import random

class Skulptor3D:
    def __init__(self, config=None):
        self.config = config or {
            'canvas_width': 800, 'canvas_height': 600, 'target_fps': 60,
            'canvas_id': 'skulptor3d-canvas', 'popup_id': 'skulptor3d-popup',
            'log_format': 'json'
        }
        self.canvas = None
        self.error_log = []
        self.rotation = 0.0
        self._check_js_module()

    def _check_js_module(self):
        try:
            import js
            self.js_available = True
            self.log("JavaScript bridge loaded", "INFO")
        except ModuleNotFoundError:
            self.js_available = False
            self.log("JavaScript bridge unavailable", "ERROR")
            self.error_log.append({'error': 'No js module', 'fix': 'Ensure Pyodide initialized'})

    def log(self, message, level="INFO"):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        if self.config['log_format'] == 'json':
            print(json.dumps({'timestamp': timestamp, 'level': level, 'message': message}))
            if level in ("ERROR", "WARNING"): 
                self.error_log.append({'timestamp': timestamp, 'level': level, 'message': message})
        else:
            print(f"[{timestamp}] [{level}] {message}")
            if level in ("ERROR", "WARNING"): 
                self.error_log.append(f"{timestamp}: {message}")

    async def initialize_webgpu(self):
        if not self.js_available: 
            self.log("WebGPU initialization skipped: JS bridge unavailable", "ERROR")
            return False
        try:
            import js
            if not hasattr(js.navigator, 'gpu'):
                self.log("WebGPU not supported in this browser", "ERROR")
                return False
            adapter = await js.navigator.gpu.requestAdapter()
            if not adapter:
                self.log("No GPU adapter found", "ERROR")
                return False
            self.device = await adapter.requestDevice()
            canvas = js.document.getElementById(self.config['canvas_id'])
            if not canvas:
                self.log("Canvas not found", "ERROR")
                return False
            self.canvas = canvas
            self.canvas.width = self.config['canvas_width']
            self.canvas.height = self.config['canvas_height']
            self.context = canvas.getContext('webgpu')
            if not self.context:
                self.log("Failed to get WebGPU context", "ERROR")
                return False
            self.context.configure({
                'device': self.device, 
                'format': js.navigator.gpu.getPreferredCanvasFormat(),
                'alphaMode': 'premultiplied'
            })
            self.log("WebGPU initialized", "INFO")
            return True
        except Exception as e:
            self.log(f"WebGPU init failed: {str(e)}", "ERROR")
            return False

    def show_3d_popup(self):
        if not self.js_available: 
            self.log("Popup creation skipped: JS bridge unavailable", "ERROR")
            return False
        try:
            import js
            popup = js.document.getElementById(self.config['popup_id'])
            if not popup:
                popup = js.document.createElement('div')
                popup.id = self.config['popup_id']
                popup.style.cssText = 'background:#000;border:2px solid #0f0;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:1000;padding:10px'
                js.document.body.appendChild(popup)
            popup.style.display = 'block'
            return True
        except Exception as e:
            self.log(f"Popup failed: {str(e)}", "ERROR")
            return False

    def create_canvas(self):
        if not self.js_available: 
            self.log("Canvas creation skipped: JS bridge unavailable", "ERROR")
            return False
        try:
            import js
            if not self.show_3d_popup(): 
                return False
            self.canvas = js.document.getElementById(self.config['canvas_id'])
            if not self.canvas:
                self.canvas = js.document.createElement('canvas')
                self.canvas.id = self.config['canvas_id']
                self.canvas.width = self.config['canvas_width']
                self.canvas.height = self.config['canvas_height']
                self.canvas.style.cssText = 'border:1px solid #0f0;background:#000'
                js.document.getElementById(self.config['popup_id']).appendChild(self.canvas)
            return True
        except Exception as e:
            self.log(f"Canvas creation failed: {str(e)}", "ERROR")
            return False

    async def render_3d(self):
        if not self.device or not self.context: 
            self.log("Rendering skipped: WebGPU not initialized", "ERROR")
            return False
        try:
            import js
            shader_module = self.device.createShaderModule({
                'code': f"""
                    @vertex
                    fn vertex_main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {{
                        let m = mat4x4<f32>(
                            cos({self.rotation}), -sin({self.rotation}), 0.0, 0.0,
                            sin({self.rotation}), cos({self.rotation}), 0.0, 0.0,
                            0.0, 0.0, 1.0, 0.0,
                            0.0, 0.0, 0.0, 1.0
                        );
                        let p = mat4x4<f32>(
                            2.0/{self.config['canvas_width']}, 0.0, 0.0, 0.0,
                            0.0, -2.0/{self.config['canvas_height']}, 0.0, 0.0,
                            0.0, 0.0, -1.0, 0.0,
                            -1.0, 1.0, 0.0, 1.0
                        );
                        return p * m * vec4<f32>(pos, 1.0);
                    }}
                    @fragment
                    fn fragment_main() -> @location(0) vec4<f32> {{
                        return vec4<f32>(0.0, 1.0, 0.0, 1.0);
                    }}
                """
            })
            pipeline = self.device.createRenderPipeline({
                'layout': 'auto',
                'vertex': {
                    'module': shader_module,
                    'entryPoint': 'vertex_main',
                    'buffers': [{
                        'arrayStride': 12,
                        'attributes': [{
                            'shaderLocation': 0,
                            'offset': 0,
                            'format': 'float32x3'
                        }]
                    }]
                },
                'fragment': {
                    'module': shader_module,
                    'entryPoint': 'fragment_main',
                    'targets': [{
                        'format': js.navigator.gpu.getPreferredCanvasFormat()
                    }]
                },
                'primitive': {'topology': 'triangle-list'}
            })
            vertices = js.Float32Array.new([
                -0.5, -0.5, 0.0,
                 0.5, -0.5, 0.0,
                 0.0,  0.5, 0.0
            ])
            vertex_buffer = self.device.createBuffer({
                'size': vertices.length * 4,
                'usage': js.GPUBufferUsage.VERTEX | js.GPUBufferUsage.COPY_DST
            })
            self.device.queue.writeBuffer(vertex_buffer, 0, vertices)

            async def render_loop():
                for _ in range(10):  # Limited iterations for testing
                    self.rotation += 0.01
                    encoder = self.device.createCommandEncoder()
                    pass_encoder = encoder.beginRenderPass({
                        'colorAttachments': [{
                            'view': self.context.getCurrentTexture().createView(),
                            'clearValue': [0.0, 0.0, 0. премьеры0, 1.0],
                            'loadOp': 'clear',
                            'storeOp': 'store'
                        }]
                    })
                    pass_encoder.setPipeline(pipeline)
                    pass_encoder.setVertexBuffer(0, vertex_buffer)
                    pass_encoder.draw(3)
                    pass_encoder.end()
                    self.device.queue.submit([encoder.finish()])
                    await asyncio.sleep(1.0 / self.config['target_fps'])
                self.log("Rendering test completed", "INFO")

            asyncio.ensure_future(render_loop())
            self.log("Rendering started", "INFO")
            return True
        except Exception as e:
            self.log(f"Render failed: {str(e)}", "ERROR")
            return False

    async def mars_trails(self):
        state = {
            "crew health": 100, "morale": 100},
            "resources": {"fuel": 100, "oxygen": 100, "food": 100},
            "distance": 0, "day": 1, "max_distance": 1000
        }
        def print_status(s): 
            print(f"Day {s['day']} | Distance: {s['distance']}/{s['max_distance']} km\nCrew: Health={s['crew']['health']}, Morale={s['crew']['morale']}\nResources: Fuel={s['resources']['fuel']}, Oxygen={s['.resources']['oxygen']}, Food={s['resources']['food']}")
        def print_help(): 
            print("Commands: help, status, trade, continue, quit")
        def handle_event(s): 
            event = random.choice([
                ("Meteor!", {"fuel": -10, "health": -15}),
                ("Storm", {"fuel": -5, "distance": -10}),
                ("Supplies!", {"fuel": 10, "oxygen": 10}),
                ("Signal!", {"morale": 15}),
                ("Glitch", {"fuel": -15})
            ])
            print(f"Event: {event[0]}")
            for k, v in event[1].items():
                target = "crew" if k in s["crew"] else "resources"
                s[target][k] = max(0, s[target].get(k, 0) + v) if k != "distance" else max(0, s["distance"] + v)
            return s
        def trade_resources(s):
            try:
                import js
                cmd = js.document.getElementById('command-input').value.strip().lower()
                js.document.getElementById('command-input').value = ""
                if cmd == "cancel": 
                    return s
                amount, res = cmd.split()
                amount = int(amount)
                if res not in ["food", "oxygen"] or amount <= 0 or s["resources"]["fuel"] < amount:
                    print("Invalid trade")
                    return s
                s["resources"]["fuel"] -= amount
                s["resources"][res] += amount
                print(f"Traded {amount} fuel for {amount} {res}")
            except Exception as e:
                print(f"Invalid trade format: {str(e)}")
            return s
        def check_game_over(s): 
            if s["crew"]["health"] <= 0 or any(s["resources"][r] <= 0 for r in ["fuel", "oxygen", "food"]):
                print("Game Over: Depleted")
                return True
            if s["distance"] >= s["max_distance"]:
                print("Victory: Reached Mars!")
                return True
            return False

        print("Welcome to Mars Trails! Type 'help' for commands.")
        for _ in range(3):  # Limited iterations for testing
            try:
                import js
                cmd = "status"  # Simulate command for testing
                if cmd == "help":
                    print_help()
                elif cmd == "status":
                    print_status(state)
                elif cmd == "trade":
                    state = trade_resources(state)
                elif cmd == "continue":
                    state["day"] += 1
                    state["distance"] += random.randint(50, 100)
                    for r in ["fuel", "oxygen", "food"]:
                        state["resources"][r] = max(0, state["resources"][r] - random.randint(5, 15 if r == "fuel" else 10))
                    state["crew"]["health"] = max(0, state["crew"]["health"] - random.randint(0, 5))
                    state["crew"]["morale"] = max(0, state["crew"]["morale"] - random.randint(0, 5))
                    print_status(state)
                    state = handle_event(state)
                    if check_game_over(state):
                        break
                elif cmd == "quit":
                    print("Mission aborted")
                    break
                else:
                    print("Unknown command")
            except Exception as e:
                self.log(f"Mars Trails error: {str(e)}", "ERROR")
                break
            await asyncio.sleep(0.1)
        self.log("Mars Trails test completed", "INFO")

    async def test_suite(self):
        errors = []
        try:
            import js
            import sys
            import numpy
            # Test 1: Pyodide and Dependencies
            try:
                self.log(f"Python version: {sys.version}", "INFO")
                self.log(f"Numpy version: {numpy.__version__}", "INFO")
            except Exception as e:
                errors.append(f"Pyodide/Dependency Error: {str(e)}")

            # Test 2: WebGPU Initialization
            if not await self.initialize_webgpu():
                errors.append("WebGPU Initialization Failed")

            # Test 3: Popup and Canvas
            try:
                if not self.show_3d_popup():
                    errors.append("Failed to show 3D popup")
                if not self.create_canvas():
                    errors.append("Failed to create canvas")
            except Exception as e:
                errors.append(f"Popup/Canvas Error: {str(e)}")

            # Test 4: Rendering
            try:
                if not await self.render_3d():
                    errors.append("Rendering Failed")
            except Exception as e:
                errors.append(f"Rendering Error: {str(e)}")

            # Test 5: Mars Trails
            try:
                await self.mars_trails()
            except Exception as e:
                errors.append(f"Mars Trails Error: {str(e)}")

            # Test 6: UI Components
            try:
                console = js.document.getElementById('console')
                input_area = js.document.getElementById('command-input')
                mode_selector = js.document.getElementById('game-mode')
                buttons = js.document.querySelectorAll('button')
                if not console or not input_area or not mode_selector or buttons.length < 4:
                    errors.append("UI Components Missing")
                else:
                    self.log("UI Components Verified", "INFO")
            except Exception as e:
                errors.append(f"UI Error: {str(e)}")

            # Output Test Results
            if errors:
                self.log("Test Suite Completed with Errors:", "ERROR")
                for error in errors:
                    self.log(error, "ERROR")
            else:
                self.log("Test Suite Completed: All Tests Passed", "INFO")
        except Exception as e:
            self.log(f"Test Suite Failed: {str(e)}", "ERROR")

if platform.system() == "Emscripten":
    asyncio.ensure_future(Skulptor3D().test_suite())
    </script>
    <script>
        let pyodide;
        async function initPyodide() {
            try {
                document.getElementById('console').innerHTML += '[INFO] Initializing Pyodide...<br>';
                pyodide = await loadPyodide({ indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.28.0/full/' });
                await pyodide.loadPackage(['micropip']);
                await pyodide.runPythonAsync(`
                    import micropip
                    await micropip.install(['numpy'])
                    print("[INFO] Packages loaded successfully")
                `);
                document.getElementById('console').innerHTML += '[INFO] Pyodide initialized<br>';
                await pyodide.runPythonAsync(document.querySelector('script[type="text/pyodide"]').textContent);
            } catch (e) {
                document.getElementById('console').innerHTML += `[ERROR] Pyodide init failed: ${e}<br>`;
            }
        }

        function showPopup() { document.getElementById('py-popup').style.display = 'block'; }
        function closePopup() { document.getElementById('py-popup').style.display = 'none'; document.getElementById('py-input').value = ''; }
        function show3DPopup() { document.getElementById('skulptor3d-popup').style.display = 'block'; }
        function close3DPopup() { document.getElementById('skulptor3d-popup').style.display = 'none'; }

        async function executeCommand() {
            if (!pyodide) return;
            const cmd = document.getElementById('command-input').value.trim();
            try {
                const mode = document.getElementById('game-mode').value;
                if (cmd === '/test') {
                    await pyodide.runPythonAsync(`
                        from __main__ import Skulptor3D
                        await Skulptor3D().test_suite()
                    `);
                } else if (mode === 'mars-trails' && cmd.toLowerCase() !== 'start') {
                    document.getElementById('console').innerHTML += '[INFO] Type "start" to begin Mars Trails<br>';
                } else if (mode === 'mars-trails' && cmd.toLowerCase() === 'start') {
                    await pyodide.runPythonAsync(`
                        from __main__ import Skulptor3D
                        await Skulptor3D().mars_trails()
                    `);
                } else {
                    await pyodide.runPythonAsync(cmd);
                }
            } catch (err) {
                document.getElementById('console').innerHTML += `[ERROR] ${err}<br>`;
            }
            document.getElementById('command-input').value = '';
            document.getElementById('console').scrollTop = document.getElementById('console').scrollHeight;
        }

        async function injectScript() {
            if (!pyodide) return;
            const code = document.getElementById('py-input').value;
            try {
                await pyodide.runPythonAsync(code);
                closePopup();
            } catch (err) {
                document.getElementById('console').innerHTML += `[ERROR] Injection failed: ${err}<br>`;
            }
        }

        async function runTroubleshooting() {
            if (!pyodide) return;
            try {
                await pyodide.runPythonAsync(`
                    import sys
                    print("[TROUBLESHOOT] Python version: ", sys.version)
                    print("[TROUBLESHOOT] Checking numpy...")
                    import numpy
                    print("[TROUBLESHOOT] Numpy version: ", numpy.__version__)
                    print("[TROUBLESHOOT] No errors detected")
                `);
                document.getElementById('console').innerHTML += '[INFO] Troubleshooting completed<br>';
            } catch (err) {
                document.getElementById('console').innerHTML += `[ERROR] Troubleshooting failed: ${err}<br>`;
            }
        }

        document.getElementById('execute-btn').onclick = executeCommand;
        document.getElementById('inject-btn').onclick = showPopup;
        document.getElementById('eject-btn').onclick = closePopup;
        document.getElementById('troubleshoot-btn').onclick = runTroubleshooting;
        initPyodide();
    </script>
</body>
</html>
