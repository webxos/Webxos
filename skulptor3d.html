<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Permissions-Policy" content="clipboard-write=(self)">
    <title>Skulptor3D</title>
    <style>
        body { font-family: monospace; margin: 0; padding: 10px; background: #000; color: #0f0; }
        #console, #error-console, #command-input, #py-input, canvas { border: 1px solid #0f0; background: #000; color: #0f0; }
        #console { width: 100%; height: 200px; overflow-y: auto; padding: 10px; font-size: 14px; }
        #error-console { width: 100%; height: 150px; overflow-y: auto; padding: 10px; font-size: 14px; margin-top: 10px; }
        #input-area { margin-top: 10px; display: flex; flex-direction: column; gap: 10px; }
        #command-input { padding: 10px; font-size: 16px; width: 100%; box-sizing: border-box; }
        #py-popup, #skulptor3d-popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 2px solid #0f0; padding: 15px; z-index: 1000; background: #000; }
        #py-input { width: 100%; height: 250px; font-family: monospace; font-size: 14px; box-sizing: border-box; }
        button { padding: 12px; font-size: 16px; cursor: pointer; width: 100%; box-sizing: border-box; background: #0f0; color: #000; }
        button:hover:not(:disabled) { background: #0c0; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #close-3d-popup { position: absolute; top: 5px; right: 5px; font-weight: bold; padding: 8px; font-size: 14px; background: #f00; color: #fff; }
        #close-3d-popup:hover { background: #c00; }
        #status-area { margin-bottom: 10px; }
        .log-info { color: #0f0; }
        .log-error { color: #f00; }
        .log-warning { color: #ff0; }
        #log-output { display: none; margin-top: 10px; width: 100%; height: 100px; font-family: monospace; }
        .hidden { display: none; }
        @media (min-width: 768px) {
            #input-area { flex-direction: row; }
            button { width: auto; }
            #command-input { width: 70%; }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.26.0/full/pyodide.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
</head>
<body>
    <div id="console" class="border" role="log" aria-live="polite"></div>
    <div id="error-console" class="border" role="log" aria-live="assertive"></div>
    <button id="copy-log-btn" disabled aria-label="Copy error log to clipboard">Copy Log</button>
    <div id="status-area">
        <span id="pyodide-status">Loading...</span> |
        <span id="webgl-status">Checking...</span> |
        <span id="fps">0.00</span> FPS | <span id="memory">0.00</span> MB
    </div>
    <div id="input-area" class="flex flex-col md:flex-row gap-2">
        <input id="command-input" type="text" placeholder="Enter command" class="border" aria-label="Enter command">
        <button id="execute-btn" disabled aria-label="Execute command">Execute</button>
        <button id="inject-btn" disabled aria-label="Open code input popup">Inject</button>
        <button id="eject-btn" disabled aria-label="Eject and refresh application">Eject</button>
        <button id="troubleshoot-btn" disabled aria-label="Run troubleshooting diagnostics">Troubleshoot</button>
    </div>
    <div id="py-popup" class="hidden">
        <select id="code-type" aria-label="Select code type">
            <option value="py">Python (.py)</option>
            <option value="py3d">Skulptor3D (.py3d)</option>
        </select>
        <textarea id="py-input" placeholder="Paste Python or .py3d code" class="border" aria-label="Code input"></textarea><br>
        <button onclick="injectScript()" class="mt-2" aria-label="Inject code">Inject</button>
        <button onclick="closePopup()" class="mt-2" aria-label="Close code popup">Close</button>
    </div>
    <div id="skulptor3d-popup" class="hidden">
        <button id="close-3d-popup" onclick="close3DPopup()" aria-label="Close 3D canvas popup">X</button>
        <canvas id="skulptor3d-canvas" aria-label="3D rendering canvas"></canvas>
    </div>
    <textarea id="log-output" readonly placeholder="Error log for manual copy" aria-label="Error log output"></textarea>
    <script>
        let pyodide;
        let pyodideReady = false;
        let globalErrorLog = [];
        let glContext = null;
        let renderLoopRunning = false;
        let renderFrameId = null;
        let performanceFrameId = null;
        let sceneObjects = [];
        let animations = [];
        let cameraPosition = [0, 0, 5];
        let cameraRotation = [0.3, 0.5, 0];

        function addToErrorLog(level, message) {
            globalErrorLog.push({ timestamp: new Date().toISOString(), level, message });
            if (globalErrorLog.length > 100) globalErrorLog.shift();
            const logEntry = document.createElement('div');
            logEntry.className = `log-${level.toLowerCase()}`;
            logEntry.textContent = `[${level}] ${message}`;
            const errorConsole = document.getElementById('error-console');
            errorConsole.appendChild(logEntry);
            errorConsole.scrollTop = errorConsole.scrollHeight;
            updateLogOutput();
        }

        function updateLogOutput() {
            const logText = globalErrorLog.map(entry => `[${entry.timestamp}] [${entry.level}] ${entry.message}`).join('\n');
            document.getElementById('log-output').value = logText;
        }

        async function loadPyodideWithFallback() {
            try {
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Loading Pyodide...</div>';
                pyodide = await loadPyodide({ indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.26.0/full/' });
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Pyodide loaded successfully</div>';
                return true;
            } catch (e) {
                addToErrorLog('ERROR', `Pyodide load failed: ${e.message}. Retrying...`);
                return await tryPyodideWorkaround();
            }
        }

        async function tryPyodideWorkaround() {
            try {
                const script = document.createElement('script');
                script.src = `https://cdn.jsdelivr.net/pyodide/v0.26.0/full/pyodide.js?t=${Date.now()}`;
                script.async = false;
                document.head.appendChild(script);
                await new Promise((resolve, reject) => {
                    script.onload = () => resolve();
                    script.onerror = () => reject(new Error('Failed to reload pyodide.js'));
                });
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Pyodide script reloaded, initializing...</div>';
                pyodide = await loadPyodide({ indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.26.0/full/' });
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Pyodide workaround successful</div>';
                return true;
            } catch (e) {
                addToErrorLog('ERROR', `Workaround failed: ${e.message}`);
                return false;
            }
        }

        async function initPy3D() {
            try {
                // Expose sceneObjects and animations globally for js module access
                window.sceneObjects = sceneObjects;
                window.animations = animations;

                await pyodide.runPythonAsync(`
                    import js
                    from pyodide.ffi import to_js

                    class Py3D:
                        def add_cube(self, name, position, size, color):
                            try:
                                shape = {
                                    "name": name,
                                    "type": "cube",
                                    "position": list(position),
                                    "size": float(size),
                                    "color": list(color)
                                }
                                if hasattr(js, 'sceneObjects'):
                                    js.sceneObjects.append(to_js(shape))
                                    js.console.log(f"[Py3D] Added cube: {name}, Total shapes: {len(js.sceneObjects)}")
                                else:
                                    js.addToErrorLog("ERROR", f"js.sceneObjects not accessible for cube {name}")
                            except Exception as e:
                                js.addToErrorLog("ERROR", f"Failed to add cube {name}: {str(e)}")

                        def set_camera(self, position, rotation):
                            try:
                                js.cameraPosition = to_js(list(position))
                                js.cameraRotation = to_js(list(rotation))
                                js.console.log(f"[Py3D] Camera set to position: {position}, rotation: {rotation}")
                            except Exception as e:
                                js.addToErrorLog("ERROR", f"Failed to set camera: {str(e)}")

                        def animate(self, name, position, duration):
                            try:
                                animation = {
                                    "name": name,
                                    "target_position": list(position),
                                    "duration": float(duration),
                                    "start_time": js.performance.now() / 1000
                                }
                                if hasattr(js, 'animations'):
                                    js.animations.append(to_js(animation))
                                    js.console.log(f"[Py3D] Animation added for {name}, Total animations: {len(js.animations)}")
                                else:
                                    js.addToErrorLog("ERROR", f"js.animations not accessible for animation {name}")
                            except Exception as e:
                                js.addToErrorLog("ERROR", f"Failed to animate {name}: {str(e)}")

                        def clear_scene(self):
                            try:
                                if hasattr(js, 'sceneObjects') and hasattr(js, 'animations'):
                                    js.sceneObjects.length = 0
                                    js.animations.length = 0
                                    js.console.log(f"[Py3D] Scene cleared, Shapes: {len(js.sceneObjects)}, Animations: {len(js.animations)}")
                                else:
                                    js.addToErrorLog("ERROR", "js.sceneObjects or js.animations not accessible")
                            except Exception as e:
                                js.addToErrorLog("ERROR", f"Failed to clear scene: {str(e)}")

                        async def test_suite(self):
                            try:
                                js.console.log("[Py3D] Running test suite")
                                js.console.log(f"[Py3D] js.sceneObjects available: {hasattr(js, 'sceneObjects')}")
                                js.console.log(f"[Py3D] js.animations available: {hasattr(js, 'animations')}")
                                js.console.log("[Py3D] Test suite passed")
                            except Exception as e:
                                js.addToErrorLog("ERROR", f"Test suite failed: {str(e)}")

                    globals()['Py3D'] = Py3D
                `);
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Py3D module initialized</div>';
                // Test injection: single cube
                await pyodide.runPythonAsync(`
                    try:
                        Py3D().add_cube("test_cube", [0, 0, 0], 1, [1, 0, 0])
                    except Exception as e:
                        js.addToErrorLog("ERROR", f"Test cube injection failed: {str(e)}")
                `);
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Test cube injected</div>';
            } catch (e) {
                addToErrorLog('ERROR', `Py3D initialization failed: ${e.message}`);
                // Fallback: manually add test cube
                sceneObjects.push({
                    name: "fallback_cube",
                    type: "cube",
                    position: [0, 0, 0],
                    size: 1,
                    color: [1, 0, 0]
                });
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Fallback: Added test cube to sceneObjects</div>';
            }
        }

        async function initPyodide() {
            try {
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Initializing Pyodide...</div>';
                const loaded = await loadPyodideWithFallback();
                if (!loaded) throw new Error('Pyodide initialization failed after retries.');
                await initPy3D();
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Pyodide initialized</div>';
                pyodideReady = true;
                document.getElementById('pyodide-status').textContent = 'Loaded';
                ['execute-btn', 'inject-btn', 'eject-btn', 'troubleshoot-btn', 'copy-log-btn'].forEach(id => {
                    document.getElementById(id).disabled = false;
                    document.getElementById(id).setAttribute('aria-disabled', 'false');
                });
                initWebGL();
                updatePerformance();
            } catch (e) {
                addToErrorLog('ERROR', `Pyodide init failed: ${e.message}`);
                document.getElementById('pyodide-status').textContent = 'Failed';
                disableInteractiveFeatures();
            }
        }

        function disableInteractiveFeatures() {
            ['execute-btn', 'inject-btn', 'eject-btn', 'troubleshoot-btn', 'copy-log-btn'].forEach(id => {
                document.getElementById(id).disabled = true;
                document.getElementById(id).setAttribute('aria-disabled', 'true');
            });
        }

        function handleContextLoss() {
            addToErrorLog('ERROR', 'WebGL context lost. Attempting to restore...');
            glContext = null;
            renderLoopRunning = false;
            cancelAnimationFrame(renderFrameId);
            document.getElementById('webgl-status').textContent = 'Context Lost';
            setTimeout(initWebGL, 1000);
        }

        function handleContextRestore() {
            document.getElementById('console').innerHTML += '<div class="log-info">[INFO] WebGL context restored. Reinitializing...</div>';
            initWebGL();
        }

        function initWebGL() {
            if (!window.mat4) {
                addToErrorLog('ERROR', 'gl-matrix library not loaded');
                document.getElementById('webgl-status').textContent = 'Failed';
                return;
            }
            const canvas = document.getElementById('skulptor3d-canvas');
            try {
                glContext = canvas.getContext('webgl', { preserveDrawingBuffer: true }) || canvas.getContext('webgl2', { preserveDrawingBuffer: true });
                if (!glContext) throw new Error('WebGL context initialization failed');
                canvas.addEventListener('webglcontextlost', handleContextLoss);
                canvas.addEventListener('webglcontextrestored', handleContextRestore);
                document.getElementById('webgl-status').textContent = 'WebGL';
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] WebGL context initialized</div>';
                setupWebGL();
                if (!renderLoopRunning) startRenderLoop();
            } catch (e) {
                addToErrorLog('ERROR', `WebGL initialization failed: ${e.message}`);
                document.getElementById('webgl-status').textContent = 'Not Supported';
            }
        }

        function setupWebGL() {
            const gl = glContext;
            try {
                gl.enable(gl.DEPTH_TEST);
                gl.enable(gl.CULL_FACE);
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, `
                    attribute vec3 aPosition;
                    uniform mat4 uModelViewMatrix;
                    uniform mat4 uProjectionMatrix;
                    void main() {
                        gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                    }
                `);
                gl.compileShader(vertexShader);
                if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                    throw new Error(`Vertex shader compilation failed: ${gl.getShaderInfoLog(vertexShader)}`);
                }
                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, `
                    precision mediump float;
                    uniform vec3 uColor;
                    void main() {
                        gl_FragColor = vec4(uColor, 1.0);
                    }
                `);
                gl.compileShader(fragmentShader);
                if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                    throw new Error(`Fragment shader compilation failed: ${gl.getShaderInfoLog(fragmentShader)}`);
                }
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error(`Shader program linking failed: ${gl.getProgramInfoLog(program)}`);
                }
                gl.useProgram(program);
                glContext.program = program;
                glContext.aPosition = gl.getAttribLocation(program, 'aPosition');
                glContext.uModelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
                glContext.uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');
                glContext.uColor = gl.getUniformLocation(program, 'uColor');
                const cubeVertices = new Float32Array([
                    -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5,
                    -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5,
                    -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5,
                    -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5,
                    0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5, -0.5,
                    -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5
                ]);
                const indices = new Uint16Array([
                    0,  1,  2,  0,  2,  3,
                    4,  5,  6,  4,  6,  7,
                    8,  9, 10,  8, 10, 11,
                    12, 13, 14, 12, 14, 15,
                    16, 17, 18, 16, 18, 19,
                    20, 21, 22, 20, 22, 23
                ]);
                const vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);
                const indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
                glContext.vertexBuffer = vertexBuffer;
                glContext.indexBuffer = indexBuffer;
                glContext.indexCount = indices.length;
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] WebGL setup complete</div>';
            } catch (e) {
                addToErrorLog('ERROR', `WebGL setup failed: ${e.message}`);
            }
        }

        function stopRenderLoop() {
            if (renderFrameId) {
                cancelAnimationFrame(renderFrameId);
                renderFrameId = null;
                renderLoopRunning = false;
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Render loop stopped</div>';
            }
        }

        function startRenderLoop() {
            if (renderLoopRunning) return;
            renderLoopRunning = true;
            const gl = glContext;
            if (!gl) {
                addToErrorLog('ERROR', 'Cannot start render loop: WebGL context is null');
                renderLoopRunning = false;
                return;
            }
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            const fov = 45 * Math.PI / 180;
            const aspect = gl.canvas.width / gl.canvas.height;
            const projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, fov, aspect, 0.1, 1000.0);
            async function render() {
                if (!glContext || glContext.isContextLost()) {
                    addToErrorLog('ERROR', 'Render loop stopped due to lost WebGL context');
                    stopRenderLoop();
                    return;
                }
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                const viewMatrix = mat4.create();
                mat4.translate(viewMatrix, viewMatrix, cameraPosition);
                mat4.rotateX(viewMatrix, viewMatrix, cameraRotation[0]);
                mat4.rotateY(viewMatrix, viewMatrix, cameraRotation[1]);
                mat4.rotateZ(viewMatrix, viewMatrix, cameraRotation[2]);
                const modelMatrix = mat4.create();
                const currentTime = performance.now() / 1000;
                if (animations.length === 0) {
                    document.getElementById('console').innerHTML += '<div class="log-warning">[WARNING] No animations to process</div>';
                } else {
                    document.getElementById('console').innerHTML += `<div class="log-info">[RENDER] Processing ${animations.length} animations</div>`;
                }
                animations.forEach((anim, index) => {
                    try {
                        const t = Math.min((currentTime - anim.start_time) / anim.duration, 1);
                        const shape = sceneObjects.find(obj => obj.name === anim.name);
                        if (shape) {
                            const startPos = shape.position;
                            const endPos = anim.target_position;
                            shape.position = [
                                startPos[0] + (endPos[0] - startPos[0]) * t,
                                startPos[1] + (endPos[1] - startPos[1]) * t,
                                startPos[2] + (endPos[2] - startPos[2]) * t
                            ];
                            if (t >= 1) {
                                animations.splice(index, 1);
                            }
                        } else {
                            document.getElementById('console').innerHTML += `<div class="log-warning">[WARNING] Animation ${anim.name} has no matching shape</div>`;
                        }
                    } catch (e) {
                        addToErrorLog('ERROR', `Animation ${anim.name} failed: ${e.message}`);
                    }
                });
                if (sceneObjects.length === 0) {
                    document.getElementById('console').innerHTML += '<div class="log-warning">[WARNING] No scene objects to render</div>';
                } else {
                    document.getElementById('console').innerHTML += `<div class="log-info">[RENDER] Rendering ${sceneObjects.length} objects</div>`;
                }
                sceneObjects.forEach(obj => {
                    try {
                        if (obj.type === 'cube') {
                            mat4.identity(modelMatrix);
                            mat4.translate(modelMatrix, modelMatrix, obj.position);
                            mat4.scale(modelMatrix, modelMatrix, [obj.size, obj.size, obj.size]);
                            const modelViewMatrix = mat4.create();
                            mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);
                            gl.uniformMatrix4fv(glContext.uModelViewMatrix, false, modelViewMatrix);
                            gl.uniformMatrix4fv(glContext.uProjectionMatrix, false, projectionMatrix);
                            gl.uniform3fv(glContext.uColor, obj.color);
                            gl.bindBuffer(gl.ARRAY_BUFFER, glContext.vertexBuffer);
                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glContext.indexBuffer);
                            gl.vertexAttribPointer(glContext.aPosition, 3, gl.FLOAT, false, 0, 0);
                            gl.enableVertexAttribArray(glContext.aPosition);
                            gl.drawElements(gl.TRIANGLES, glContext.indexCount, gl.UNSIGNED_SHORT, 0);
                        }
                    } catch (e) {
                        addToErrorLog('ERROR', `Failed to render object ${obj.name}: ${e.message}`);
                    }
                });
                renderFrameId = requestAnimationFrame(render);
            }
            renderFrameId = requestAnimationFrame(render);
        }

        function stopPerformanceLoop() {
            if (performanceFrameId) {
                cancelAnimationFrame(performanceFrameId);
                performanceFrameId = null;
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Performance loop stopped</div>';
            }
        }

        function updatePerformance() {
            let lastTime = performance.now();
            let frameCount = 0;
            function loop(currentTime) {
                frameCount++;
                const delta = currentTime - lastTime;
                if (delta >= 1000) {
                    const fps = (frameCount * 1000 / delta).toFixed(2);
                    document.getElementById('fps').textContent = fps;
                    if (performance.memory) {
                        const memory = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2);
                        document.getElementById('memory').textContent = memory;
                    }
                    frameCount = 0;
                    lastTime = currentTime;
                }
                performanceFrameId = requestAnimationFrame(loop);
            }
            performanceFrameId = requestAnimationFrame(loop);
        }

        function parsePy3D(code) {
            const lines = code.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith('#'));
            const commands = [];
            document.getElementById('console').innerHTML += `<div class="log-info">[PARSE] Parsing ${lines.length} lines of .py3d code</div>`;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                document.getElementById('console').innerHTML += `<div class="log-info">[PARSE] Line ${i + 1}: ${line}</div>`;
                try {
                    if (line.startsWith('add_shape')) {
                        const match = line.match(/add_shape\s+cube\s*,\s*name\s*=\s*(\w+)\s*,\s*position\s*=\s*\(\s*([-]?\d+\.?\d*)\s*,\s*([-]?\d+\.?\d*)\s*,\s*([-]?\d+\.?\d*)\s*\)\s*,\s*size\s*=\s*(\d+\.?\d*)\s*,\s*color\s*=\s*\(\s*(\d+\.?\d*)\s*,\s*(\d+\.?\d*)\s*,\s*(\d+\.?\d*)\s*\)/);
                        if (!match) throw new Error('Invalid add_shape syntax');
                        const [, name, x, y, z, size, r, g, b] = match;
                        commands.push(`Py3D().add_cube("${name}", [${x}, ${y}, ${z}], ${size}, [${r}, ${g}, ${b}]);`);
                        document.getElementById('console').innerHTML += `<div class="log-info">[PARSE] Generated: Py3D().add_cube("${name}", [${x}, ${y}, ${z}], ${size}, [${r}, ${g}, ${b}])</div>`;
                    } else if (line.startsWith('set_camera')) {
                        const match = line.match(/set_camera\s*position\s*=\s*\(\s*([-]?\d+\.?\d*)\s*,\s*([-]?\d+\.?\d*)\s*,\s*([-]?\d+\.?\d*)\s*\)\s*,\s*rotation\s*=\s*\(\s*([-]?\d+\.?\d*)\s*,\s*([-]?\d+\.?\d*)\s*,\s*([-]?\d+\.?\d*)\s*\)/);
                        if (!match) throw new Error('Invalid set_camera syntax');
                        const [, px, py, pz, rx, ry, rz] = match;
                        commands.push(`Py3D().set_camera([${px}, ${py}, ${pz}], [${rx}, ${ry}, ${rz}]);`);
                        document.getElementById('console').innerHTML += `<div class="log-info">[PARSE] Generated: Py3D().set_camera([${px}, ${py}, ${pz}], [${rx}, ${ry}, ${rz}])</div>`;
                    } else if (line.startsWith('animate')) {
                        const match = line.match(/animate\s+(\w+)\s*,\s*position\s*=\s*\(\s*([-]?\d+\.?\d*)\s*,\s*([-]?\d+\.?\d*)\s*,\s*([-]?\d+\.?\d*)\s*\)\s*,\s*duration\s*=\s*(\d+\.?\d*)/);
                        if (!match) throw new Error('Invalid animate syntax');
                        const [, name, x, y, z, duration] = match;
                        commands.push(`Py3D().animate("${name}", [${x}, ${y}, ${z}], ${duration});`);
                        document.getElementById('console').innerHTML += `<div class="log-info">[PARSE] Generated: Py3D().animate("${name}", [${x}, ${y}, ${z}], ${duration})</div>`;
                    } else if (line.startsWith('clear_scene')) {
                        commands.push(`Py3D().clear_scene();`);
                        document.getElementById('console').innerHTML += `<div class="log-info">[PARSE] Generated: Py3D().clear_scene()</div>`;
                    } else {
                        throw new Error(`Unknown command: ${line}`);
                    }
                } catch (e) {
                    addToErrorLog('ERROR', `Line ${i + 1}: ${e.message}`);
                    return null;
                }
            }
            return commands.join('\n');
        }

        function showPopup() {
            if (!pyodideReady) {
                addToErrorLog('ERROR', 'Pyodide not ready. Please wait.');
                return;
            }
            document.getElementById('py-popup').style.display = 'block';
        }

        function closePopup() {
            document.getElementById('py-popup').style.display = 'none';
            document.getElementById('py-input').value = '';
        }

        function show3DPopup() {
            document.getElementById('skulptor3d-popup').style.display = 'block';
            resizeCanvas();
            if (!renderLoopRunning) startRenderLoop();
        }

        function close3DPopup() {
            document.getElementById('skulptor3d-popup').style.display = 'none';
            stopRenderLoop();
        }

        async function executeCommand() {
            if (!pyodideReady) {
                addToErrorLog('ERROR', 'Pyodide not ready. Please wait.');
                return;
            }
            const cmd = document.getElementById('command-input').value.trim();
            try {
                if (cmd === '/test') {
                    await pyodide.runPythonAsync(`await Py3D().test_suite()`);
                } else if (cmd === '/show3d') {
                    show3DPopup();
                } else if (cmd === 'test 3d') {
                    await pyodide.runPythonAsync(`
                        Py3D().add_cube("test_cube", [0, 0, 0], 1, [1, 0, 0])
                    `);
                    document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Test 3D executed</div>';
                } else if (cmd === 'launch swarm') {
                    await pyodide.runPythonAsync(`
                        Py3D().add_cube("drone_0", [0, 0, 0], 1, [1, 0, 0])
                        Py3D().add_cube("drone_1", [0, 0, 0], 1, [0, 1, 0])
                        Py3D().animate("drone_0", [10, 10, -10], 2)
                        Py3D().animate("drone_1", [-10, -10, -10], 2)
                    `);
                    document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Swarm launched</div>';
                } else if (cmd === 'guide') {
                    document.getElementById('console').innerHTML += `
                        <div class="log-info">[INFO] Swarm Guide:</div>
                        <div class="log-info">  test 3d - Test WebGL rendering</div>
                        <div class="log-info">  launch swarm - Start drone animations</div>
                        <div class="log-info">  guide - Show this help</div>
                        <div class="log-info">  clear - Reset scene</div>
                        <div class="log-info">  /show3d - Display 3D canvas</div>
                    `;
                } else if (cmd === 'clear') {
                    await pyodide.runPythonAsync(`Py3D().clear_scene()`);
                    document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Scene cleared</div>';
                } else {
                    await pyodide.runPythonAsync(cmd);
                    document.getElementById('console').innerHTML += `<div class="log-info">[INFO] Command executed: ${cmd}</div>`;
                }
            } catch (err) {
                addToErrorLog('ERROR', `Command error: ${err.message}`);
            }
            document.getElementById('command-input').value = '';
            document.getElementById('console').scrollTop = document.getElementById('console').scrollHeight;
        }

        async function injectScript() {
            if (!pyodideReady) {
                addToErrorLog('ERROR', 'Pyodide not ready. Please wait.');
                return;
            }
            const code = document.getElementById('py-input').value.trim();
            const codeType = document.getElementById('code-type').value;
            if (!code) {
                document.getElementById('console').innerHTML += '<div class="log-warning">[WARNING] No code to inject</div>';
                return;
            }
            try {
                const py3dAvailable = await pyodide.runPythonAsync(`'Py3D' in globals()`);
                if (!py3dAvailable) {
                    addToErrorLog('ERROR', 'Py3D class not initialized, using fallback');
                    if (codeType === 'py3d') {
                        const parsed = parsePy3D(code);
                        if (!parsed) throw new Error('Failed to parse .py3d code');
                        const lines = parsed.split('\n');
                        for (const line of lines) {
                            if (line.includes('add_cube')) {
                                const match = line.match(/Py3D\(\)\.add_cube\("(\w+)", \[([-]?\d+\.?\d*), ([-]?\d+\.?\d*), ([-]?\d+\.?\d*)\], (\d+\.?\d*), \[(\d+\.?\d*), (\d+\.?\d*), (\d+\.?\d*)\]\)/);
                                if (match) {
                                    const [, name, x, y, z, size, r, g, b] = match;
                                    sceneObjects.push({
                                        name,
                                        type: "cube",
                                        position: [parseFloat(x), parseFloat(y), parseFloat(z)],
                                        size: parseFloat(size),
                                        color: [parseFloat(r), parseFloat(g), parseFloat(b)]
                                    });
                                    document.getElementById('console').innerHTML += `<div class="log-info">[FALLBACK] Added cube: ${name}</div>`;
                                }
                            }
                        }
                        document.getElementById('console').innerHTML += `<div class="log-info">[FALLBACK] Processed .py3d, Shapes: ${sceneObjects.length}</div>`;
                    } else {
                        document.getElementById('console').innerHTML += `<div class="log-warning">[WARNING] Python code injection not supported in fallback mode</div>`;
                    }
                } else {
                    if (codeType === 'py3d') {
                        const parsed = parsePy3D(code);
                        if (!parsed) throw new Error('Failed to parse .py3d code');
                        document.getElementById('console').innerHTML += `<div class="log-info">[INJECT] Executing parsed .py3d code</div>`;
                        await pyodide.runPythonAsync(parsed);
                        document.getElementById('console').innerHTML += `<div class="log-info">[INJECT] .py3d script executed, Shapes: ${sceneObjects.length}, Animations: ${animations.length}</div>`;
                    } else {
                        await pyodide.runPythonAsync(code);
                        document.getElementById('console').innerHTML += `<div class="log-info">[INJECT] Python script executed</div>`;
                    }
                }
                closePopup();
                show3DPopup();
            } catch (err) {
                addToErrorLog('ERROR', `Script injection error: ${err.message}`);
            }
        }

        async function runTroubleshoot() {
            if (!pyodideReady) {
                addToErrorLog('ERROR', 'Pyodide not ready. Please wait.');
                return;
            }
            document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Initiating troubleshooting...</div>';
            const checks = [
                { id: 1, test: 'WebGL initialization', fn: () => glContext && !glContext.isContextLost() ? 'OK' : 'Failed' },
                { id: 2, test: 'Vertex shader', fn: () => glContext && glContext.program ? 'OK' : 'Failed' },
                { id: 3, test: 'Fragment shader', fn: () => glContext && glContext.program ? 'OK' : 'Failed' },
                { id: 4, test: 'Scene rendering', fn: () => sceneObjects.length > 0 ? 'OK' : 'No objects' },
                { id: 5, test: 'Animation', fn: () => animations.length > 0 ? 'OK' : 'No animations' },
                { id: 6, test: 'gl-matrix', fn: () => window.mat4 ? 'OK' : 'Failed' },
                { id: 7, test: 'Pyodide runtime', fn: async () => (await pyodide.runPythonAsync('1 + 1')) === 2 ? 'OK' : 'Failed' },
                { id: 8, test: 'js.sceneObjects', fn: async () => (await pyodide.runPythonAsync('hasattr(js, "sceneObjects")')) ? 'OK' : 'Failed' },
                { id: 9, test: 'js.animations', fn: async () => (await pyodide.runPythonAsync('hasattr(js, "animations")')) ? 'OK' : 'Failed' }
            ];
            for (const check of checks) {
                const result = await check.fn();
                if (result === 'OK' || (check.id === 5 && result === 'No animations') || (check.id === 4 && result === 'No objects')) {
                    document.getElementById('console').innerHTML += `<div class="log-info">[CHECK ${check.id}] ${check.test}: ${result}</div>`;
                } else {
                    addToErrorLog('ERROR', `[CHECK ${check.id}] ${check.test}: ${result}`);
                }
            }
            document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Troubleshooting completed</div>';
        }

        async function copyErrorLog() {
            if (!globalErrorLog.length) {
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] No errors to copy</div>';
                return;
            }
            const logText = document.getElementById('log-output').value;
            try {
                await navigator.clipboard.writeText(logText);
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Error log copied to clipboard</div>';
            } catch (err) {
                document.getElementById('log-output').style.display = 'block';
                document.getElementById('log-output').focus();
                document.getElementById('log-output').select();
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Clipboard unavailable. Log displayed for manual copy.</div>';
            }
        }

        function ejectAndRefresh() {
            stopRenderLoop();
            stopPerformanceLoop();
            window.location.reload();
        }

        function resizeCanvas() {
            const canvas = document.getElementById('skulptor3d-canvas');
            if (canvas) {
                const dpr = window.devicePixelRatio || 1;
                const width = Math.min(window.innerWidth - 40, 800);
                const height = Math.min(window.innerHeight - 300, 600);
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = `${width}px`;
                canvas.style.height = `${height}px`;
                if (glContext) {
                    glContext.viewport(0, 0, canvas.width, canvas.height);
                    const aspect = canvas.width / canvas.height;
                    const projectionMatrix = mat4.create();
                    mat4.perspective(projectionMatrix, 45 * Math.PI / 180, aspect, 0.1, 1000.0);
                    glContext.uniformMatrix4fv(glContext.uProjectionMatrix, false, projectionMatrix);
                }
            }
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('beforeunload', () => {
            stopRenderLoop();
            stopPerformanceLoop();
        });
        document.getElementById('execute-btn').onclick = executeCommand;
        document.getElementById('inject-btn').onclick = showPopup;
        document.getElementById('eject-btn').onclick = ejectAndRefresh;
        document.getElementById('troubleshoot-btn').onclick = runTroubleshoot;
        document.getElementById('copy-log-btn').onclick = copyErrorLog;
        initPyodide();
        resizeCanvas();
    </script>
</body>
</html>
