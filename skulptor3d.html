<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Permissions-Policy" content="clipboard-write=(self)">
    <title>Skulptor3D</title>
    <style>
        body { font-family: monospace; margin: 0; padding: 10px; background: #000; color: #0f0; }
        #console, #error-console, #command-input, #py-input, canvas { border: 1px solid #0f0; background: #000; color: #0f0; }
        #console { width: 100%; height: 200px; overflow-y: auto; padding: 10px; font-size: 14px; }
        #error-console { width: 100%; height: 150px; overflow-y: auto; padding: 10px; font-size: 14px; margin-top: 10px; }
        #input-area { margin-top: 10px; display: flex; flex-direction: column; gap: 10px; }
        #command-input { padding: 10px; font-size: 16px; width: 100%; box-sizing: border-box; }
        #py-popup, #skulptor3d-popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 2px solid #0f0; padding: 15px; z-index: 1000; background: #000; }
        #py-input { width: 100%; height: 250px; font-family: monospace; font-size: 14px; box-sizing: border-box; }
        button { padding: 12px; font-size: 16px; cursor: pointer; width: 100%; box-sizing: border-box; background: #0f0; color: #000; }
        button:hover:not(:disabled) { background: #0c0; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #close-3d-popup { position: absolute; top: 5px; right: 5px; font-weight: bold; padding: 8px; font-size: 14px; background: #f00; color: #fff; }
        #close-3d-popup:hover { background: #c00; }
        #status-area { margin-bottom: 10px; }
        .log-info { color: #0f0; }
        .log-error { color: #f00; }
        .log-warning { color: #ff0; }
        #log-output { display: none; margin-top: 10px; width: 100%; height: 100px; font-family: monospace; }
        .hidden { display: none; }
        @media (min-width: 768px) {
            #input-area { flex-direction: row; }
            button { width: auto; }
            #command-input { width: 70%; }
        }
    </style>
</head>
<body>
    <div id="console" class="border" role="log" aria-live="polite"></div>
    <div id="error-console" class="border" role="log" aria-live="assertive"></div>
    <button id="copy-log-btn" disabled aria-label="Copy error log to clipboard">Copy Log</button>
    <div id="status-area">
        <span id="webgl-status">Checking...</span> |
        <span id="fps">0.00</span> FPS | <span id="memory">0.00</span> MB
    </div>
    <div id="input-area" class="flex flex-col md:flex-row gap-2">
        <input id="command-input" type="text" placeholder="Enter command" class="border" aria-label="Enter command">
        <button id="execute-btn" disabled aria-label="Execute command">Execute</button>
        <button id="inject-btn" disabled aria-label="Open code input popup">Inject</button>
        <button id="eject-btn" disabled aria-label="Eject and refresh application">Eject</button>
        <button id="troubleshoot-btn" disabled aria-label="Run troubleshooting diagnostics">Troubleshoot</button>
    </div>
    <div id="py-popup" class="hidden">
        <select id="code-type" aria-label="Select code type">
            <option value="py3d">Skulptor3D (.py3d)</option>
        </select>
        <textarea id="py-input" placeholder="Paste .py3d code" class="border" aria-label="Code input"></textarea><br>
        <button onclick="injectScript()" class="mt-2" aria-label="Inject code">Inject</button>
        <button onclick="closePopup()" class="mt-2" aria-label="Close code popup">Close</button>
    </div>
    <div id="skulptor3d-popup" class="hidden">
        <button id="close-3d-popup" onclick="close3DPopup()" aria-label="Close 3D canvas popup">X</button>
        <canvas id="skulptor3d-canvas" aria-label="3D rendering canvas"></canvas>
    </div>
    <textarea id="log-output" readonly placeholder="Error log for manual copy" aria-label="Error log output"></textarea>
    <script>
        let globalErrorLog = [];
        let glContext = null;
        let renderLoopRunning = false;
        let renderFrameId = null;
        let performanceFrameId = null;
        let sceneObjects = [];
        let animations = [];
        let cameraPosition = [0, 0, 5];
        let cameraRotation = [0.3, 0.5, 0];
        let webglRetryCount = 0;
        let lastWarningTime = 0;
        let lastRenderLogTime = 0;
        let scriptInjected = false;
        const maxWebglRetries = 3;

        // Custom Matrix Library
        const MatrixLib = {
            mat4: {
                create: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
                identity: (out) => {
                    out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                    out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                    out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                    out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
                },
                perspective: (out, fovy, aspect, near, far) => {
                    const f = 1.0 / Math.tan(fovy / 2);
                    const nf = 1 / (near - far);
                    out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
                    out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
                    out[8] = 0; out[9] = 0; out[10] = (far + near) * nf; out[11] = -1;
                    out[12] = 0; out[13] = 0; out[14] = 2 * far * near * nf; out[15] = 0;
                },
                translate: (out, a, v) => {
                    out[12] = a[0] * v[0] + a[4] * v[1] + a[8] * v[2] + a[12];
                    out[13] = a[1] * v[0] + a[5] * v[1] + a[9] * v[2] + a[13];
                    out[14] = a[2] * v[0] + a[6] * v[1] + a[10] * v[2] + a[14];
                    out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                    out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                    out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
                    out[15] = a[15];
                },
                rotateX: (out, a, rad) => {
                    const s = Math.sin(rad), c = Math.cos(rad);
                    const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                    const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                    out[4] = a10 * c + a20 * s; out[5] = a11 * c + a21 * s;
                    out[6] = a12 * c + a22 * s; out[7] = a13 * c + a23 * s;
                    out[8] = a20 * c - a10 * s; out[9] = a21 * c - a11 * s;
                    out[10] = a22 * c - a12 * s; out[11] = a23 * c - a13 * s;
                    out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                    out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                },
                rotateY: (out, a, rad) => {
                    const s = Math.sin(rad), c = Math.cos(rad);
                    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                    const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                    out[0] = a00 * c - a20 * s; out[1] = a01 * c - a21 * s;
                    out[2] = a02 * c - a22 * s; out[3] = a03 * c - a23 * s;
                    out[8] = a00 * s + a20 * c; out[9] = a01 * s + a21 * c;
                    out[10] = a02 * s + a22 * c; out[11] = a03 * s + a23 * c;
                    out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                    out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                },
                rotateZ: (out, a, rad) => {
                    const s = Math.sin(rad), c = Math.cos(rad);
                    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                    const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                    out[0] = a00 * c + a10 * s; out[1] = a01 * c + a11 * s;
                    out[2] = a02 * c + a12 * s; out[3] = a03 * c + a13 * s;
                    out[4] = a10 * c - a00 * s; out[5] = a11 * c - a01 * s;
                    out[6] = a12 * c - a02 * s; out[7] = a13 * c - a03 * s;
                    out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
                    out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                },
                scale: (out, a, v) => {
                    out[0] = a[0] * v[0]; out[1] = a[1] * v[0]; out[2] = a[2] * v[0]; out[3] = a[3] * v[0];
                    out[4] = a[4] * v[1]; out[5] = a[5] * v[1]; out[6] = a[6] * v[1]; out[7] = a[7] * v[1];
                    out[8] = a[8] * v[2]; out[9] = a[9] * v[2]; out[10] = a[10] * v[2]; out[11] = a[11] * v[2];
                    out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                },
                multiply: (out, a, b) => {
                    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                    const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                    const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                    const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                    const b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
                    const b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
                    const b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
                    const b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];
                    out[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
                    out[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
                    out[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
                    out[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
                    out[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
                    out[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
                    out[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
                    out[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
                    out[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
                    out[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
                    out[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
                    out[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
                    out[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
                    out[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
                    out[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
                    out[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
                }
            }
        };

        // JS3D Class to Replace Py3D
        class JS3D {
            add_cube(name, position, size, color) {
                try {
                    const shape = {
                        name: name,
                        type: "cube",
                        position: position.map(Number),
                        size: Number(size),
                        color: color.map(Number)
                    };
                    sceneObjects.push(shape);
                    console.log(`[JS3D] Added cube: ${name}, Total shapes: ${sceneObjects.length}`);
                } catch (e) {
                    addToErrorLog("ERROR", `Failed to add cube ${name}: ${e.message}`);
                }
            }
            set_camera(position, rotation) {
                try {
                    cameraPosition = position.map(Number);
                    cameraRotation = rotation.map(Number);
                    console.log(`[JS3D] Camera set to position: ${position}, rotation: ${rotation}`);
                } catch (e) {
                    addToErrorLog("ERROR", `Failed to set camera: ${e.message}`);
                }
            }
            animate(name, position, duration) {
                try {
                    const animation = {
                        name: name,
                        target_position: position.map(Number),
                        duration: Number(duration),
                        start_time: performance.now() / 1000
                    };
                    animations.push(animation);
                    console.log(`[JS3D] Animation added for ${name}, Total animations: ${animations.length}`);
                } catch (e) {
                    addToErrorLog("ERROR", `Failed to animate ${name}: ${e.message}`);
                }
            }
            clear_scene() {
                try {
                    sceneObjects.length = 0;
                    animations.length = 0;
                    console.log(`[JS3D] Scene cleared, Shapes: ${sceneObjects.length}, Animations: ${animations.length}`);
                } catch (e) {
                    addToErrorLog("ERROR", `Failed to clear scene: ${e.message}`);
                }
            }
            test_suite() {
                try {
                    console.log("[JS3D] Running test suite");
                    console.log(`[JS3D] sceneObjects available: ${!!sceneObjects}`);
                    console.log(`[JS3D] animations available: ${!!animations}`);
                    console.log("[JS3D] Test suite passed");
                } catch (e) {
                    addToErrorLog("ERROR", `Test suite failed: ${e.message}`);
                }
            }
        }

        const js3d = new JS3D();

        function saveSceneState() {
            localStorage.setItem('skulptor3d_scene', JSON.stringify({ sceneObjects, animations }));
        }

        function restoreSceneState() {
            const saved = localStorage.getItem('skulptor3d_scene');
            if (saved) {
                const { sceneObjects: savedObjects, animations: savedAnimations } = JSON.parse(saved);
                sceneObjects.length = 0;
                sceneObjects.push(...savedObjects);
                animations.length = 0;
                animations.push(...savedAnimations);
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Scene state restored</div>';
                updateScroll();
            }
        }

        function addToErrorLog(level, message) {
            globalErrorLog.push({ timestamp: new Date().toISOString(), level, message });
            if (globalErrorLog.length > 100) globalErrorLog.shift();
            const logEntry = document.createElement('div');
            logEntry.className = `log-${level.toLowerCase()}`;
            logEntry.textContent = `[${level}] ${message}`;
            const errorConsole = document.getElementById('error-console');
            errorConsole.appendChild(logEntry);
            while (errorConsole.children.length > 100) {
                errorConsole.removeChild(errorConsole.firstChild);
            }
            const console = document.getElementById('console');
            while (console.children.length > 100) {
                console.removeChild(console.firstChild);
            }
            updateLogOutput();
            updateScroll();
        }

        function updateLogOutput() {
            const logText = globalErrorLog.map(entry => `[${entry.timestamp}] [${entry.level}] ${entry.message}`).join('\n');
            document.getElementById('log-output').value = logText;
        }

        function updateScroll() {
            const consoles = [document.getElementById('console'), document.getElementById('error-console')];
            consoles.forEach(console => {
                if (console.children.length > 0) {
                    const lastEntry = console.lastElementChild;
                    if (lastEntry) lastEntry.scrollIntoView({ behavior: 'smooth', block: 'end' });
                }
            });
        }

        function initApp() {
            try {
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Initializing Skulptor3D...</div>';
                restoreSceneState();
                js3d.add_cube("test_cube", [0, 0, 0], 1, [1, 0, 0]);
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Test cube injected</div>';
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Skulptor3D initialized</div>';
                ['execute-btn', 'inject-btn', 'eject-btn', 'troubleshoot-btn', 'copy-log-btn'].forEach(id => {
                    document.getElementById(id).disabled = false;
                    document.getElementById(id).setAttribute('aria-disabled', 'false');
                });
                initWebGL();
                updatePerformance();
            } catch (e) {
                addToErrorLog('ERROR', `Initialization failed: ${e.message}`);
                document.getElementById('webgl-status').textContent = 'Failed';
                disableInteractiveFeatures();
            }
        }

        function disableInteractiveFeatures() {
            ['execute-btn', 'inject-btn', 'eject-btn', 'troubleshoot-btn', 'copy-log-btn'].forEach(id => {
                document.getElementById(id).disabled = true;
                document.getElementById(id).setAttribute('aria-disabled', 'true');
            });
        }

        function handleContextLoss() {
            addToErrorLog('ERROR', 'WebGL context lost. Attempting to restore...');
            glContext = null;
            renderLoopRunning = false;
            cancelAnimationFrame(renderFrameId);
            document.getElementById('webgl-status').textContent = 'Context Lost';
            setTimeout(initWebGL, 2000);
        }

        function handleContextRestore() {
            document.getElementById('console').innerHTML += '<div class="log-info">[INFO] WebGL context restored. Reinitializing...</div>';
            initWebGL();
        }

        function initWebGL() {
            if (webglRetryCount >= maxWebglRetries) {
                addToErrorLog('ERROR', 'Max WebGL retries reached. Rendering disabled.');
                document.getElementById('webgl-status').textContent = 'Failed';
                return;
            }
            const canvas = document.getElementById('skulptor3d-canvas');
            try {
                glContext = canvas.getContext('webgl', { preserveDrawingBuffer: true }) || canvas.getContext('webgl2', { preserveDrawingBuffer: true });
                if (!glContext) throw new Error('WebGL context initialization failed');
                glContext.program = null;
                glContext.vertexBuffer = null;
                glContext.indexBuffer = null;
                canvas.addEventListener('webglcontextlost', handleContextLoss);
                canvas.addEventListener('webglcontextrestored', handleContextRestore);
                document.getElementById('webgl-status').textContent = 'WebGL';
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] WebGL context initialized</div>';
                setupWebGL();
                setupCameraControls();
                if (!renderLoopRunning) startRenderLoop();
                webglRetryCount = 0;
            } catch (e) {
                addToErrorLog('ERROR', `WebGL initialization failed (attempt ${webglRetryCount + 1}): ${e.message}`);
                webglRetryCount++;
                setTimeout(initWebGL, 2000);
            }
        }

        function setupWebGL() {
            const gl = glContext;
            try {
                gl.enable(gl.DEPTH_TEST);
                gl.enable(gl.CULL_FACE);
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, `
                    attribute vec3 aPosition;
                    uniform mat4 uModelViewMatrix;
                    uniform mat4 uProjectionMatrix;
                    void main() {
                        gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                    }
                `);
                gl.compileShader(vertexShader);
                if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                    throw new Error(`Vertex shader compilation failed: ${gl.getShaderInfoLog(vertexShader)}`);
                }
                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, `
                    precision mediump float;
                    uniform vec3 uColor;
                    void main() {
                        gl_FragColor = vec4(uColor, 1.0);
                    }
                `);
                gl.compileShader(fragmentShader);
                if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                    throw new Error(`Fragment shader compilation failed: ${gl.getShaderInfoLog(fragmentShader)}`);
                }
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error(`Shader program linking failed: ${gl.getProgramInfoLog(program)}`);
                }
                gl.useProgram(program);
                glContext.program = program;
                glContext.aPosition = gl.getAttribLocation(program, 'aPosition');
                glContext.uModelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
                glContext.uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');
                glContext.uColor = gl.getUniformLocation(program, 'uColor');
                const cubeVertices = new Float32Array([
                    -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5,
                    -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5,
                    -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5,
                    -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5,
                    0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5, -0.5,
                    -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5
                ]);
                const indices = new Uint16Array([
                    0,  1,  2,  0,  2,  3,
                    4,  5,  6,  4,  6,  7,
                    8,  9, 10,  8, 10, 11,
                    12, 13, 14, 12, 14, 15,
                    16, 17, 18, 16, 18, 19,
                    20, 21, 22, 20, 22, 23
                ]);
                const vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);
                const indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
                glContext.vertexBuffer = vertexBuffer;
                glContext.indexBuffer = indexBuffer;
                glContext.indexCount = indices.length;
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] WebGL setup complete</div>';
                updateScroll();
            } catch (e) {
                addToErrorLog('ERROR', `WebGL setup failed: ${e.message}`);
            }
        }

        function stopRenderLoop() {
            if (renderFrameId) {
                cancelAnimationFrame(renderFrameId);
                renderFrameId = null;
                renderLoopRunning = false;
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Render loop stopped</div>';
                updateScroll();
            }
        }

        function startRenderLoop() {
            if (renderLoopRunning) return;
            renderLoopRunning = true;
            const gl = glContext;
            if (!gl) {
                addToErrorLog('ERROR', 'Cannot start render loop: WebGL context is null');
                renderLoopRunning = false;
                return;
            }
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            const fov = 45 * Math.PI / 180;
            const aspect = gl.canvas.width / gl.canvas.height;
            const projectionMatrix = MatrixLib.mat4.create();
            MatrixLib.mat4.perspective(projectionMatrix, fov, aspect, 0.1, 1000.0);
            async function render() {
                if (!glContext || glContext.isContextLost()) {
                    addToErrorLog('ERROR', 'Render loop stopped due to lost WebGL context');
                    stopRenderLoop();
                    return;
                }
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                const viewMatrix = MatrixLib.mat4.create();
                MatrixLib.mat4.translate(viewMatrix, viewMatrix, cameraPosition);
                MatrixLib.mat4.rotateX(viewMatrix, viewMatrix, cameraRotation[0]);
                MatrixLib.mat4.rotateY(viewMatrix, viewMatrix, cameraRotation[1]);
                MatrixLib.mat4.rotateZ(viewMatrix, viewMatrix, cameraRotation[2]);
                const modelMatrix = MatrixLib.mat4.create();
                const currentTime = performance.now() / 1000;
                if (scriptInjected) {
                    if (animations.length === 0 && performance.now() - lastWarningTime >= 5000) {
                        document.getElementById('console').innerHTML += '<div class="log-warning">[WARNING] No animations to process</div>';
                        lastWarningTime = performance.now();
                        updateScroll();
                    } else if (animations.length > 0) {
                        document.getElementById('console').innerHTML += `<div class="log-info">[RENDER] Processing ${animations.length} animations</div>`;
                    }
                    animations.forEach((anim, index) => {
                        try {
                            const t = Math.min((currentTime - anim.start_time) / anim.duration, 1);
                            const shape = sceneObjects.find(obj => obj.name === anim.name);
                            if (shape) {
                                const startPos = shape.position;
                                const endPos = anim.target_position;
                                shape.position = [
                                    startPos[0] + (endPos[0] - startPos[0]) * t,
                                    startPos[1] + (endPos[1] - startPos[1]) * t,
                                    startPos[2] + (endPos[2] - startPos[2]) * t
                                ];
                                if (t >= 1) {
                                    requestAnimationFrame(() => {
                                        document.getElementById('console').innerHTML += `<div class="log-info">[INFO] Animation ${anim.name} completed</div>`;
                                        updateScroll();
                                    });
                                    animations.splice(index, 1);
                                }
                            } else {
                                document.getElementById('console').innerHTML += `<div class="log-warning">[WARNING] Animation ${anim.name} has no matching shape</div>`;
                            }
                        } catch (e) {
                            addToErrorLog('ERROR', `Animation ${anim.name} failed: ${e.message}`);
                        }
                    });
                    if (sceneObjects.length > 0 && performance.now() - lastRenderLogTime >= 5000) {
                        document.getElementById('console').innerHTML += `<div class="log-info">[RENDER] Rendering ${sceneObjects.length} objects</div>`;
                        lastRenderLogTime = performance.now();
                        updateScroll();
                    }
                }
                sceneObjects.forEach(obj => {
                    try {
                        if (obj.type === 'cube') {
                            MatrixLib.mat4.identity(modelMatrix);
                            MatrixLib.mat4.translate(modelMatrix, modelMatrix, obj.position);
                            MatrixLib.mat4.scale(modelMatrix, modelMatrix, [obj.size, obj.size, obj.size]);
                            const modelViewMatrix = MatrixLib.mat4.create();
                            MatrixLib.mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);
                            gl.uniformMatrix4fv(glContext.uModelViewMatrix, false, modelViewMatrix);
                            gl.uniformMatrix4fv(glContext.uProjectionMatrix, false, projectionMatrix);
                            gl.uniform3fv(glContext.uColor, obj.color);
                            gl.bindBuffer(gl.ARRAY_BUFFER, glContext.vertexBuffer);
                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glContext.indexBuffer);
                            gl.vertexAttribPointer(glContext.aPosition, 3, gl.FLOAT, false, 0, 0);
                            gl.enableVertexAttribArray(glContext.aPosition);
                            gl.drawElements(gl.TRIANGLES, glContext.indexCount, gl.UNSIGNED_SHORT, 0);
                        }
                    } catch (e) {
                        addToErrorLog('ERROR', `Failed to render object ${obj.name}: ${e.message}`);
                    }
                });
                renderFrameId = requestAnimationFrame(render);
            }
            renderFrameId = requestAnimationFrame(render);
        }

        function stopPerformanceLoop() {
            if (performanceFrameId) {
                cancelAnimationFrame(performanceFrameId);
                performanceFrameId = null;
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Performance loop stopped</div>';
                updateScroll();
            }
        }

        function updatePerformance() {
            let lastTime = performance.now();
            let frameCount = 0;
            function loop(currentTime) {
                frameCount++;
                const delta = currentTime - lastTime;
                if (delta >= 1000) {
                    const fps = (frameCount * 1000 / delta).toFixed(2);
                    document.getElementById('fps').textContent = fps;
                    if (performance.memory) {
                        const memory = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2);
                        document.getElementById('memory').textContent = memory;
                    }
                    frameCount = 0;
                    lastTime = currentTime;
                }
                performanceFrameId = requestAnimationFrame(loop);
            }
            performanceFrameId = requestAnimationFrame(loop);
        }

        function parsePy3D(code) {
            const lines = code.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith('#'));
            const commands = [];
            document.getElementById('console').innerHTML += `<div class="log-info">[PARSE] Parsing ${lines.length} lines of .py3d code</div>`;
            for (let i = 0; i < lines.length; i++) {
                const tokens = lines[i].split(/[\s,=()]+/).filter(t => t);
                try {
                    if (tokens[0] === 'add_shape' && tokens[1] === 'cube') {
                        const name = tokens[3];
                        const position = [parseFloat(tokens[5]), parseFloat(tokens[6]), parseFloat(tokens[7])];
                        const size = parseFloat(tokens[9]);
                        const color = [parseFloat(tokens[11]), parseFloat(tokens[12]), parseFloat(tokens[13])];
                        commands.push(`js3d.add_cube("${name}", [${position}], ${size}, [${color}]);`);
                        document.getElementById('console').innerHTML += `<div class="log-info">[PARSE] Generated: js3d.add_cube("${name}", [${position}], ${size}, [${color}])</div>`;
                    } else if (tokens[0] === 'set_camera') {
                        const position = [parseFloat(tokens[2]), parseFloat(tokens[3]), parseFloat(tokens[4])];
                        const rotation = [parseFloat(tokens[6]), parseFloat(tokens[7]), parseFloat(tokens[8])];
                        commands.push(`js3d.set_camera([${position}], [${rotation}]);`);
                        document.getElementById('console').innerHTML += `<div class="log-info">[PARSE] Generated: js3d.set_camera([${position}], [${rotation}])</div>`;
                    } else if (tokens[0] === 'animate') {
                        const name = tokens[1];
                        const position = [parseFloat(tokens[3]), parseFloat(tokens[4]), parseFloat(tokens[5])];
                        const duration = parseFloat(tokens[7]);
                        commands.push(`js3d.animate("${name}", [${position}], ${duration});`);
                        document.getElementById('console').innerHTML += `<div class="log-info">[PARSE] Generated: js3d.animate("${name}", [${position}], ${duration})</div>`;
                    } else if (tokens[0] === 'clear_scene') {
                        commands.push(`js3d.clear_scene();`);
                        document.getElementById('console').innerHTML += `<div class="log-info">[PARSE] Generated: js3d.clear_scene()</div>`;
                    } else {
                        throw new Error(`Unknown command: ${lines[i]}`);
                    }
                } catch (e) {
                    addToErrorLog('ERROR', `Line ${i + 1}: ${e.message}`);
                    return null;
                }
            }
            return commands.join('\n');
        }

        function showPopup() {
            document.getElementById('py-popup').style.display = 'block';
        }

        function closePopup() {
            document.getElementById('py-popup').style.display = 'none';
            document.getElementById('py-input').value = '';
        }

        function show3DPopup() {
            document.getElementById('skulptor3d-popup').style.display = 'block';
            resizeCanvas();
            if (!renderLoopRunning) startRenderLoop();
        }

        function close3DPopup() {
            document.getElementById('skulptor3d-popup').style.display = 'none';
            saveSceneState();
            stopRenderLoop();
        }

        const validCommands = {
            '/test': () => {
                js3d.test_suite();
            },
            '/show3d': () => {
                show3DPopup();
            },
            'test 3d': () => {
                js3d.add_cube("test_cube", [0, 0, 0], 1, [1, 0, 0]);
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Test 3D executed</div>';
                updateScroll();
            },
            'launch swarm': () => {
                js3d.add_cube("drone_0", [0, 0, 0], 1, [1, 0, 0]);
                js3d.add_cube("drone_1", [0, 0, 0], 1, [0, 1, 0]);
                js3d.animate("drone_0", [10, 10, -10], 2);
                js3d.animate("drone_1", [-10, -10, -10], 2);
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Swarm launched</div>';
                updateScroll();
            },
            'guide': () => {
                document.getElementById('console').innerHTML += `
                    <div class="log-info">[INFO] Swarm Guide:</div>
                    <div class="log-info">  test 3d - Test WebGL rendering</div>
                    <div class="log-info">  launch swarm - Start drone animations</div>
                    <div class="log-info">  guide - Show this help</div>
                    <div class="log-info">  clear - Reset scene</div>
                    <div class="log-info">  /show3d - Display 3D canvas</div>
                `;
                updateScroll();
            },
            'clear': () => {
                js3d.clear_scene();
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Scene cleared</div>';
                updateScroll();
            }
        };

        function executeCommand() {
            const cmd = document.getElementById('command-input').value.trim();
            if (validCommands[cmd]) {
                validCommands[cmd]();
            } else {
                addToErrorLog('ERROR', `Unknown command: ${cmd}`);
            }
            document.getElementById('command-input').value = '';
        }

        function injectScript() {
            const code = document.getElementById('py-input').value.trim();
            const codeType = document.getElementById('code-type').value;
            if (!code) {
                document.getElementById('console').innerHTML += '<div class="log-warning">[WARNING] No code to inject</div>';
                updateScroll();
                return;
            }
            try {
                if (codeType === 'py3d') {
                    const parsed = parsePy3D(code);
                    if (!parsed) throw new Error('Failed to parse .py3d code');
                    eval(parsed); // Execute parsed JS3D commands
                    document.getElementById('console').innerHTML += `<div class="log-info">[INJECT] .py3d script executed, Shapes: ${sceneObjects.length}, Animations: ${animations.length}</div>`;
                    scriptInjected = true;
                } else {
                    addToErrorLog('ERROR', 'Only .py3d code is supported');
                }
                closePopup();
                show3DPopup();
            } catch (err) {
                addToErrorLog('ERROR', `Script injection error: ${err.message}`);
            }
        }

        function runTroubleshoot() {
            document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Initiating troubleshooting...</div>';
            const checks = [
                { id: 1, test: 'WebGL initialization', fn: () => glContext && !glContext.isContextLost() ? 'OK' : 'Failed' },
                { id: 2, test: 'Vertex shader', fn: () => glContext && glContext.program ? 'OK' : 'Failed' },
                { id: 3, test: 'Fragment shader', fn: () => glContext && glContext.program ? 'OK' : 'Failed' },
                { id: 4, test: 'Scene rendering', fn: () => sceneObjects.length > 0 ? 'OK' : 'No objects' },
                { id: 5, test: 'Animation', fn: () => animations.length > 0 ? 'OK' : 'No animations' },
                { id: 6, test: 'MatrixLib', fn: () => MatrixLib.mat4 ? 'OK' : 'Failed' },
                { id: 7, test: 'JS3D availability', fn: () => js3d ? 'OK' : 'Failed' },
                { id: 8, test: 'sceneObjects', fn: () => sceneObjects ? 'OK' : 'Failed' },
                { id: 9, test: 'animations', fn: () => animations ? 'OK' : 'Failed' }
            ];
            for (const check of checks) {
                const result = check.fn();
                if (result === 'OK' || (check.id === 5 && result === 'No animations') || (check.id === 4 && result === 'No objects')) {
                    document.getElementById('console').innerHTML += `<div class="log-info">[CHECK ${check.id}] ${check.test}: ${result}</div>`;
                } else {
                    addToErrorLog('ERROR', `[CHECK ${check.id}] ${check.test}: ${result}`);
                }
            }
            document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Troubleshooting completed</div>';
            updateScroll();
        }

        function copyErrorLog() {
            if (!globalErrorLog.length) {
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] No errors to copy</div>';
                updateScroll();
                return;
            }
            const logText = document.getElementById('log-output').value;
            try {
                navigator.clipboard.writeText(logText);
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Error log copied to clipboard</div>';
                updateScroll();
            } catch (err) {
                document.getElementById('log-output').style.display = 'block';
                document.getElementById('log-output').focus();
                document.getElementById('log-output').select();
                document.getElementById('console').innerHTML += '<div class="log-info">[INFO] Clipboard unavailable. Log displayed for manual copy.</div>';
                updateScroll();
            }
        }

        function ejectAndRefresh() {
            stopRenderLoop();
            stopPerformanceLoop();
            window.location.reload();
        }

        function resizeCanvas() {
            const canvas = document.getElementById('skulptor3d-canvas');
            if (canvas) {
                const popup = document.getElementById('skulptor3d-popup');
                const rect = popup.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                const width = Math.min(rect.width - 30, 800);
                const height = Math.min(rect.height - 30, 600);
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = `${width}px`;
                canvas.style.height = `${height}px`;
                if (glContext) {
                    glContext.viewport(0, 0, canvas.width, canvas.height);
                    const aspect = canvas.width / canvas.height;
                    const projectionMatrix = MatrixLib.mat4.create();
                    MatrixLib.mat4.perspective(projectionMatrix, 45 * Math.PI / 180, aspect, 0.1, 1000.0);
                    glContext.uniformMatrix4fv(glContext.uProjectionMatrix, false, projectionMatrix);
                }
            }
        }

        function setupCameraControls() {
            const canvas = document.getElementById('skulptor3d-canvas');
            let isDragging = false;
            let lastX, lastY;
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
            });
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const dx = e.clientX - lastX;
                    const dy = e.clientY - lastY;
                    cameraRotation[1] += dx * 0.005;
                    cameraRotation[0] += dy * 0.005;
                    lastX = e.clientX;
                    lastY = e.clientY;
                }
            });
            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('wheel', (e) => {
                cameraPosition[2] += e.deltaY * 0.01;
            });
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('beforeunload', () => {
            stopRenderLoop();
            stopPerformanceLoop();
        });
        document.getElementById('execute-btn').onclick = executeCommand;
        document.getElementById('inject-btn').onclick = showPopup;
        document.getElementById('eject-btn').onclick = ejectAndRefresh;
        document.getElementById('troubleshoot-btn').onclick = runTroubleshoot;
        document.getElementById('copy-log-btn').onclick = copyErrorLog;
        initApp();
        resizeCanvas();
    </script>
</body>
</html>
