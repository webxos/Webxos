<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#00ff00">
    <link rel="manifest" href="/manifest.json">
    <title>Grid Locker</title>
    <!-- Inline CSS for reliability -->
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #000000;
            font-family: 'Courier New', monospace;
            color: #00ff00;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .app-container {
            width: 100%;
            max-width: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 0;
            position: relative;
        }

        .hologram-container {
            width: 220px;
            height: 180px;
            position: relative;
            overflow: hidden;
            z-index: 1;
        }

        .hologram {
            width: 180px;
            height: 180px;
            position: absolute;
            top: 0;
            left: 20px;
            transform-style: preserve-3d;
            animation: rotateHologram 30s infinite linear;
            -webkit-transform-style: preserve-3d;
            -moz-transform-style: preserve-3d;
        }

        .grid-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #00ff00, #00cc00);
            opacity: 0.5;
        }

        .grid-layer {
            position: absolute;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(45deg, transparent, transparent 8px, rgba(0, 255, 0, 0.5) 8px, rgba(0, 255, 0, 0.5) 10px);
            animation: shiftGrid 10s infinite linear;
        }

        .grid-wireframe {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 1px solid #00ff00;
        }

        .grid-plane {
            position: absolute;
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            animation: pulsePlane 5s infinite;
        }

        .button-container {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            z-index: 1;
        }

        .btn {
            padding: 8px 14px;
            font-size: 12px;
            color: #000000;
            background: #00ff00;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #00cc00;
        }

        .console-section {
            width: 100%;
            max-width: 200px;
            margin: 10px 0;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 0;
        }

        .console-section textarea {
            width: 100%;
            height: 100px;
            padding: 10px;
            background: #000000;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            box-sizing: border-box;
            resize: none;
            margin-top: 10px;
        }

        .console-section button {
            padding: 6px 12px;
            background: #00ff00;
            color: #000000;
            border: none;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
        }

        .console-section #consoleOutput {
            margin-top: 5px;
            font-size: 12px;
            color: #00ff00;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 180px;
            padding: 12px;
            background: #000000;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 1000;
        }

        .popup h3 {
            margin: 0 0 10px;
            font-size: 14px;
        }

        .popup input {
            width: 100%;
            padding: 6px;
            background: #000000;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .popup .btn {
            width: 100%;
            margin: 5px 0 0;
            padding: 8px 14px;
        }

        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }

        footer {
            width: 100%;
            max-width: 200px;
            text-align: center;
            font-size: 10px;
            color: #00ff00;
            margin-top: 10px;
        }

        @keyframes rotateHologram {
            0% { transform: rotateY(0deg) rotateX(15deg); }
            100% { transform: rotateY(360deg) rotateX(15deg); }
        }

        @keyframes shiftGrid {
            0% { background-position: 0 0; }
            100% { background-position: 80px 80px; }
        }

        @keyframes pulsePlane {
            0%, 100% { transform: scale(1) translateZ(0); }
            50% { transform: scale(1.1) translateZ(12px); }
        }

        @media (prefers-reduced-motion: reduce) {
            .hologram, .grid-layer, .grid-plane {
                animation: none;
            }
        }

        .fallback {
            background: #000000;
            color: #00ff00;
            font-family: monospace;
            padding: 20px;
            text-align: center;
        }
    </style>
    <!-- Include pako for compression -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
</head>
<body>
    <div class="app-container">
        <div class="hologram-container">
            <div class="hologram" id="hologram"></div>
        </div>
        <div class="console-section">
            <textarea id="consoleInput" placeholder="Enter message"></textarea>
            <button onclick="clearConsole()">Clear</button>
            <div id="consoleOutput"></div>
        </div>
        <div class="button-container">
            <button class="btn" onclick="generateGrid()">Generate</button>
            <button class="btn" onclick="copyCode()">Copy</button>
            <button class="btn" onclick="showExecutePopup()">Execute</button>
        </div>
    </div>

    <div class="popup-overlay" id="executeOverlay"></div>
    <div class="popup" id="executePopup">
        <h3>Execute Grid</h3>
        <input type="text" id="executeInput" placeholder="Enter serial,code,validation (e.g., HOLO-000001-A7K,Ω-CODE:ΔΩΨ123#@*,VAL-XXXXXXXXXXXX)">
        <button class="btn" onclick="executeGrid()">Submit</button>
        <button class="btn" onclick="closeExecutePopup()">Cancel</button>
    </div>

    <footer>
        © WebXOS 2025<br>
        Usage: Generate encrypts and compresses message with unique grid keys. Copy saves codes. Execute loads grid and message. Secure PWA for public use.
    </footer>

    <script>
        const STORAGE_VERSION = 'grid-locker-v4'; // Updated to force storage reset
        const hologram = document.getElementById('hologram');
        const consoleInput = document.getElementById('consoleInput');
        const consoleOutput = document.getElementById('consoleOutput');
        const executePopup = document.getElementById('executePopup');
        const executeOverlay = document.getElementById('executeOverlay');
        const executeInput = document.getElementById('executeInput');
        let currentSerial = '';
        let currentCode = '';
        let currentValidationCode = '';
        let actionHistory = [];
        let lastAlertTime = 0;
        let userPassphrase = 'default-passphrase'; // Default for public use
        let serialCounter = parseInt(localStorage.getItem('serialCounter')) || 1;

        // PWA Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').then(() => {
                console.log('Service Worker registered');
            }).catch(err => {
                console.error('Service Worker registration failed:', err);
            });
        }

        // Input Sanitization
        function sanitizeInput(input) {
            if (typeof input !== 'string') {
                console.log('Invalid input type, returning empty string');
                return '';
            }
            const sanitized = input
                .replace(/[<>&"']/g, '') // Prevent XSS
                .replace(/[^\x20-\x7E]/g, '') // Allow printable ASCII only
                .trim()
                .slice(0, 1000); // Limit length
            console.log('Sanitized input:', sanitized);
            return sanitized;
        }

        consoleInput.addEventListener('input', () => {
            consoleInput.value = sanitizeInput(consoleInput.value);
        });

        executeInput.addEventListener('input', () => {
            executeInput.value = sanitizeInput(executeInput.value);
        });

        function showAlert(message) {
            const now = Date.now();
            console.error('Alert:', message);
            // Reduced cooldown to 2 seconds for critical errors
            if (now - lastAlertTime < 2000) return;
            lastAlertTime = now;
            const modal = document.createElement('div');
            modal.className = 'popup';
            modal.innerHTML = `<h3>Alert</h3><p>${sanitizeInput(message)}</p><button class="btn" onclick="this.parentElement.remove()">OK</button>`;
            document.body.appendChild(modal);
            modal.style.display = 'block';
        }

        // Compression/Decompression
        function compressMessage(message) {
            try {
                console.log('Compressing message:', message);
                const enc = new TextEncoder();
                const compressed = pako.gzip(enc.encode(message));
                const base64 = btoa(String.fromCharCode(...compressed));
                console.log('Compressed message:', base64);
                return base64;
            } catch (err) {
                console.error('Compression failed:', err);
                showAlert('Compression failed: ' + err.message);
                return null;
            }
        }

        function decompressMessage(compressed) {
            try {
                console.log('Decompressing message:', compressed);
                const dec = new Uint8Array(atob(compressed).split('').map(c => c.charCodeAt(0)));
                const decompressed = pako.ungzip(dec, { to: 'string' });
                console.log('Decompressed message:', decompressed);
                return decompressed;
            } catch (err) {
                console.error('Decompression failed:', err);
                showAlert('Decompression failed: ' + err.message);
                return null;
            }
        }

        // Cryptographic Functions
        async function deriveKey(serial, passphrase, salt) {
            try {
                console.log('Deriving key for serial:', serial);
                const enc = new TextEncoder();
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    enc.encode(passphrase),
                    'PBKDF2',
                    false,
                    ['deriveBits', 'deriveKey']
                );
                const key = await crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: enc.encode(salt),
                        iterations: 100000,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );
                console.log('Key derived successfully');
                return key;
            } catch (err) {
                console.error('Key derivation failed:', err);
                showAlert('Key derivation failed: ' + err.message);
                return null;
            }
        }

        async function encryptMessage(message, serial) {
            try {
                console.log('Encrypting message:', message, 'for serial:', serial);
                if (!message) {
                    console.log('Empty message, skipping encryption');
                    return null; // Allow empty messages
                }
                const compressed = compressMessage(message);
                if (!compressed) {
                    console.error('Compression returned null');
                    return null;
                }
                const salt = crypto.getRandomValues(new Uint8Array(16));
                const key = await deriveKey(serial, userPassphrase, salt);
                if (!key) {
                    console.error('Key derivation returned null');
                    return null;
                }
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const enc = new TextEncoder();
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv },
                    key,
                    enc.encode(compressed)
                );
                const result = {
                    salt: btoa(String.fromCharCode(...salt)),
                    iv: btoa(String.fromCharCode(...iv)),
                    encrypted: btoa(String.fromCharCode(...new Uint8Array(encrypted)))
                };
                console.log('Encrypted message:', result);
                return result;
            } catch (err) {
                console.error('Encryption failed:', err);
                showAlert('Encryption failed: ' + err.message);
                return null;
            }
        }

        async function decryptMessage({ salt, iv, encrypted }, serial) {
            try {
                console.log('Decrypting message for serial:', serial);
                const key = await deriveKey(serial, userPassphrase, new Uint8Array(atob(salt).split('').map(c => c.charCodeAt(0))));
                if (!key) return null;
                const dec = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: new Uint8Array(atob(iv).split('').map(c => c.charCodeAt(0))) },
                    key,
                    new Uint8Array(atob(encrypted).split('').map(c => c.charCodeAt(0)))
                );
                const compressed = new TextDecoder().decode(dec);
                const decompressed = decompressMessage(compressed);
                console.log('Decrypted and decompressed message:', decompressed);
                return decompressed;
            } catch (err) {
                console.error('Decryption failed:', err);
                showAlert('Decryption failed: ' + err.message);
                return null;
            }
        }

        // Triple-Code Validation
        async function generateValidationCode(serial, code) {
            try {
                console.log('Generating validation code for serial:', serial, 'code:', code);
                const enc = new TextEncoder();
                const key = await crypto.subtle.importKey(
                    'raw',
                    enc.encode('grid-locker-secret'),
                    { name: 'HMAC', hash: 'SHA-256' },
                    false,
                    ['sign']
                );
                const signature = await crypto.subtle.sign(
                    'HMAC',
                    key,
                    enc.encode(`${serial}:${code}`)
                );
                const validationCode = `VAL-${btoa(String.fromCharCode(...new Uint8Array(signature))).slice(0, 12)}`;
                console.log('Validation code generated:', validationCode);
                return validationCode;
            } catch (err) {
                console.error('Validation code generation failed:', err);
                showAlert('Validation code generation failed: ' + err.message);
                return null;
            }
        }

        async function verifyValidationCode(serial, code, validationCode) {
            const expected = await generateValidationCode(serial, code);
            const isValid = expected === validationCode;
            console.log('Validation code verification:', { serial, code, validationCode, expected, isValid });
            return isValid;
        }

        // Data Obfuscation
        function obfuscateData(data) {
            try {
                console.log('Obfuscating data:', data);
                const json = JSON.stringify(data);
                console.log('JSON stringified:', json);
                const enc = new TextEncoder();
                const bytes = enc.encode(json);
                const base64 = btoa(String.fromCharCode(...bytes));
                console.log('Base64 encoded:', base64);
                return base64;
            } catch (err) {
                console.error('Obfuscation failed:', err);
                showAlert('Obfuscation failed: ' + err.message);
                return null;
            }
        }

        function deobfuscateData(obfuscated) {
            try {
                console.log('Deobfuscating data:', obfuscated);
                if (!obfuscated || !/^[A-Za-z0-9+/=]+$/.test(obfuscated)) {
                    throw new Error('Invalid base64 string');
                }
                const bytes = new Uint8Array(atob(obfuscated).split('').map(c => c.charCodeAt(0)));
                const dec = new TextDecoder();
                const json = dec.decode(bytes);
                console.log('Decoded JSON:', json);
                return JSON.parse(json);
            } catch (err) {
                console.error('Deobfuscation failed:', err);
                showAlert('Deobfuscation failed: ' + err.message);
                return null;
            }
        }

        // Storage Functions
        async function storeSerialMap(serialMap) {
            try {
                console.log('Storing serialMap:', [...serialMap]);
                const json = JSON.stringify([...serialMap]);
                const encrypted = await encryptMessage(json, 'storage-key');
                console.log('Encrypted serialMap:', encrypted);
                if (!encrypted) {
                    console.error('Encryption failed for serialMap');
                    return;
                }
                const obfuscated = obfuscateData(encrypted);
                console.log('Obfuscated serialMap:', obfuscated);
                if (!obfuscated) {
                    console.error('Obfuscation failed for serialMap');
                    return;
                }
                localStorage.setItem('serialMap', obfuscated);
                localStorage.setItem('storageVersion', STORAGE_VERSION);
                console.log('SerialMap stored successfully');
            } catch (err) {
                console.error('Storage failed:', err);
                showAlert('Storage failed: ' + err.message);
            }
        }

        async function loadSerialMap() {
            try {
                console.log('Loading serialMap');
                const storedVersion = localStorage.getItem('storageVersion');
                if (storedVersion !== STORAGE_VERSION) {
                    console.log('Version mismatch, clearing storage');
                    localStorage.removeItem('serialMap');
                    localStorage.setItem('storageVersion', STORAGE_VERSION);
                    return new Map();
                }
                const obfuscated = localStorage.getItem('serialMap');
                console.log('Retrieved obfuscated:', obfuscated);
                if (!obfuscated) {
                    console.log('No serialMap in storage');
                    return new Map();
                }
                const encrypted = deobfuscateData(obfuscated);
                console.log('Deobfuscated encrypted:', encrypted);
                if (!encrypted) {
                    console.error('Deobfuscation returned null, clearing storage');
                    localStorage.removeItem('serialMap');
                    return new Map();
                }
                const decrypted = await decryptMessage(encrypted, 'storage-key');
                console.log('Decrypted serialMap:', decrypted);
                if (!decrypted) {
                    console.error('Decryption returned null, clearing storage');
                    localStorage.removeItem('serialMap');
                    return new Map();
                }
                const serialMap = new Map(JSON.parse(decrypted));
                console.log('Loaded serialMap:', [...serialMap]);
                return serialMap;
            } catch (err) {
                console.error('Load serialMap failed:', err);
                showAlert('Load serialMap failed: ' + err.message);
                localStorage.removeItem('serialMap');
                return new Map();
            }
        }

        // Grid Generation and Execution
        async function generateGrid() {
            monitorAction('generate');
            try {
                console.log('Starting generateGrid');
                const message = sanitizeInput(consoleInput.value);
                console.log('Sanitized message:', message);
                let serialMap = await loadSerialMap();
                if (!serialMap) {
                    console.error('loadSerialMap returned null');
                    showAlert('Failed to load serial map');
                    return;
                }
                console.log('Loaded serialMap:', [...serialMap]);
                let newCode;
                let attempts = 0;
                do {
                    if (attempts++ > 100) {
                        console.error('Too many attempts to generate unique code');
                        showAlert('Failed to generate unique code');
                        return;
                    }
                    newCode = generateCrypticCode();
                } while (Array.from(serialMap.values()).some(data => data.code === newCode));
                console.log('Generated code:', newCode);
                const serial = generateSerialNumber();
                if (!serial) {
                    console.error('Serial generation failed');
                    showAlert('Failed to generate serial number');
                    return;
                }
                console.log('Generated serial:', serial);
                const encryptedMessage = message ? await encryptMessage(message, serial) : null;
                console.log('Encrypted message:', encryptedMessage);
                if (message && !encryptedMessage) {
                    console.error('Encryption failed for non-empty message');
                    showAlert('Message encryption failed');
                    return;
                }
                serialMap.set(serial, { code: newCode, encryptedMessage });
                console.log('Updating serialMap with:', { serial, code: newCode, encryptedMessage });
                await storeSerialMap(serialMap);
                console.log('SerialMap stored');
                currentSerial = serial;
                currentCode = newCode;
                currentValidationCode = await generateValidationCode(serial, newCode);
                console.log('Validation code:', currentValidationCode);
                if (!currentValidationCode) {
                    console.error('Validation code generation failed');
                    showAlert('Validation code generation failed');
                    return;
                }
                console.log('Generating image for seed:', newCode, 'serial:', serial);
                generateImageFromSeed(newCode, serial, message);
                console.log('Updating consoleOutput');
                consoleOutput.textContent = `${serial},${newCode},${currentValidationCode}${message ? `\nMessage: ${message}` : ''}`;
                console.log('generateGrid completed successfully');
            } catch (err) {
                console.error('Grid generation failed:', err);
                showAlert('Grid generation failed: ' + err.message);
            }
        }

        async function executeGrid() {
            monitorAction('execute');
            try {
                console.log('Starting executeGrid');
                const input = sanitizeInput(executeInput.value);
                console.log('Execute input:', input);
                if (!input) {
                    showAlert('Please enter serial, code, and validation code');
                    return;
                }
                // Handle both comma-separated and newline-separated inputs
                let parts = input.includes(',') ? input.split(',').map(s => s.trim()) : input.split('\n').map(s => s.trim());
                console.log('Input parts:', parts);
                if (parts.length !== 3) {
                    showAlert('Invalid input format! Use: serial,code,validation (e.g., HOLO-000001-A7K,Ω-CODE:ΔΩΨ123#@*,VAL-XXXXXXXXXXXX) or newlines');
                    return;
                }
                const [serial, code, validationCode] = parts;
                if (!serial || !code || !validationCode) {
                    showAlert('All fields are required: serial, code, validation');
                    return;
                }
                if (!serial.match(/HOLO-\d{6}-[A-Z0-9]{3}/)) {
                    console.log('Invalid serial format:', serial);
                    showAlert('Invalid serial format! Must be HOLO-XXXXXX-XXX');
                    return;
                }
                if (!code.startsWith('Ω-CODE:')) {
                    console.log('Invalid code format:', code);
                    showAlert('Invalid code format! Must start with Ω-CODE:');
                    return;
                }
                if (!validationCode.startsWith('VAL-')) {
                    console.log('Invalid validation code format:', validationCode);
                    showAlert('Invalid validation code format! Must start with VAL-');
                    return;
                }
                console.log('Validating:', { serial, code, validationCode });
                if (!(await verifyValidationCode(serial, code, validationCode))) {
                    showAlert('Invalid validation code!');
                    return;
                }
                let serialMap = await loadSerialMap();
                console.log('Loaded serialMap:', [...serialMap]);
                if (serialMap.has(serial)) {
                    const { code: storedCode, encryptedMessage } = serialMap.get(serial);
                    if (storedCode !== code) {
                        showAlert('Code mismatch!');
                        return;
                    }
                    const message = encryptedMessage ? await decryptMessage(encryptedMessage, serial) : '';
                    console.log('Decrypted message:', message);
                    if (encryptedMessage && !message) return;
                    currentSerial = serial;
                    currentCode = code;
                    currentValidationCode = validationCode;
                    generateImageFromSeed(code, serial, message);
                    consoleOutput.textContent = `${serial},${code},${validationCode}${message ? `\nMessage: ${message}` : ''}`;
                } else {
                    serialMap.set(serial, { code, encryptedMessage: null });
                    await storeSerialMap(serialMap);
                    currentSerial = serial;
                    currentCode = code;
                    currentValidationCode = validationCode;
                    generateImageFromSeed(code, serial);
                    consoleOutput.textContent = `${serial},${code},${validationCode}`;
                }
                closeExecutePopup();
            } catch (err) {
                console.error('Grid execution failed:', err);
                showAlert('Grid execution failed: ' + err.message);
            }
        }

        function generateCrypticCode() {
            const glyphs = 'ΔΩΨΘΣΦΩΓΛΞΠΩ0123456789#@&%*+-=<>';
            let code = '';
            for (let i = 0; i < 9; i++) {
                code += glyphs.charAt(Math.floor(Math.random() * glyphs.length));
            }
            console.log('Generated cryptic code:', `Ω-CODE:${code}`);
            return `Ω-CODE:${code}`;
        }

        function generateSerialNumber() {
            try {
                const paddedNumber = String(serialCounter++).padStart(6, '0');
                const suffix = Math.random().toString(36).substr(2, 3).toUpperCase();
                const serial = `HOLO-${paddedNumber}-${suffix}`;
                localStorage.setItem('serialCounter', serialCounter);
                console.log('Generated serial number:', serial);
                return serial;
            } catch (err) {
                console.error('Serial generation failed:', err);
                showAlert('Serial generation failed: ' + err.message);
                return null;
            }
        }

        function generateImageFromSeed(seed, serial, message = '') {
            try {
                console.log('Generating image from seed:', seed, 'serial:', serial, 'message:', message);
                hologram.innerHTML = '';
                hologram.classList.remove('revealed');

                const hash = hashCode(seed);
                const rand = (min, max) => min + (hash % (max - min + 1));
                const randFloat = (min, max) => min + ((hash % 10000) / 10000) * (max - min);

                const gridBase = document.createElement('div');
                gridBase.className = 'grid-base';
                gridBase.style.opacity = randFloat(0.4, 0.6);
                hologram.appendChild(gridBase);

                const layerCount = rand(2, 4);
                for (let i = 0; i < layerCount; i++) {
                    const layer = document.createElement('div');
                    layer.className = 'grid-layer';
                    const z = randFloat(-60, 60) * (i + 1) / layerCount;
                    layer.style.cssText = `
                        transform: translateZ(${z}px) rotateY(${randFloat(-12, 12)}deg) rotateX(${randFloat(-12, 12)}deg);
                        opacity: ${randFloat(0.3, 0.7)};
                    `;
                    hologram.appendChild(layer);
                }

                const wireframeCount = rand(1, 2);
                for (let i = 0; i < wireframeCount; i++) {
                    const wireframe = document.createElement('div');
                    wireframe.className = 'grid-wireframe';
                    const z = randFloat(-50, 50);
                    const scale = randFloat(0.8, 1.1);
                    wireframe.style.cssText = `
                        transform: translateZ(${z}px) scale(${scale}) rotateX(${randFloat(-20, 20)}deg) rotateY(${randFloat(-20, 20)}deg);
                        opacity: ${randFloat(0.5, 0.9)};
                    `;
                    hologram.appendChild(wireframe);
                }

                const planeCount = rand(2, 3);
                for (let i = 0; i < planeCount; i++) {
                    const plane = document.createElement('div');
                    plane.className = 'grid-plane';
                    const width = randFloat(40, 100);
                    const height = randFloat(40, 100);
                    const left = randFloat(0, 100 - (width / 1.8));
                    const top = randFloat(0, 100 - (height / 1.8));
                    const z = randFloat(-80, 80);
                    plane.style.cssText = `
                        width: ${width}px;
                        height: ${height}px;
                        left: ${left}%;
                        top: ${top}%;
                        transform: translateZ(${z}px) rotateX(${randFloat(-35, 35)}deg) rotateY(${randFloat(-35, 35)}deg);
                    `;
                    hologram.appendChild(plane);
                }

                consoleOutput.textContent = `${currentSerial},${currentCode},${currentValidationCode}${message ? `\nMessage: ${message}` : ''}`;
                setTimeout(() => {
                    hologram.classList.add('revealed');
                    console.log('Hologram revealed');
                }, 100);
            } catch (err) {
                console.error('Grid rendering failed:', err);
                showAlert('Grid rendering failed: ' + err.message);
            }
        }

        function hashCode(str) {
            let hash = 2166136261;
            for (let i = 0; i < str.length; i++) {
                hash ^= str.charCodeAt(i);
                hash *= 16777619;
            }
            console.log('Hash code for:', str, 'is:', Math.abs(hash));
            return Math.abs(hash);
        }

        function showExecutePopup() {
            executeInput.value = '';
            executePopup.style.display = 'block';
            executeOverlay.style.display = 'block';
            console.log('Execute popup shown');
        }

        function closeExecutePopup() {
            executePopup.style.display = 'none';
            executeOverlay.style.display = 'none';
            console.log('Execute popup closed');
        }

        function copyCode() {
            if (!currentSerial || !currentCode || !currentValidationCode) {
                showAlert('Generate or execute a grid first!');
                return;
            }
            const code = `${currentSerial},${currentCode},${currentValidationCode}`;
            console.log('Copying code:', code);
            navigator.clipboard.writeText(code).then(() => {
                showAlert('Code copied!');
                console.log('Code copied successfully');
            }).catch(err => {
                console.error('Copy failed:', err);
                showAlert('Copy failed: ' + err.message);
            });
        }

        function clearConsole() {
            consoleInput.value = '';
            consoleOutput.textContent = '';
            console.log('Console cleared');
        }

        function monitorAction(action) {
            actionHistory.push({ action, timestamp: Date.now() });
            if (actionHistory.length > 100) actionHistory.shift();
            if (detectAnomaly(actionHistory)) {
                showAlert('Suspicious activity detected! Please slow down.');
            }
            console.log('Action monitored:', action);
        }

        function detectAnomaly(history) {
            const recent = history.slice(-10);
            const isAnomaly = recent.length === 10 && recent[9].timestamp - recent[0].timestamp < 5000; // 10 actions in 5 seconds
            console.log('Anomaly detection:', { recentLength: recent.length, isAnomaly });
            return isAnomaly;
        }

        window.addEventListener('load', async () => {
            try {
                console.log('Window load event triggered');
                // Clear incompatible storage
                const storedVersion = localStorage.getItem('storageVersion');
                if (storedVersion !== STORAGE_VERSION) {
                    console.log('Clearing incompatible storage');
                    localStorage.removeItem('serialMap');
                    localStorage.setItem('storageVersion', STORAGE_VERSION);
                }
                const initCode = generateCrypticCode();
                const initSerial = `HOLO-${String(1).padStart(6, '0')}-INIT`;
                currentValidationCode = await generateValidationCode(initSerial, initCode);
                if (currentValidationCode) {
                    console.log('Initializing with:', { initSerial, initCode, currentValidationCode });
                    generateImageFromSeed(initCode, initSerial);
                    consoleOutput.textContent = `${initSerial},${initCode},${currentValidationCode}`;
                    currentSerial = initSerial;
                    currentCode = initCode;
                } else {
                    console.error('Initial validation code generation failed');
                    showAlert('Initialization failed: Validation code generation');
                }
            } catch (err) {
                console.error('Initialization failed:', err);
                showAlert('Initialization failed: ' + err.message);
            }
        });
    </script>
</body>
</html>
