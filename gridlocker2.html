<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#00ff00">
    <link rel="manifest" href="/manifest.json">
    <title>Grid Locker</title>
    <!-- Inline CSS for reliability -->
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #000000;
            font-family: 'Courier New', monospace;
            color: #00ff00;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .app-container {
            width: 100%;
            max-width: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 0;
            position: relative;
        }

        .hologram-container {
            width: 220px;
            height: 180px;
            position: relative;
            overflow: hidden;
            z-index: 1;
        }

        .hologram {
            width: 180px;
            height: 180px;
            position: absolute;
            top: 0;
            left: 20px;
            transform-style: preserve-3d;
            animation: rotateHologram 30s infinite linear;
            -webkit-transform-style: preserve-3d;
            -moz-transform-style: preserve-3d;
        }

        .grid-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #00ff00, #00cc00);
            opacity: 0.5;
        }

        .grid-layer {
            position: absolute;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(45deg, transparent, transparent 8px, rgba(0, 255, 0, 0.5) 8px, rgba(0, 255, 0, 0.5) 10px);
            animation: shiftGrid 10s infinite linear;
        }

        .grid-wireframe {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 1px solid #00ff00;
        }

        .grid-plane {
            position: absolute;
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            animation: pulsePlane 5s infinite;
        }

        .button-container {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            z-index: 1;
        }

        .btn {
            padding: 8px 14px;
            font-size: 12px;
            color: #000000;
            background: #00ff00;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #00cc00;
        }

        .console-section {
            width: 100%;
            max-width: 200px;
            margin: 10px 0;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 0;
        }

        .console-section textarea {
            width: 100%;
            height: 100px;
            padding: 10px;
            background: #000000;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            box-sizing: border-box;
            resize: none;
            margin-top: 10px;
        }

        .console-section button {
            padding: 6px 12px;
            background: #00ff00;
            color: #000000;
            border: none;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
        }

        .console-section #consoleOutput {
            margin-top: 5px;
            font-size: 12px;
            color: #00ff00;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 180px;
            padding: 12px;
            background: #000000;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 1000;
        }

        .popup h3 {
            margin: 0 0 10px;
            font-size: 14px;
        }

        .popup input {
            width: 100%;
            padding: 6px;
            background: #000000;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .popup .btn {
            width: 100%;
            margin: 5px 0 0;
            padding: 8px 14px;
        }

        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }

        footer {
            width: 100%;
            max-width: 200px;
            text-align: center;
            font-size: 10px;
            color: #00ff00;
            margin-top: 10px;
        }

        @keyframes rotateHologram {
            0% { transform: rotateY(0deg) rotateX(15deg); }
            100% { transform: rotateY(360deg) rotateX(15deg); }
        }

        @keyframes shiftGrid {
            0% { background-position: 0 0; }
            100% { background-position: 80px 80px; }
        }

        @keyframes pulsePlane {
            0%, 100% { transform: scale(1) translateZ(0); }
            50% { transform: scale(1.1) translateZ(12px); }
        }

        @media (prefers-reduced-motion: reduce) {
            .hologram, .grid-layer, .grid-plane {
                animation: none;
            }
        }

        .fallback {
            background: #000000;
            color: #00ff00;
            font-family: monospace;
            padding: 20px;
            text-align: center;
        }
    </style>
    <!-- Include pako for compression -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
</head>
<body>
    <div class="app-container">
        <div class="hologram-container">
            <div class="hologram" id="hologram"></div>
        </div>
        <div class="console-section">
            <textarea id="consoleInput" placeholder="Enter message"></textarea>
            <button onclick="clearConsole()">Clear</button>
            <div id="consoleOutput"></div>
        </div>
        <div class="button-container">
            <button class="btn" onclick="generateGrid()">Generate</button>
            <button class="btn" onclick="copyCode()">Copy</button>
            <button class="btn" onclick="showExecutePopup()">Execute</button>
        </div>
    </div>

    <div class="popup-overlay" id="executeOverlay"></div>
    <div class="popup" id="executePopup">
        <h3>Execute Grid</h3>
        <input type="text" id="executeInput" placeholder="Enter serial,code,validation (e.g., HOLO-000001-A7K,Ω-CODE:ΔΩΨ123#@*,VAL-XXXXXXXXXXXX)">
        <button class="btn" onclick="executeGrid()">Submit</button>
        <button class="btn" onclick="closeExecutePopup()">Cancel</button>
    </div>

    <footer>
        © WebXOS 2025<br>
        Usage: Generate encrypts and compresses message with unique grid keys. Copy saves codes. Execute loads grid and message. Secure PWA for public use.
    </footer>

    <script>
        const hologram = document.getElementById('hologram');
        const consoleInput = document.getElementById('consoleInput');
        const consoleOutput = document.getElementById('consoleOutput');
        const executePopup = document.getElementById('executePopup');
        const executeOverlay = document.getElementById('executeOverlay');
        const executeInput = document.getElementById('executeInput');
        let currentSerial = '';
        let currentCode = '';
        let currentValidationCode = '';
        let actionHistory = [];
        let lastAlertTime = 0;
        let userPassphrase = 'default-passphrase'; // Default for public use
        let serialCounter = parseInt(localStorage.getItem('serialCounter')) || 1;

        // PWA Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').then(() => {
                console.log('Service Worker registered');
            }).catch(err => {
                console.error('Service Worker registration failed:', err);
            });
        }

        // Input Sanitization
        function sanitizeInput(input) {
            if (typeof input !== 'string') return '';
            return input
                .replace(/[<>&"']/g, '')
                .replace(/[^\x20-\x7E]/g, '')
                .slice(0, 1000);
        }

        consoleInput.addEventListener('input', () => {
            consoleInput.value = sanitizeInput(consoleInput.value);
        });

        executeInput.addEventListener('input', () => {
            executeInput.value = sanitizeInput(executeInput.value);
        });

        function showAlert(message) {
            const now = Date.now();
            if (now - lastAlertTime < 5000) return; // 5-second cooldown
            lastAlertTime = now;
            const modal = document.createElement('div');
            modal.className = 'popup';
            modal.innerHTML = `<h3>Alert</h3><p>${sanitizeInput(message)}</p><button class="btn" onclick="this.parentElement.remove()">OK</button>`;
            document.body.appendChild(modal);
            modal.style.display = 'block';
        }

        // Compression/Decompression
        function compressMessage(message) {
            try {
                const enc = new TextEncoder();
                const compressed = pako.gzip(enc.encode(message));
                return btoa(String.fromCharCode(...compressed));
            } catch (err) {
                showAlert('Compression failed: ' + err.message);
                return null;
            }
        }

        function decompressMessage(compressed) {
            try {
                const dec = new Uint8Array(atob(compressed).split('').map(c => c.charCodeAt(0)));
                const decompressed = pako.ungzip(dec, { to: 'string' });
                return decompressed;
            } catch (err) {
                showAlert('Decompression failed: ' + err.message);
                return null;
            }
        }

        // Cryptographic Functions
        async function deriveKey(serial, passphrase, salt) {
            try {
                const enc = new TextEncoder();
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    enc.encode(passphrase),
                    'PBKDF2',
                    false,
                    ['deriveBits', 'deriveKey']
                );
                return crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: enc.encode(salt),
                        iterations: 100000,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );
            } catch (err) {
                showAlert('Key derivation failed: ' + err.message);
                return null;
            }
        }

        async function encryptMessage(message, serial) {
            try {
                const compressed = compressMessage(message);
                if (!compressed) return null;
                const salt = crypto.getRandomValues(new Uint8Array(16));
                const key = await deriveKey(serial, userPassphrase, salt);
                if (!key) return null;
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const enc = new TextEncoder();
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv },
                    key,
                    enc.encode(compressed)
                );
                return {
                    salt: btoa(String.fromCharCode(...salt)),
                    iv: btoa(String.fromCharCode(...iv)),
                    encrypted: btoa(String.fromCharCode(...new Uint8Array(encrypted)))
                };
            } catch (err) {
                showAlert('Encryption failed: ' + err.message);
                return null;
            }
        }

        async function decryptMessage({ salt, iv, encrypted }, serial) {
            try {
                const key = await deriveKey(serial, userPassphrase, new Uint8Array(atob(salt).split('').map(c => c.charCodeAt(0))));
                if (!key) return null;
                const dec = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: new Uint8Array(atob(iv).split('').map(c => c.charCodeAt(0))) },
                    key,
                    new Uint8Array(atob(encrypted).split('').map(c => c.charCodeAt(0)))
                );
                const compressed = new TextDecoder().decode(dec);
                return decompressMessage(compressed);
            } catch (err) {
                showAlert('Decryption failed: ' + err.message);
                return null;
            }
        }

        // Triple-Code Validation
        async function generateValidationCode(serial, code) {
            try {
                const enc = new TextEncoder();
                const key = await crypto.subtle.importKey(
                    'raw',
                    enc.encode('grid-locker-secret'),
                    { name: 'HMAC', hash: 'SHA-256' },
                    false,
                    ['sign']
                );
                const signature = await crypto.subtle.sign(
                    'HMAC',
                    key,
                    enc.encode(`${serial}:${code}`)
                );
                return `VAL-${btoa(String.fromCharCode(...new Uint8Array(signature))).slice(0, 12)}`;
            } catch (err) {
                showAlert('Validation code generation failed: ' + err.message);
                return null;
            }
        }

        async function verifyValidationCode(serial, code, validationCode) {
            const expected = await generateValidationCode(serial, code);
            return expected === validationCode;
        }

        // Data Obfuscation
        function obfuscateData(data) {
            const json = JSON.stringify(data);
            const enc = new TextEncoder();
            const bytes = enc.encode(json);
            const obfuscated = Array.from(bytes).map(b => b ^ 0x55); // Simple XOR obfuscation
            return btoa(String.fromCharCode(...obfuscated));
        }

        function deobfuscateData(obfuscated) {
            const bytes = new Uint8Array(atob(obfuscated).split('').map(c => c.charCodeAt(0)));
            const deobfuscated = Array.from(bytes).map(b => b ^ 0x55);
            const dec = new TextDecoder();
            return JSON.parse(dec.decode(new Uint8Array(deobfuscated)));
        }

        // Storage Functions
        async function storeSerialMap(serialMap) {
            try {
                const encrypted = await encryptMessage(JSON.stringify([...serialMap]), 'storage-key');
                if (!encrypted) return;
                localStorage.setItem('serialMap', obfuscateData(encrypted));
            } catch (err) {
                showAlert('Storage failed: ' + err.message);
            }
        }

        async function loadSerialMap() {
            try {
                const obfuscated = localStorage.getItem('serialMap');
                if (!obfuscated) return new Map();
                const encrypted = deobfuscateData(obfuscated);
                const decrypted = await decryptMessage(encrypted, 'storage-key');
                if (!decrypted) return new Map();
                return new Map(JSON.parse(decrypted));
            } catch (err) {
                showAlert('Failed to load storage: ' + err.message);
                return new Map();
            }
        }

        // Grid Generation and Execution
        async function generateGrid() {
            monitorAction('generate');
            try {
                const message = sanitizeInput(consoleInput.value);
                let serialMap = await loadSerialMap();
                let newCode;
                do {
                    newCode = generateCrypticCode();
                } while (Array.from(serialMap.values()).some(data => data.code === newCode));
                const serial = generateSerialNumber(newCode);
                const encryptedMessage = message ? await encryptMessage(message, serial) : null;
                if (message && !encryptedMessage) return;
                serialMap.set(serial, { code: newCode, encryptedMessage });
                await storeSerialMap(serialMap);
                currentSerial = serial;
                currentCode = newCode;
                currentValidationCode = await generateValidationCode(serial, newCode);
                if (!currentValidationCode) return;
                generateImageFromSeed(newCode, serial, message);
                consoleOutput.textContent = `${serial}\n${newCode}\n${currentValidationCode}${message ? `\nMessage: ${message}` : ''}`;
            } catch (err) {
                showAlert('Grid generation failed: ' + err.message);
            }
        }

        async function executeGrid() {
            monitorAction('execute');
            try {
                const input = sanitizeInput(executeInput.value);
                const [serial, code, validationCode] = input.split(',').map(s => s.trim());
                if (!serial.match(/HOLO-\d{6}-[A-Z0-9]{3}/) || !code.startsWith('Ω-CODE:') || !validationCode.startsWith('VAL-')) {
                    showAlert('Invalid input format! Use: HOLO-XXXXXX-XXX,Ω-CODE:XXXX,VAL-XXXX');
                    return;
                }
                if (!(await verifyValidationCode(serial, code, validationCode))) {
                    showAlert('Invalid validation code!');
                    return;
                }
                let serialMap = await loadSerialMap();
                if (serialMap.has(serial)) {
                    const { code: storedCode, encryptedMessage } = serialMap.get(serial);
                    if (storedCode !== code) {
                        showAlert('Code mismatch!');
                        return;
                    }
                    const message = encryptedMessage ? await decryptMessage(encryptedMessage, serial) : '';
                    if (encryptedMessage && !message) return;
                    currentSerial = serial;
                    currentCode = code;
                    currentValidationCode = validationCode;
                    generateImageFromSeed(code, serial, message);
                    consoleOutput.textContent = `${serial}\n${code}\n${validationCode}${message ? `\nMessage: ${message}` : ''}`;
                } else {
                    serialMap.set(serial, { code, encryptedMessage: null });
                    await storeSerialMap(serialMap);
                    currentSerial = serial;
                    currentCode = code;
                    currentValidationCode = validationCode;
                    generateImageFromSeed(code, serial);
                    consoleOutput.textContent = `${serial}\n${code}\n${validationCode}`;
                }
                closeExecutePopup();
            } catch (err) {
                showAlert('Grid execution failed: ' + err.message);
            }
        }

        function generateCrypticCode() {
            const glyphs = 'ΔΩΨΘΣΦΩΓΛΞΠΩ0123456789#@&%*+-=<>';
            let code = '';
            for (let i = 0; i < 9; i++) {
                code += glyphs.charAt(Math.floor(Math.random() * glyphs.length));
            }
            return `Ω-CODE: ${code}`;
        }

        function generateSerialNumber(code) {
            let serial;
            do {
                const paddedNumber = String(serialCounter++).padStart(6, '0');
                const suffix = Math.random().toString(36).substr(2, 3).toUpperCase();
                serial = `HOLO-${paddedNumber}-${suffix}`;
            } while (localStorage.getItem('serialMap') && JSON.parse(localStorage.getItem('serialMap') || '{}').hasOwnProperty(serial));
            localStorage.setItem('serialCounter', serialCounter);
            return serial;
        }

        function generateImageFromSeed(seed, serial, message = '') {
            try {
                hologram.innerHTML = '';
                hologram.classList.remove('revealed');

                const hash = hashCode(seed);
                const rand = (min, max) => min + (hash % (max - min + 1));
                const randFloat = (min, max) => min + ((hash % 10000) / 10000) * (max - min);

                const gridBase = document.createElement('div');
                gridBase.className = 'grid-base';
                gridBase.style.opacity = randFloat(0.4, 0.6);
                hologram.appendChild(gridBase);

                const layerCount = rand(2, 4);
                for (let i = 0; i < layerCount; i++) {
                    const layer = document.createElement('div');
                    layer.className = 'grid-layer';
                    const z = randFloat(-60, 60) * (i + 1) / layerCount;
                    layer.style.cssText = `
                        transform: translateZ(${z}px) rotateY(${randFloat(-12, 12)}deg) rotateX(${randFloat(-12, 12)}deg);
                        opacity: ${randFloat(0.3, 0.7)};
                    `;
                    hologram.appendChild(layer);
                }

                const wireframeCount = rand(1, 2);
                for (let i = 0; i < wireframeCount; i++) {
                    const wireframe = document.createElement('div');
                    wireframe.className = 'grid-wireframe';
                    const z = randFloat(-50, 50);
                    const scale = randFloat(0.8, 1.1);
                    wireframe.style.cssText = `
                        transform: translateZ(${z}px) scale(${scale}) rotateX(${randFloat(-20, 20)}deg) rotateY(${randFloat(-20, 20)}deg);
                        opacity: ${randFloat(0.5, 0.9)};
                    `;
                    hologram.appendChild(wireframe);
                }

                const planeCount = rand(2, 3);
                for (let i = 0; i < planeCount; i++) {
                    const plane = document.createElement('div');
                    plane.className = 'grid-plane';
                    const width = randFloat(40, 100);
                    const height = randFloat(40, 100);
                    const left = randFloat(0, 100 - (width / 1.8));
                    const top = randFloat(0, 100 - (height / 1.8));
                    const z = randFloat(-80, 80);
                    plane.style.cssText = `
                        width: ${width}px;
                        height: ${height}px;
                        left: ${left}%;
                        top: ${top}%;
                        transform: translateZ(${z}px) rotateX(${randFloat(-35, 35)}deg) rotateY(${randFloat(-35, 35)}deg);
                    `;
                    hologram.appendChild(plane);
                }

                if (message) {
                    consoleOutput.textContent = `${currentSerial}\n${currentCode}\n${currentValidationCode}\nMessage: ${message}`;
                }
                setTimeout(() => {
                    hologram.classList.add('revealed');
                }, 100);
            } catch (err) {
                showAlert('Grid rendering failed: ' + err.message);
            }
        }

        function hashCode(str) {
            let hash = 2166136261;
            for (let i = 0; i < str.length; i++) {
                hash ^= str.charCodeAt(i);
                hash *= 16777619;
            }
            return Math.abs(hash);
        }

        function showExecutePopup() {
            executeInput.value = '';
            executePopup.style.display = 'block';
            executeOverlay.style.display = 'block';
        }

        function closeExecutePopup() {
            executePopup.style.display = 'none';
            executeOverlay.style.display = 'none';
        }

        function copyCode() {
            if (!currentSerial || !currentCode || !currentValidationCode) {
                showAlert('Generate or execute a grid first!');
                return;
            }
            const code = `${currentSerial}\n${currentCode}\n${currentValidationighborhoodCode}`;
            if (code.length > 100) {
                showAlert('Code too long!');
                return;
            }
            navigator.clipboard.writeText(code).then(() => showAlert('Code copied!')).catch(err => {
                showAlert('Copy failed: ' + err.message);
            });
        }

        function clearConsole() {
            consoleInput.value = '';
            consoleOutput.textContent = '';
        }

        function monitorAction(action) {
            actionHistory.push({ action, timestamp: Date.now() });
            if (actionHistory.length > 100) actionHistory.shift();
            if (detectAnomaly(actionHistory)) {
                showAlert('Suspicious activity detected! Please slow down.');
            }
        }

        function detectAnomaly(history) {
            const recent = history.slice(-10);
            return recent.length === 10 && recent[9].timestamp - recent[0].timestamp < 5000; // 10 actions in 5 seconds
        }

        window.addEventListener('load', async () => {
            try {
                const initCode = generateCrypticCode();
                const initSerial = `HOLO-${String(1).padStart(6, '0')}-INIT`;
                currentValidationCode = await generateValidationCode(initSerial, initCode);
                if (currentValidationCode) {
                    generateImageFromSeed(initCode, initSerial);
                    consoleOutput.textContent = `${initSerial}\n${initCode}\n${currentValidationCode}`;
                    currentSerial = initSerial;
                    currentCode = initCode;
                }
            } catch (err) {
                showAlert('Initialization failed: ' + err.message);
            }
        });
    </script>
</body>
</html>
