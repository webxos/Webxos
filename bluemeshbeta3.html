<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Bluemesh 2025: Secure Bluetooth and HTTP mesh networking with P2P messaging, WebGL visualization, and diagnostics via FalseNode@webxos. Offline mode supported with limited functionality.">
  <meta name="keywords" content="Bluemesh, Bluetooth Mesh, HTTP Mesh, P2P Messaging, WebGL, WebAssembly, NodeSync, edge computing, secure networking">
  <meta name="author" content="WEBXOS Standardization">
  <meta name="robots" content="index, follow">
  <meta name="copyright" content="© 2025 WEBXOS Standardization">
  <title>Bluemesh 2025</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #000;
      color: #00ff00;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .console {
      flex-grow: 1;
      background: rgba(0, 0, 0, 0.8);
      text-shadow: 0 0 5px currentColor, 0 0 10px currentColor, 0 0 15px currentColor;
      overflow-y: auto;
      position: relative;
      font-size: 0.7em;
      line-height: 1.1;
      margin: 0 10px 5px 10px;
      padding: 5px;
      border: 1px solid currentColor;
    }
    .input-line {
      display: flex;
      margin-top: 10px;
      position: sticky;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1;
      padding: 5px;
    }
    .input-line input {
      background: transparent;
      border: 1px solid #00ff00;
      color: #00ff00;
      font-size: inherit;
      flex-grow: 1;
      padding: 2px;
      text-shadow: 0 0 3px currentColor;
    }
    .input-line input:focus {
      box-shadow: 0 0 5px #00ff00;
      outline: none;
    }
    .input-line input::placeholder {
      color: #00ff00;
      opacity: 0.7;
    }
    .button-container {
      display: flex;
      flex-wrap: wrap;
      font-size: 0.8em;
      padding: 3px;
    }
    button {
      background: transparent;
      border: 1px solid #00ff00;
      color: #00ff00;
      min-width: 120px;
      padding: 3px 6px;
      margin: 1px;
      cursor: pointer;
      text-shadow: 0 0 3px currentColor;
    }
    button:hover {
      background: rgba(255, 255, 255, 0.1);
      box-shadow: 0 0 5px currentColor;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    footer {
      text-align: center;
      font-size: 10px;
      height: 5px;
      text-shadow: 0 0 3px currentColor;
    }
    .popup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      max-width: 400px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid #00ff00;
      padding: 10px;
      z-index: 2;
    }
    .popup.active {
      display: block;
    }
    .diagnostic-section {
      margin-top: 10px;
      border-top: 1px dashed #00ff00;
    }
    .error {
      color: #ff0000;
      text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000;
    }
    .clickable-node {
      cursor: pointer;
      text-decoration: underline;
    }
    .clickable-node:hover {
      color: #00cc00;
      text-shadow: 0 0 5px #00cc00, 0 0 10px #00cc00;
    }
    @media (max-width: 600px) {
      .console { font-size: 0.6em; }
      .button-container { font-size: 0.7em; }
      button { padding: 2px 4px; }
      .input-line input { font-size: 0.6em; }
      .popup { width: 90%; }
      footer { font-size: 0.6em; }
    }
  </style>
</head>
<body>
  <div id="consoleOutput" class="console"></div>
  <div class="input-line">
    <span>&gt;</span>
    <input id="commandInput" type="text" placeholder="Enter command or message (e.g., user@webxos Hello!)">
  </div>
  <div class="button-container">
    <button id="executeButton">Execute</button>
    <button id="discoverButton">Discover</button>
    <button id="troubleshootButton">Troubleshoot</button>
  </div>
  <canvas id="webglCanvas" style="display: none;"></canvas>
  <div id="wizardPopup" class="popup">
    <h3>Bluemesh Setup</h3>
    <p>Enter your node ID (e.g., user@webxos):</p>
    <input id="nodeIdInput" type="text" placeholder="user@webxos">
    <button onclick="WizardManager.nextStep(1)">Next</button>
    <button onclick="WizardManager.skip()">Skip</button>
  </div>
  <div id="confirmPopup" class="popup">
    <h3>Confirm Merge</h3>
    <p id="confirmMessage"></p>
    <button onclick="BluetoothMesh.confirmMerge(true)">Confirm</button>
    <button onclick="BluetoothMesh.confirmMerge(false)">Cancel</button>
  </div>
  <footer>BLUEMESH v1.0.0 © 2025 WEBXOS Standardization, Tested: 09:59 AM EDT, July 13, 2025</footer>
  <script>
    // NodeSync Module
    const NodeSync = {
      nodeKeys: new Map(),
      XOR_VALUE: 0xFF,
      MAX_DATA_SIZE: 10 * 1024 * 1024, // 10MB
      generateNodeKey(nodeId) {
        if (!this.nodeKeys.has(nodeId)) {
          const key = Array(16).fill().map(() => String.fromCharCode(65 + Math.floor(Math.random() * 26))).join('');
          this.nodeKeys.set(nodeId, key);
        }
        return this.nodeKeys.get(nodeId);
      },
      getNodeKey(nodeId) {
        return this.nodeKeys.get(nodeId) || this.generateNodeKey(nodeId);
      },
      validateDataSize(data) {
        const size = new Blob([JSON.stringify(data)]).size;
        if (size > this.MAX_DATA_SIZE) throw new Error(`Data exceeds ${this.MAX_DATA_SIZE / (1024 * 1024)}MB limit`);
      },
      compressData(data, nodeId) {
        this.validateDataSize(data);
        const str = JSON.stringify(data);
        return this._pakoDeflate(str);
      },
      decompressData(compressed, nodeId) {
        const str = this._pakoInflate(compressed);
        const data = this.validateData(str);
        return data;
      },
      encryptData(data, nodeId) {
        const compressed = this.compressData(data, nodeId);
        const key = this.getNodeKey(nodeId);
        return this._aesEncrypt(compressed, key);
      },
      decryptData(encrypted, nodeId) {
        const key = this.getNodeKey(nodeId);
        const compressed = this._aesDecrypt(encrypted, key);
        return this.decompressData(compressed, nodeId);
      },
      encryptMessage(message, senderId, recipientId) {
        const data = { sender: senderId, message, timestamp: Date.now() };
        return this.encryptData(data, recipientId);
      },
      decryptMessage(encrypted, recipientId) {
        return this.decryptData(encrypted, recipientId);
      },
      generateSerial(nodeId) {
        return `WEBXOS-${Array(13).fill().map(() => String.fromCharCode(65 + Math.floor(Math.random() * 26))).join('')}`;
      },
      generateMessageSerial(nodeId) {
        return `WEBXOS-MSG-${Array(13).fill().map(() => String.fromCharCode(65 + Math.floor(Math.random() * 26))).join('')}`;
      },
      validateData(data) {
        try {
          return JSON.parse(data);
        } catch (e) {
          throw new Error('Invalid JSON data');
        }
      },
      retrieveData(serial, nodeId) {
        const encrypted = localStorage.getItem(serial);
        if (!encrypted) throw new Error('Data not found');
        return this.decryptData(encrypted, nodeId);
      },
      encryptWASM(data, nodeId) {
        return this.encryptData(data, nodeId); // Placeholder for WASM
      },
      validateCompressionConfig() {
        try {
          const testData = { test: 'data' };
          const compressed = this._pakoDeflate(JSON.stringify(testData));
          const decompressed = this._pakoInflate(compressed);
          return JSON.stringify(testData) === decompressed;
        } catch (e) {
          throw new Error('Compression configuration failed');
        }
      },
      _pakoDeflate(str) {
        return Array.from(str).map(c => String.fromCharCode(c.charCodeAt(0) ^ this.XOR_VALUE)).join('');
      },
      _pakoInflate(compressed) {
        return Array.from(compressed).map(c => String.fromCharCode(c.charCodeAt(0) ^ this.XOR_VALUE)).join('');
      },
      _aesEncrypt(data, key) {
        return Array.from(data).map((c, i) => String.fromCharCode(c.charCodeAt(0) ^ key.charCodeAt(i % key.length))).join('');
      },
      _aesDecrypt(encrypted, key) {
        return Array.from(encrypted).map((c, i) => String.fromCharCode(c.charCodeAt(0) ^ key.charCodeAt(i % key.length))).join('');
      }
    };

    // BluetoothMesh Module
    const BluetoothMesh = {
      nodeId: null,
      isOffline: false,
      connectedNodes: new Set(['FalseNode@webxos']),
      nodes: new Set(['FalseNode@webxos']),
      setNodeId(id) {
        if (!id.match(/^[a-zA-Z0-9]+@webxos$/)) throw new Error('Invalid node ID format');
        this.nodeId = id.replace(/[<>]/g, '');
      },
      async discover() {
        ConsoleManager.log('Discovering networks...');
        this.nodes = new Set(['FalseNode@webxos']);
        if (!this.isOffline) {
          const userNodes = this.getUserNodesFromMessages();
          userNodes.forEach(node => this.nodes.add(node));
          await this.receiveMessages();
        }
        this._renderNodes([...this.nodes]);
        WebGLViz.renderNodes([...this.nodes]);
      },
      async testNodeConnectivity(node, protocol) {
        if (protocol === 'bluetooth') {
          const details = await this.checkBluetoothDetails();
          return details.status === 'connected';
        } else {
          const httpDetails = await this.checkHttpConnectivity();
          return httpDetails.status === 'connected';
        }
      },
      async checkBluetoothDetails() {
        const details = { available: false, deviceType: 'unknown', status: 'disconnected', speed: 0, getDevicesSupported: false };
        if (!navigator.bluetooth) {
          ConsoleManager.logError('Bluetooth unavailable', 'Ensure Bluetooth is enabled or try a supported browser (e.g., Chrome Canary, Edge)');
          return details;
        }
        details.available = true;
        details.deviceType = /Mobi|Android|iPhone|iPad/.test(navigator.userAgent) ? 'mobile' : 'desktop';
        details.speed = details.deviceType === 'mobile' ? 1 : 3; // Mbps
        details.getDevicesSupported = typeof navigator.bluetooth.getDevices === 'function';
        try {
          if (details.getDevicesSupported) {
            const devices = await navigator.bluetooth.getDevices();
            details.status = devices.length > 0 ? 'connected' : 'disconnected';
          } else {
            await navigator.bluetooth.requestDevice({ acceptAllDevices: true });
            details.status = 'connected';
          }
        } catch (e) {
          if (details.getDevicesSupported) {
            ConsoleManager.logError('Bluetooth getDevices failed', 'Try Chrome Canary or Edge for getDevices support');
          }
          details.status = 'disconnected';
        }
        return details;
      },
      async checkHttpConnectivity() {
        const details = { available: true, status: 'disconnected', latency: 0 };
        for (let i = 0; i < 3; i++) {
          const start = performance.now();
          try {
            const response = await fetch('https://api.ipify.org?format=json', { signal: AbortSignal.timeout(5000) });
            if (!response.ok) throw new Error(`HTTP status ${response.status}`);
            details.status = 'connected';
            details.latency = performance.now() - start;
            return details;
          } catch (e) {
            details.status = 'disconnected';
            ConsoleManager.logError(`HTTP attempt ${i + 1} failed: ${e.message}`, 'Check WiFi, disable ad blockers, or use a VPN');
          }
        }
        return details;
      },
      async checkConnectivity() {
        const bluetoothDetails = await this.checkBluetoothDetails();
        if (bluetoothDetails.status === 'connected') {
          this.isOffline = false;
          ConsoleManager.log(`Bluetooth: ${bluetoothDetails.status}, Type: ${bluetoothDetails.deviceType}, Speed: ${bluetoothDetails.speed} Mbps, getDevices: ${bluetoothDetails.getDevicesSupported}`);
          document.getElementById('discoverButton').disabled = false;
          return;
        }
        const httpDetails = await this.checkHttpConnectivity();
        if (httpDetails.status === 'connected') {
          this.isOffline = false;
          ConsoleManager.log(`HTTP: ${httpDetails.status}, Latency: ${httpDetails.latency.toFixed(2)}ms`);
          document.getElementById('discoverButton').disabled = false;
          return;
        }
        this.isOffline = true;
        ConsoleManager.logError('No connectivity: Running in offline mode...', `Bluetooth: ${bluetoothDetails.status}, HTTP: ${httpDetails.status}, Retries: 3`);
        document.getElementById('discoverButton').disabled = true;
      },
      getUserNodesFromMessages() {
        const nodes = new Set();
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key.startsWith('WEBXOS-MSG-')) {
            try {
              const data = NodeSync.decryptMessage(localStorage.getItem(key), this.nodeId);
              if (data.sender !== this.nodeId) nodes.add(data.sender);
            } catch (e) {}
          }
        }
        return nodes;
      },
      sendMessage(recipientId, message) {
        if (!this.nodeId) throw new Error('Node ID not set');
        const serial = NodeSync.generateMessageSerial(this.nodeId);
        const encrypted = NodeSync.encryptMessage(message, this.nodeId, recipientId);
        localStorage.setItem(serial, encrypted);
        this.nodes.add(recipientId);
        this._renderNodes([...this.nodes]);
        ConsoleManager.log(`Sent to ${recipientId}: ${message}`);
      },
      async receiveMessages() {
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key.startsWith('WEBXOS-MSG-')) {
            try {
              const data = NodeSync.decryptMessage(localStorage.getItem(key), this.nodeId);
              if (data.recipient === this.nodeId) {
                ConsoleManager.log(`${data.sender}: ${data.message}`);
              }
            } catch (e) {}
          }
        }
      },
      toggleConnection(node, forceConnect = false) {
        if (node === 'FalseNode@webxos' && !this.connectedNodes.has(node)) {
          Troubleshooter.falseNodeTroubleshoot();
        }
        if (forceConnect || !this.connectedNodes.has(node)) {
          this.connectedNodes.add(node);
          ConsoleManager.log(`Connected to ${node}`);
        } else {
          this.connectedNodes.delete(node);
          ConsoleManager.log(`Disconnected from ${node}`);
        }
      },
      showConfirmation(node) {
        if (node === 'FalseNode@webxos') {
          ConsoleManager.logError('Cannot merge with FalseNode@webxos', 'Select a user node for merging');
          return;
        }
        document.getElementById('confirmMessage').textContent = `Merge with ${node}?`;
        document.getElementById('confirmPopup').classList.add('active');
      },
      confirmMerge(confirm) {
        document.getElementById('confirmPopup').classList.remove('active');
        if (confirm) {
          this.merge(document.getElementById('confirmMessage').textContent.split(' ')[2]);
        }
      },
      merge(node) {
        if (node === 'FalseNode@webxos') return;
        const serial = NodeSync.generateSerial(node);
        const data = { node, timestamp: Date.now() };
        localStorage.setItem(serial, NodeSync.encryptData(data, node));
        ConsoleManager.log(`Merged with ${node}, Serial: ${serial}`);
      },
      _renderNodes(nodes) {
        const diagnostic = ['FalseNode@webxos'];
        const discovered = nodes.filter(n => n !== 'FalseNode@webxos');
        let output = '';
        if (diagnostic.length) {
          output += '<div class="diagnostic-section">Diagnostic Nodes:<br>' + diagnostic.map(n => `<span class="clickable-node">${n}</span>`).join(', ') + '</div>';
        }
        if (discovered.length) {
          output += '<div class="diagnostic-section">Discovered Nodes:<br>' + discovered.map(n => `<span class="clickable-node">${n}</span>`).join(', ') + '</div>';
        }
        ConsoleManager.log(output);
      }
    };

    // WebGLViz Module
    const WebGLViz = {
      gl: null,
      program: null,
      init() {
        const canvas = document.getElementById('webglCanvas');
        this.gl = canvas.getContext('webgl');
        if (!this.gl) throw new Error('WebGL not supported');
        const vs = `
          attribute vec2 a_position;
          void main() {
            gl_Position = vec4(a_position, 0, 1);
            gl_PointSize = 10.0;
          }
        `;
        const fs = `
          precision mediump float;
          uniform vec4 u_color;
          void main() {
            gl_FragColor = u_color;
          }
        `;
        const vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);
        this.gl.shaderSource(vertexShader, vs);
        this.gl.compileShader(vertexShader);
        const fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        this.gl.shaderSource(fragmentShader, fs);
        this.gl.compileShader(fragmentShader);
        this.program = this.gl.createProgram();
        this.gl.attachShader(this.program, vertexShader);
        this.gl.attachShader(this.program, fragmentShader);
        this.gl.linkProgram(this.program);
        this.gl.useProgram(this.program);
      },
      validateRenderConfig(nodes) {
        if (!this.gl || !this.program) throw new Error('WebGL not initialized');
        if (!Array.isArray(nodes)) throw new Error('Invalid node array');
      },
      renderNodes(nodes) {
        this.validateRenderConfig(nodes);
        const maxNodes = window.innerWidth <= 600 || navigator.hardwareConcurrency < 4 ? 2 : 10;
        const renderNodes = nodes.slice(0, maxNodes);
        const canvas = document.getElementById('webglCanvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight * 0.5;
        this.gl.viewport(0, 0, canvas.width, canvas.height);
        this.gl.clearColor(0, 0, 0, 1);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        const positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);
        const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
        this.gl.enableVertexAttribArray(positionLocation);
        this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
        const colorLocation = this.gl.getUniformLocation(this.program, 'u_color');
        renderNodes.forEach((node, i) => {
          const x = (i % 5) * 0.4 - 0.8;
          const y = Math.floor(i / 5) * 0.4 - 0.8;
          this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([x, y]), this.gl.STATIC_DRAW);
          this.gl.uniform4f(colorLocation, node === 'FalseNode@webxos' ? 1 : 0, node === 'FalseNode@webxos' ? 0 : 1, 0, 1);
          this.gl.drawArrays(this.gl.POINTS, 0, 1);
        });
        canvas.style.display = 'block';
        setTimeout(() => canvas.style.display = 'none', 5000);
      }
    };

    // WizardManager Module
    const WizardManager = {
      async open() {
        document.getElementById('wizardPopup').classList.add('active');
        await this.testConnectivity();
      },
      async testConnectivity() {
        await BluetoothMesh.checkConnectivity();
        if (BluetoothMesh.isOffline) {
          ConsoleManager.logError('Offline mode: Limited functionality', 'Cached messaging and troubleshooting available');
        }
      },
      nextStep(step) {
        const nodeId = document.getElementById('nodeIdInput').value.trim();
        if (!nodeId.match(/^[a-zA-Z0-9]+@webxos$/)) {
          ConsoleManager.logError('Invalid node ID', 'Use format: user@webxos');
          return;
        }
        BluetoothMesh.setNodeId(nodeId);
        this.finalize(nodeId);
      },
      skip() {
        const nodeId = `guest${Math.random().toString(36).slice(2, 10)}@webxos`;
        BluetoothMesh.setNodeId(nodeId);
        this.finalize(nodeId);
      },
      finalize(nodeId) {
        document.getElementById('wizardPopup').classList.remove('active');
        ConsoleManager.log(`Node ID set: ${nodeId}`);
        ConsoleManager.log('Usage: Type commands (discover, troubleshoot, verbose) or messages (user@webxos Hello!) in console');
        ConsoleManager.log('Click nodes in console to connect/disconnect, use Troubleshoot button for diagnostics');
        if (BluetoothMesh.isOffline) {
          ConsoleManager.logError('Offline mode', 'Connect to Bluetooth or HTTP for full functionality');
        }
      }
    };

    // ConsoleManager Module
    const ConsoleManager = {
      verbose: false,
      awaitingTroubleshootResponse: false,
      log(message) {
        const div = document.createElement('div');
        div.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
        this._makeNodesClickable(div);
        document.getElementById('consoleOutput').appendChild(div);
        div.scrollIntoView();
      },
      logError(message, suggestion) {
        const div = document.createElement('div');
        div.className = 'error';
        div.innerHTML = `[${new Date().toLocaleTimeString()}] ERROR: ${message}${suggestion ? ` - ${suggestion}` : ''}`;
        this._makeNodesClickable(div);
        document.getElementById('consoleOutput').appendChild(div);
        div.scrollIntoView();
      },
      logVerbose(message) {
        if (this.verbose) this.log(message);
      },
      execute() {
        const input = document.getElementById('commandInput');
        const value = input.value.trim();
        input.value = '';
        if (!value) return;
        if (this.awaitingTroubleshootResponse) {
          this.handleTroubleshootResponse(value);
          return;
        }
        if (value === 'discover') {
          BluetoothMesh.discover();
        } else if (value === 'troubleshoot') {
          Troubleshooter.check();
        } else if (value === 'verbose') {
          this.verbose = !this.verbose;
          this.log(`Verbose mode: ${this.verbose ? 'ON' : 'OFF'}`);
        } else if (value.match(/^[a-zA-Z0-9]+@webxos\s+.+$/)) {
          const [recipient, ...messageParts] = value.split(' ');
          const message = messageParts.join(' ');
          try {
            BluetoothMesh.sendMessage(recipient, message);
          } catch (e) {
            Troubleshooter.checkError(e, 'Verify node ID and message format');
          }
        } else {
          ConsoleManager.logError('Invalid command or message', 'Use: discover, troubleshoot, verbose, or user@webxos message');
        }
        input.focus();
      },
      handleTroubleshootResponse(response) {
        if (response.toLowerCase() === 'y') {
          Troubleshooter.falseNodeTroubleshoot();
        } else {
          this.awaitingTroubleshootResponse = false;
          ConsoleManager.log('Troubleshooting ended');
        }
      },
      handleCommand(event) {
        if (event.key === 'Enter') this.execute();
      },
      _makeNodesClickable(element) {
        const regex = /[a-zA-Z0-9]+@webxos/g;
        element.innerHTML = element.innerHTML.replace(regex, match => `<span class="clickable-node">${match}</span>`);
        element.querySelectorAll('.clickable-node').forEach(node => {
          node.addEventListener('click', () => BluetoothMesh.toggleConnection(node.textContent));
        });
      }
    };

    // Troubleshooter Module
    const Troubleshooter = {
      errorCache: new Set(),
      async check() {
        if (!BluetoothMesh.connectedNodes.has('FalseNode@webxos')) {
          BluetoothMesh.toggleConnection('FalseNode@webxos', true);
        }
        await this.falseNodeTroubleshoot();
      },
      checkError(error, suggestion) {
        const errorKey = `${error.message}:${suggestion}`;
        if (this.errorCache.has(errorKey)) return;
        this.errorCache.add(errorKey);
        ConsoleManager.logError(error.message, suggestion);
        this.falseNodeTroubleshoot();
      },
      checkJavaScriptSyntax() {
        try {
          new Function('return true;')();
          return true;
        } catch (e) {
          this.checkError(e, 'JavaScript engine issue');
          return false;
        }
      },
      async checkConnectivity() {
        await BluetoothMesh.checkConnectivity();
        if (BluetoothMesh.isOffline) {
          this.checkError(new Error('No connectivity'), 'Check Bluetooth/HTTP settings');
        }
      },
      checkDOM() {
        const elements = ['consoleOutput', 'commandInput', 'executeButton', 'discoverButton', 'troubleshootButton', 'webglCanvas', 'wizardPopup', 'confirmPopup'];
        for (const id of elements) {
          if (!document.getElementById(id)) {
            this.checkError(new Error(`Missing DOM element: ${id}`), 'Check HTML structure');
            return false;
          }
        }
        return true;
      },
      checkStorage() {
        try {
          localStorage.setItem('test', 'test');
          localStorage.removeItem('test');
          return true;
        } catch (e) {
          this.checkError(e, 'Check browser storage permissions');
          return false;
        }
      },
      checkWebGL() {
        try {
          WebGLViz.init();
          return true;
        } catch (e) {
          this.checkError(e, 'Ensure WebGL is enabled');
          return false;
        }
      },
      checkWASM() {
        try {
          new WebAssembly.Module(new Uint8Array([0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00]));
          return true;
        } catch (e) {
          this.checkError(e, 'Ensure WebAssembly is enabled');
          return false;
        }
      },
      getMemoryUsage() {
        if (performance.memory) {
          const { usedJSHeapSize, totalJSHeapSize } = performance.memory;
          return `Memory: ${Math.round(usedJSHeapSize / (1024 * 1024))}MB / ${Math.round(totalJSHeapSize / (1024 * 1024))}MB`;
        }
        return 'Memory: Usage unavailable';
      },
      async falseNodeTroubleshoot() {
        this.checkJavaScriptSyntax();
        await this.checkConnectivity();
        this.checkDOM();
        this.checkStorage();
        this.checkWebGL();
        this.checkWASM();
        NodeSync.validateCompressionConfig();
        const bluetoothDetails = await BluetoothMesh.checkBluetoothDetails();
        const httpDetails = await BluetoothMesh.checkHttpConnectivity();
        ConsoleManager.log(`Diagnostics: ${this.getMemoryUsage()}, Bluetooth: ${bluetoothDetails.status}, Type: ${bluetoothDetails.deviceType}, Speed: ${bluetoothDetails.speed} Mbps, getDevices: ${bluetoothDetails.getDevicesSupported}, HTTP: ${httpDetails.status}, Latency: ${httpDetails.latency.toFixed(2)}ms`);
        ConsoleManager.log('Use format: user@webxos message for messaging, click nodes to connect/disconnect');
        if (!bluetoothDetails.getDevicesSupported) {
          ConsoleManager.logError('Bluetooth getDevices unsupported', 'Try Chrome Canary or Edge');
        }
        ConsoleManager.log('Do you need more help? (y/n)');
        ConsoleManager.awaitingTroubleshootResponse = true;
      }
    };

    // Service Worker and Cache
    if ('caches' in window) {
      caches.open('bluemesh-cache').then(cache => {
        cache.add('/').then(() => ConsoleManager.logVerbose('Cached / for offline use')).catch(e => ConsoleManager.logError('Cache failed', e.message));
      });
    }

    // Event Listeners
    window.addEventListener('load', () => {
      WizardManager.open();
      WebGLViz.init();
      BluetoothMesh.checkConnectivity();
    });
    document.getElementById('executeButton').addEventListener('click', () => ConsoleManager.execute());
    document.getElementById('discoverButton').addEventListener('click', () => BluetoothMesh.discover());
    document.getElementById('troubleshootButton').addEventListener('click', () => Troubleshooter.check());
    document.getElementById('commandInput').addEventListener('keydown', e => ConsoleManager.handleCommand(e));
  </script>
</body>
</html>
