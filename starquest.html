<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Starquest - WebXOS 2025</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    }
    body {
      background: #000;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #gameCanvas {
      flex: 1;
      width: 100%;
      touch-action: none;
      position: relative;
    }
    .start-screen, .end-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 50, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      z-index: 20;
      padding: 2vw;
    }
    .start-screen h1, .end-screen h1 {
      font-size: 5vw;
      margin-bottom: 2vw;
    }
    .start-screen p, .end-screen p {
      font-size: 2vw;
      margin-bottom: 1vw;
      max-width: 80%;
    }
    .start-screen button, .end-screen button {
      background: #4a90e2;
      border: none;
      padding: 1.5vw 3vw;
      color: white;
      border-radius: 10px;
      cursor: pointer;
      font-size: 2vw;
      margin: 1vw;
    }
    .start-screen button:hover, .end-screen button:hover {
      background: #357abd;
    }
    .auto-quest-btn.active {
      background: #ff4444;
    }
    .hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.4;
      z-index: 5;
    }
    .hud::before {
      content: '';
      position: absolute;
      top: 10%;
      left: 10%;
      right: 10%;
      bottom: 10%;
      border: 2px solid #4a90e2;
      border-radius: 20px;
    }
    .hud::after {
      content: '+';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #4a90e2;
      font-size: 3vw;
      transition: color 0.2s;
    }
    .hud.targeting::after {
      color: #00ff00;
      animation: pulse 0.5s infinite alternate;
    }
    @keyframes pulse {
      to { transform: translate(-50%, -50%) scale(1.2); }
    }
    .enemy-marker {
      position: absolute;
      width: 1.5vw;
      height: 1.5vw;
      border: 2px solid #ff0000;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 5;
      animation: markerPulse 0.8s infinite alternate;
    }
    @keyframes markerPulse {
      to { transform: translate(-50%, -50%) scale(1.3); }
    }
    .status-overlay {
      position: absolute;
      top: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.3);
      padding: 0.5vw 1vw;
      font-size: 1.5vw;
      color: #fff;
      z-index: 5;
      pointer-events: none;
    }
    .health-bar {
      display: inline-block;
      width: 10vw;
      height: 1vw;
      background: #333;
      border: 1px solid #fff;
      margin-left: 1vw;
    }
    .health-fill {
      height: 100%;
      background: linear-gradient(to right, green, red);
    }
    .console {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 25%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      z-index: 10;
      padding: 0.5vw;
    }
    .console-log {
      flex: 1;
      overflow-y: auto;
      font-size: 1.5vw;
      color: #fff;
      padding: 0.5vw;
    }
    .console-log p {
      margin: 0.2vw 0;
    }
    .console::-webkit-scrollbar {
      width: 0.8vw;
    }
    .console::-webkit-scrollbar-thumb {
      background: #4a90e2;
      border-radius: 0.4vw;
    }
    .mobile-controls {
      position: absolute;
      bottom: 25%;
      width: 100%;
      height: 30%;
      display: none;
      z-index: 15;
      pointer-events: none;
    }
    .joystick, .shoot-btn, .throttle-btn, .auto-quest-btn {
      position: absolute;
      background: rgba(74, 144, 226, 0.5);
      border-radius: 50%;
      pointer-events: auto;
    }
    .joystick {
      width: 20vw;
      height: 20vw;
      left: 5%;
      bottom: 10%;
    }
    .joystick-inner {
      width: 10vw;
      height: 10vw;
      background: #4a90e2;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .shoot-btn {
      width: 18vw;
      height: 18vw;
      right: 5%;
      bottom: 10%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 3vw;
      color: #fff;
    }
    .throttle-btn {
      width: 12vw;
      height: 12vw;
      right: 25%;
      bottom: 10%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2vw;
      color: #fff;
    }
    .auto-quest-btn {
      width: 12vw;
      height: 12vw;
      right: 40%;
      bottom: 10%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2vw;
      color: #fff;
    }
    .throttle-btn.active, .auto-quest-btn.active {
      background: #ff4444;
    }
    @media (max-width: 768px) {
      .start-screen h1, .end-screen h1 {
        font-size: 8vw;
      }
      .start-screen p, .end-screen p {
        font-size: 3.5vw;
      }
      .start-screen button, .end-screen button {
        font-size: 3.5vw;
        padding: 2vw 4vw;
      }
      .status-overlay {
        font-size: 2.5vw;
      }
      .console {
        height: 35%;
      }
      .console-log {
        font-size: 2.5vw;
      }
      .hud::after {
        font-size: 5vw;
      }
      .enemy-marker {
        width: 2.5vw;
        height: 2.5vw;
      }
      .health-bar {
        width: 20vw;
        height: 2vw;
      }
      .mobile-controls {
        display: flex;
      }
    }
  </style>
</head>
<body>
  <div id="gameCanvas">
    <div class="hud"></div>
    <div id="statusOverlay" class="status-overlay"></div>
    <div id="console" class="console">
      <div id="consoleLog" class="console-log"></div>
    </div>
    <div id="mobileControls" class="mobile-controls">
      <div id="joystick" class="joystick">
        <div id="joystickInner" class="joystick-inner"></div>
      </div>
      <div id="shootBtn" class="shoot-btn">Shoot</div>
      <div id="throttleBtn" class="throttle-btn">Boost</div>
      <div id="autoQuestBtn" class="auto-quest-btn">Auto</div>
    </div>
    <div id="startScreen" class="start-screen">
      <h1>Starquest</h1>
      <p>A WebXOS 2025 Production Â©</p>
      <p>Engage in epic dogfights with guided shots, complete missions, and explore vibrant planets.</p>
      <p><strong>Desktop Controls:</strong> Mouse to aim, W to boost, S to reverse, Ctrl to shoot (guided near enemies), Arrows for roll.</p>
      <p><strong>Mobile Controls:</strong> Joystick to aim, Boost for speed, Shoot for guided shots, Auto for AI play.</p>
      <p><strong>Missions:</strong> Console shows tasks like dogfights, collecting beacons, or escorting drones. Face bosses in missions 6 and 12!</p>
      <p>Complete 12 missions to earn a WebXOS serial key!</p>
      <button id="startBtn">Start Mission</button>
      <button id="autoQuestStartBtn">Auto Quest</button>
    </div>
    <div id="endScreen" class="end-screen" style="display: none;">
      <h1 id="endTitle">Mission Complete!</h1>
      <p id="endMessage"></p>
      <p id="stats"></p>
      <p id="serialKey"></p>
      <button id="restartBtn">Restart</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    window.onload = () => {
      // Scene setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 5000);
      const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 1);
      document.getElementById('gameCanvas').appendChild(renderer.domElement);

      camera.position.set(0, 0, 0);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
      scene.add( esophagusLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      // Player ship
      const playerGeometry = new THREE.BufferGeometry();
      const playerVertices = new Float32Array([
        0, 0, -20, -10, -5, 0, 10, -5, 0, 0, 5, 0
      ]);
      const playerIndices = [0, 1, 2, 0, 2, 3, 0, 3, 1];
      playerGeometry.setAttribute('position', new THREE.BufferAttribute(playerVertices, 3));
      playerGeometry.setIndex(playerIndices);
      playerGeometry.computeVertexNormals();
      const playerMaterial = new THREE.MeshStandardMaterial({
        color: 0x333333,
        emissive: 0x4a90e2,
        emissiveIntensity: 0.5,
        roughness: 0.4,
        metalness: 0.8
      });

      // Shared resources
      const materials = {
        enemyRed: new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 1.0, roughness: 0.5, metalness: 0.7 }),
        enemyYellow: new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1.0, roughness: 0.5, metalness: 0.7 }),
        boss: new THREE.MeshStandardMaterial({ color: 0x800080, emissive: 0x800080, emissiveIntensity: 1.0, roughness: 0.3, metalness: 0.9 }),
        planetYellow: new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.6, metalness: 0.2 }),
        drone: new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.5, metalness: 0.6 }),
        nodeGreen: new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x008800, roughness: 0.4 }),
        nodeBlue: new THREE.MeshStandardMaterial({ color: 0x0000ff, emissive: 0x000088, roughness: 0.4 }),
        beacon: new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0x880088, roughness: 0.4 }),
        projectile: new THREE.MeshStandardMaterial({ color: 0x4a90e2, emissive: 0x4a90e2, roughness: 0.4 }),
        enemyProjectile: new THREE.MeshStandardMaterial({ color: 0xff4444, emissive: 0xff4444, roughness: 0.4 }),
        line: new THREE.LineBasicMaterial({ color: 0x00ff00 }),
        particle: new THREE.PointsMaterial({ color: 0x4a90e2, size: 2, transparent: true, blending: THREE.AdditiveBlending }),
        enemyParticleRed: new THREE.PointsMaterial({ color: 0xff0000, size: 2, transparent: true, blending: THREE.AdditiveBlending }),
        enemyParticleYellow: new THREE.PointsMaterial({ color: 0xffff00, size: 2, transparent: true, blending: THREE.AdditiveBlending }),
        enemyParticleBoss: new THREE.PointsMaterial({ color: 0x800080, size: 2, transparent: true, blending: THREE.AdditiveBlending })
      };
      const geometries = {
        enemyRed: new THREE.BoxGeometry(18, 9, 27),
        enemyYellow: new THREE.SphereGeometry(15, 16, 16),
        boss: new THREE.BoxGeometry(60, 40, 80),
        planet: new THREE.SphereGeometry(50, 24, 24),
        drone: new THREE.BoxGeometry(5, 5, 5),
        node: new THREE.BoxGeometry(15, 15, 15),
        beacon: new THREE.SphereGeometry(8, 16, 16),
        projectile: new THREE.SphereGeometry(5, 8, 8),
        particle: new THREE.BufferGeometry()
      };
      geometries.particle.setAttribute('position', new THREE.BufferAttribute(new Float32Array(5 * 3), 3));

      // Game state
      let enemies = [];
      let planets = [];
      let drones = [];
      let nodes = [];
      let beacons = [];
      let nodeLines = [];
      let projectiles = [];
      let enemyProjectiles = [];
      let particleSystems = [];
      let rotation = { pitch: 0, yaw: 0 };
      let velocity = new THREE.Vector3(0, 0, 0);
      let throttle = 100;
      let isShooting = false;
      let lastShot = 0;
      let playerHealth = 100;
      let lastHit = 0;
      let lastEnemySpawn = 0;
      let gameState = 'start';
      let missions = [];
      let currentMission = null;
      let missionCount = 0;
      let stats = { enemiesDestroyed: 0, planetsDestroyed: 0, beaconsCollected: 0, missionsCompleted: 0 };
      let lastTime = performance.now();
      let enemyMarkers = [];
      let autoQuestActive = false;
      let reticle = { x: 0, y: 0 };
      let lockOnTarget = null;
      let lockOnTime = 0;

      // UI elements
      const statusOverlay = document.getElementById('statusOverlay');
      const consoleLog = document.getElementById('consoleLog');
      const startScreen = document.getElementById('startScreen');
      const endScreen = document.getElementById('endScreen');
      const startBtn = document.getElementById('startBtn');
      const autoQuestStartBtn = document.getElementById('autoQuestStartBtn');
      const restartBtn = document.getElementById('restartBtn');
      const joystick = document.getElementById('joystick');
      const joystickInner = document.getElementById('joystickInner');
      const shootBtn = document.getElementById('shootBtn');
      const throttleBtn = document.getElementById('throttleBtn');
      const autoQuestBtn = document.getElementById('autoQuestBtn');
      const hud = document.querySelector('.hud');

      // Console logging
      function addConsoleMessage(message) {
        const timestamp = new Date().toLocaleTimeString();
        const p = document.createElement('p');
        p.textContent = `[${timestamp}] ${message}`;
        consoleLog.appendChild(p);
        consoleLog.scrollTop = consoleLog.scrollHeight;
      }

      // Particle system
      function createParticleSystem(position, material) {
        const system = new THREE.Points(geometries.particle.clone(), material);
        system.position.copy(position);
        system.userData = { age: 0, maxAge: 1, velocity: new THREE.Vector3() };
        scene.add(system);
        particleSystems.push(system);
        return system;
      }

      // Mission generation
      function generateMission() {
        const isBossMission = missionCount === 5 || missionCount === 11;
        const types = [
          { type: 'dogfight', target: isBossMission ? 'boss ship' : 'enemy ships', count: isBossMission ? 1 : Math.floor(Math.random() * 5) + 6, progress: 0, bonus: Math.random() > 0.5 ? { type: 'collectBeacons', target: 'beacons', count: 2, progress: 0 } : null },
          { type: 'destroyEnemies', target: 'red enemies', count: Math.floor(Math.random() * 6) + 5, progress: 0, bonus: null },
          { type: 'destroyEnemies', target: 'yellow enemies', count: Math.floor(Math.random() * 6) + 5, progress: 0, bonus: null },
          { type: 'destroyPlanets', target: 'yellow planets', count: Math.floor(Math.random() * 3) + 2, progress: 0, bonus: Math.random() > 0.7 ? { type: 'visitNode', target: 'blue node', count: 1, progress: 0 } : null },
          { type: 'visitNode', target: 'green node', count: 1, progress: 0, nodeIndex: nodes.length, bonus: null },
          { type: 'escortDrone', target: 'drone', count: 1, progress: 0, drone: null, destination: null, bonus: null },
          { type: 'collectBeacons', target: 'beacons', count: Math.floor(Math.random() * 3) + 2, progress: 0, bonus: null }
        ];
        const mission = types[Math.floor(Math.random() * types.length)];
        missions.push(mission);
        let msg = `New mission: ${mission.type === 'dogfight' ? 'Engage' : mission.type === 'visitNode' ? 'Fly to' : mission.type === 'escortDrone' ? 'Escort' : mission.type === 'collectBeacons' ? 'Collect' : 'Destroy'} ${mission.count} ${mission.target}${isBossMission ? ' (Boss Fight)' : ''}.`;
        if (mission.bonus) {
          msg += ` Bonus: ${mission.bonus.type === 'visitNode' ? 'Fly to' : 'Collect'} ${mission.bonus.count} ${mission.bonus.target}.`;
        }
        addConsoleMessage(msg);
        spawnMissionEntities(mission);
        return mission;
      }

      function spawnMissionEntities(mission) {
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        if (mission.type === 'dogfight' || mission.type === 'destroyEnemies') {
          const isBoss = mission.target === 'boss ship';
          const color = isBoss ? 'boss' : mission.type === 'dogfight' ? (Math.random() > 0.5 ? 'enemyRed' : 'enemyYellow') : mission.target.includes('red') ? 'enemyRed' : 'enemyYellow';
          const geometry = isBoss ? geometries.boss : color === 'enemyRed' ? geometries.enemyRed : geometries.enemyYellow;
          const particleMaterial = isBoss ? materials.enemyParticleBoss : color === 'enemyRed' ? materials.enemyParticleRed : materials.enemyParticleYellow;
          for (let i = 0; i < mission.count; i++) {
            const angle = (Math.random() - 0.5) * Math.PI / 4;
            const offset = forward.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
            const enemy = new THREE.Mesh(geometry, materials[color]);
            enemy.position.copy(camera.position).add(offset.multiplyScalar(400 + Math.random() * 200));
            enemy.userData = {
              type: mission.target,
              velocity: new THREE.Vector3((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15),
              state: 'pursue',
              lastShot: 0,
              speed: isBoss ? 8 : 10 + Math.random() * 10,
              aggression: isBoss ? 1 : 0.5 + Math.random() * 0.5,
              health: isBoss ? 10 : 1
            };
            enemy.visible = true;
            scene.add(enemy);
            enemies.push(enemy);
            createParticleSystem(enemy.position, particleMaterial);
            addConsoleMessage(`${isBoss ? 'Boss' : color === 'enemyRed' ? 'Red enemy' : 'Yellow enemy'} spawned at ${enemy.position.toArray().map(n => n.toFixed(0)).join(', ')}`);
            if (isBoss) {
              for (let j = 0; j < 3; j++) {
                const drone = new THREE.Mesh(geometries.drone, materials.drone);
                drone.position.copy(enemy.position).add(new THREE.Vector3(
                  (Math.random() - 0.5) * 50,
                  (Math.random() - 0.5) * 50,
                  (Math.random() - 0.5) * 50
                ));
                drone.userData = { type: 'drone', boss: enemy, velocity: new THREE.Vector3((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5) };
                drone.visible = true;
                scene.add(drone);
                drones.push(drone);
              }
            }
          }
        } else if (mission.type === 'destroyPlanets') {
          for (let i = 0; i < mission.count; i++) {
            const planet = new THREE.Mesh(geometries.planet, materials.planetYellow);
            planet.position.copy(camera.position).add(forward.multiplyScalar(1200 + Math.random() * 800)).add(new THREE.Vector3(
              (Math.random() - 0.5) * 500,
              (Math.random() - 0.5) * 500,
              (Math.random() - 0.5) * 500
            ));
            planet.userData = { type: 'yellow planet', health: 3 };
            planet.visible = true;
            scene.add(planet);
            planets.push(planet);
            for (let j = 0; j < 3; j++) {
              const drone = new THREE.Mesh(geometries.drone, materials.drone);
              drone.position.copy(planet.position).add(new THREE.Vector3(
                (Math.random() - 0.5) * 100,
                (Math.random() - 0.5) * 100,
                (Math.random() - 0.5) * 100
              ));
              drone.userData = { type: 'drone', planet: planet, velocity: new THREE.Vector3((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5) };
              drone.visible = true;
              scene.add(drone);
              drones.push(drone);
            }
          }
        } else if (mission.type === 'visitNode') {
          const node = new THREE.Mesh(geometries.node, materials.nodeGreen);
          node.position.copy(camera.position).add(forward.multiplyScalar(1500 + Math.random() * 500)).add(new THREE.Vector3(
            (Math.random() - 0.5) * 300,
            (Math.random() - 0.5) * 300,
            (Math.random() - 0.5) * 300
          ));
          node.userData = { type: 'green node' };
          node.visible = true;
          scene.add(node);
          nodes.push(node);
          if (nodes.length > 1) {
            const geometry = new THREE.BufferGeometry().setFromPoints([nodes[nodes.length - 2].position, node.position]);
            const line = new THREE.Line(geometry, materials.line);
            scene.add(line);
            nodeLines.push(line);
          }
        } else if (mission.type === 'escortDrone') {
          const drone = new THREE.Mesh(geometries.drone, materials.drone);
          drone.position.copy(camera.position).add(forward.multiplyScalar(200)).add(new THREE.Vector3(
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 50
          ));
          const destination = new THREE.Mesh(geometries.node, materials.nodeGreen);
          destination.position.copy(camera.position).add(forward.multiplyScalar(2000)).add(new THREE.Vector3(
            (Math.random() - 0.5) * 400,
            (Math.random() - 0.5) * 400,
            (Math.random() - 0.5) * 400
          ));
          drone.userData = { type: 'escort drone', destination: destination.position, velocity: new THREE.Vector3(0, 0, 0) };
          destination.userData = { type: 'destination' };
          drone.visible = true;
          destination.visible = true;
          scene.add(drone);
          scene.add(destination);
          drones.push(drone);
          nodes.push(destination);
          mission.drone = drone;
          mission.destination = destination;
        } else if (mission.type === 'collectBeacons') {
          for (let i = 0; i < mission.count; i++) {
            const beacon = new THREE.Mesh(geometries.beacon, materials.beacon);
            beacon.position.copy(camera.position).add(forward.multiplyScalar(1000 + Math.random() * 1000)).add(new THREE.Vector3(
              (Math.random() - 0.5) * 300,
              (Math.random() - 0.5) * 300,
              (Math.random() - 0.5) * 300
            ));
            beacon.userData = { type: 'beacon' };
            beacon.visible = true;
            scene.add(beacon);
            beacons.push(beacon);
          }
        }
        if (mission.bonus) {
          if (mission.bonus.type === 'visitNode') {
            const node = new THREE.Mesh(geometries.node, materials.nodeBlue);
            node.position.copy(camera.position).add(forward.multiplyScalar(1200 + Math.random() * 600)).add(new THREE.Vector3(
              (Math.random() - 0.5) * 400,
              (Math.random() - 0.5) * 400,
              (Math.random() - 0.5) * 400
            ));
            node.userData = { type: 'blue node' };
            node.visible = true;
            scene.add(node);
            nodes.push(node);
            mission.bonus.nodeIndex = nodes.length - 1;
          } else if (mission.bonus.type === 'collectBeacons') {
            for (let i = 0; i < mission.bonus.count; i++) {
              const beacon = new THREE.Mesh(geometries.beacon, materials.beacon);
              beacon.position.copy(camera.position).add(forward.multiplyScalar(1000 + Math.random() * 1000)).add(new THREE.Vector3(
                (Math.random() - 0.5) * 300,
                (Math.random() - 0.5) * 300,
                (Math.random() - 0.5) * 300
              ));
              beacon.userData = { type: 'beacon' };
              beacon.visible = true;
              scene.add(beacon);
              beacons.push(beacon);
            }
          }
        }
      }

      function checkMissionProgress() {
        if (!currentMission) return;
        let msg = `Mission progress: ${currentMission.progress}/${currentMission.count} ${currentMission.target}`;
        if (currentMission.type === 'dogfight' || currentMission.type === 'destroyEnemies' || currentMission.type === 'destroyPlanets' || currentMission.type === 'collectBeacons') {
          msg += currentMission.type === 'collectBeacons' ? ' collected.' : ' destroyed.';
          addConsoleMessage(msg);
          if (currentMission.bonus) {
            addConsoleMessage(`Bonus progress: ${currentMission.bonus.progress}/${currentMission.bonus.count} ${currentMission.bonus.target} ${currentMission.bonus.type === 'visitNode' ? 'reached' : 'collected'}.`);
          }
          if (currentMission.progress >= currentMission.count) {
            missionComplete();
          }
        } else if (currentMission.type === 'visitNode' && currentMission.progress >= currentMission.count) {
          addConsoleMessage(msg + ' reached.');
          missionComplete();
        } else if (currentMission.type === 'escortDrone' && currentMission.drone && currentMission.drone.position.distanceTo(currentMission.destination.position) < 50) {
          currentMission.progress++;
          addConsoleMessage(msg + ' escorted.');
          missionComplete();
        }
      }

      function missionComplete() {
        stats.missionsCompleted++;
        addConsoleMessage(`Mission complete! ${currentMission.count} ${currentMission.target} ${currentMission.type === 'visitNode' ? 'reached' : currentMission.type === 'escortDrone' ? 'escorted' : currentMission.type === 'collectBeacons' ? 'collected' : 'destroyed'}.`);
        missions.shift();
        currentMission = null;
        missionCount++;
        if (missionCount >= 12) {
          endGame(true);
        } else {
          setTimeout(() => {
            currentMission = generateMission();
          }, 2000);
        }
      }

      // WebXOS serial key
      function generateSerialKey() {
        const data = {
          game: 'Starquest',
          missionsCompleted: stats.missionsCompleted,
          enemiesDestroyed: stats.enemiesDestroyed,
          planetsDestroyed: stats.planetsDestroyed,
          beaconsCollected: stats.beaconsCollected,
          timestamp: Date.now()
        };
        const json = JSON.stringify(data);
        let encoded = btoa(json);
        let checksum = 0;
        for (let i = 0; i < encoded.length; i++) checksum += encoded.charCodeAt(i);
        checksum = checksum % 100;
        return `WXOS-STARQUEST-${encoded}-${checksum}`;
      }

      function endGame(success) {
        gameState = 'end';
        endScreen.style.display = 'flex';
        document.getElementById('endTitle').textContent = success ? 'Mission Complete!' : 'Mission Failed!';
        document.getElementById('endMessage').textContent = success ? 'Congratulations, pilot! Youâve mastered Starquest.' : 'Your ship was destroyed. Try again!';
        document.getElementById('stats').textContent = `Enemies Destroyed: ${stats.enemiesDestroyed}, Planets Destroyed: ${stats.planetsDestroyed}, Beacons Collected: ${stats.beaconsCollected}, Missions Completed: ${stats.missionsCompleted}`;
        if (success) {
          const key = generateSerialKey();
          document.getElementById('serialKey').textContent = `WebXOS Serial Key: ${key} (Use in WebXOS Decoder)`;
        }
      }

      // Enemy AI
      function updateEnemyAI(enemy, deltaTime) {
        const toPlayer = camera.position.clone().sub(enemy.position);
        const distance = toPlayer.length();
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        const enemyForward = toPlayer.clone().normalize();
        const dot = forward.dot(enemyForward);
        const isTargeted = dot > Math.cos(5 * Math.PI / 180);
        const now = performance.now();

        if (enemy.userData.state === 'pursue' && distance < (enemy.userData.health > 1 ? 500 : 300) && now - enemy.userData.lastShot > (enemy.userData.health > 1 ? 500 : 1000)) {
          enemy.userData.state = 'attack';
        } else if ((isTargeted || distance < 100) && Math.random() > 0.3) {
          enemy.userData.state = 'evade';
        } else if (distance > (enemy.userData.health > 1 ? 600 : 400) || (enemy.userData.state === 'evade' && Math.random() > 0.5)) {
          enemy.userData.state = 'pursue';
        }

        if (enemy.userData.state === 'pursue') {
          const targetPos = camera.position.clone();
          const direction = targetPos.sub(enemy.position).normalize();
          enemy.userData.velocity.lerp(direction.multiplyScalar(enemy.userData.speed), 0.1);
        } else if (enemy.userData.state === 'attack') {
          const direction = toPlayer.normalize();
          enemy.userData.velocity.lerp(direction.multiplyScalar(enemy.userData.speed * 0.7), 0.1);
          if (now - enemy.userData.lastShot > (enemy.userData.health > 1 ? 500 : 1000)) {
            const projectile = new THREE.Mesh(geometries.projectile, materials.enemyProjectile);
            projectile.position.copy(enemy.position).add(direction.multiplyScalar(15));
            projectile.userData = { velocity: direction.multiplyScalar(enemy.userData.health > 1 ? 250 : 200), source: enemy };
            projectile.visible = true;
            scene.add(projectile);
            enemyProjectiles.push(projectile);
            enemy.userData.lastShot = now;
          }
        } else if (enemy.userData.state === 'evade') {
          const side = new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2).normalize();
          enemy.userData.velocity.lerp(side.multiplyScalar(enemy.userData.speed * 1.5), 0.2);
        }

        enemy.position.add(enemy.userData.velocity.clone().multiplyScalar(deltaTime));
        if (enemy.userData.health > 1) {
          enemy.rotation.y += deltaTime * 0.5;
        }
        enemy.visible = distance < 1000;
      }

      // Auto Quest AI
      function updateAutoQuest(deltaTime, now) {
        if (!currentMission) return;
        let targetPos = null;
        let shoot = false;
        let priorityTarget = null;

        enemies.forEach(enemy => {
          const dist = enemy.position.distanceTo(camera.position);
          if (dist < 500) {
            const toEnemy = enemy.position.clone().sub(camera.position).normalize();
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const dot = forward.dot(toEnemy);
            if (dot > Math.cos(30 * Math.PI / 180)) {
              if (!priorityTarget || (enemy.userData.health > 1 && priorityTarget.userData.health === 1) || (enemy.material === materials.enemyYellow && priorityTarget.material === materials.enemyRed)) {
                priorityTarget = enemy;
              }
            }
          }
        });

        if (currentMission.type === 'dogfight' || currentMission.type === 'destroyEnemies') {
          if (priorityTarget) {
            targetPos = priorityTarget.position.clone();
            const dist = camera.position.distanceTo(targetPos);
            if (dist < 200 && now - lastShot > 200) {
              shoot = true;
            }
          } else {
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            targetPos = camera.position.clone().add(forward.multiplyScalar(1000));
          }
        } else if (currentMission.type === 'destroyPlanets') {
          let closestPlanet = null;
          let minDist = Infinity;
          planets.forEach(planet => {
            const dist = camera.position.distanceTo(planet.position);
            if (dist < minDist) {
              minDist = dist;
              closestPlanet = planet;
            }
          });
          if (closestPlanet) {
            targetPos = closestPlanet.position.clone();
            if (minDist < 200 && now - lastShot > 200) {
              shoot = true;
            }
          }
        } else if (currentMission.type === 'visitNode') {
          const node = nodes[currentMission.nodeIndex];
          targetPos = node.position.clone();
        } else if (currentMission.type === 'escortDrone') {
          targetPos = currentMission.drone.position.clone();
        } else if (currentMission.type === 'collectBeacons') {
          let closestBeacon = null;
          let minDist = Infinity;
          beacons.forEach(beacon => {
            const dist = camera.position.distanceTo(beacon.position);
            if (dist < minDist) {
              minDist = dist;
              closestBeacon = beacon;
            }
          });
          if (closestBeacon) {
            targetPos = closestBeacon.position.clone();
          }
        }

        if (currentMission.bonus && currentMission.bonus.progress < currentMission.bonus.count) {
          if (currentMission.bonus.type === 'visitNode') {
            const node = nodes[currentMission.bonus.nodeIndex];
            if (!priorityTarget && camera.position.distanceTo(node.position) < 500) {
              targetPos = node.position.clone();
            }
          } else if (currentMission.bonus.type === 'collectBeacons') {
            let closestBeacon = null;
            let minDist = Infinity;
            beacons.forEach(beacon => {
              const dist = camera.position.distanceTo(beacon.position);
              if (dist < minDist) {
                minDist = dist;
                closestBeacon = beacon;
              }
            });
            if (closestBeacon && !priorityTarget) {
              targetPos = closestBeacon.position.clone();
            }
          }
        }

        if (playerHealth < 80 && !priorityTarget) {
          let closestBeacon = null;
          let minDist = Infinity;
          beacons.forEach(beacon => {
            const dist = camera.position.distanceTo(beacon.position);
            if (dist < minDist) {
              minDist = dist;
              closestBeacon = beacon;
            }
          });
          if (closestBeacon && minDist < 500) {
            targetPos = closestBeacon.position.clone();
          }
        }

        if (targetPos) {
          const toTarget = targetPos.sub(camera.position);
          const dist = toTarget.length();
          const yaw = Math.atan2(toTarget.x, toTarget.z);
          const pitch = Math.asin(toTarget.y / dist);
          rotation.yaw = yaw;
          rotation.pitch = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, pitch));
          throttle = priorityTarget ? 200 : 100;
        }

        let dodgeDir = null;
        enemyProjectiles.forEach(proj => {
          const toProj = proj.position.clone().sub(camera.position);
          const dist = toProj.length();
          if (dist < 100) {
            const projVel = proj.userData.velocity.clone();
            const timeToHit = dist / projVel.length();
            if (timeToHit < 0.5) {
              dodgeDir = toProj.cross(projVel).normalize();
            }
          }
        });
        if (dodgeDir) {
          rotation.yaw += dodgeDir.x * 0.2;
          rotation.pitch += dodgeDir.y * 0.2;
        }

        if (shoot && now - lastShot > 200) {
          isShooting = true;
        }
      }

      // Controls
      const keys = { ArrowLeft: false, ArrowRight: false, w: false, s: false, Control: false };
      window.addEventListener('keydown', e => {
        if (e.key === 'Control') keys.Control = true;
        if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = true;
        e.preventDefault();
      });
      window.addEventListener('keyup', e => {
        if (e.key === 'Control') keys.Control = false;
        if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = false;
      });

      let isDragging = false;
      let previousMouse = { x: 0, y: 0 };
      renderer.domElement.addEventListener('mousedown', e => {
        if (gameState !== 'playing' || autoQuestActive) return;
        isDragging = true;
        previousMouse = { x: e.clientX, y: e.clientY };
      });
      renderer.domElement.addEventListener('mousemove', e => {
        if (isDragging && gameState === 'playing' && !autoQuestActive) {
          const deltaX = (e.clientX - window.innerWidth / 2) / window.innerWidth;
          const deltaY = (e.clientY - window.innerHeight / 2) / window.innerHeight;
          reticle.x = deltaX * 2;
          reticle.y = -deltaY * 2;
          reticle.x = Math.max(-0.8, Math.min(0.8, reticle.x));
          reticle.y = Math.max(-0.8, Math.min(0.8, reticle.y));
        }
      });
      renderer.domElement.addEventListener('mouseup', () => {
        isDragging = false;
      });

      let joystickActive = false;
      joystick.addEventListener('touchstart', e => {
        if (gameState !== 'playing' || autoQuestActive) return;
        e.preventDefault();
        joystickActive = true;
      });
      joystick.addEventListener('touchmove', e => {
        if (!joystickActive || gameState !== 'playing' || autoQuestActive) return;
        e.preventDefault();
        const touch = e.touches[0];
        const rect = joystick.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const deltaX = touch.clientX - centerX;
        const deltaY = touch.clientY - centerY;
        const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), rect.width / 4);
        const angle = Math.atan2(deltaY, deltaX);
        joystickInner.style.transform = `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`;
        reticle.x = (deltaX / (rect.width / 2)) * 0.8;
        reticle.y = (-deltaY / (rect.height / 2)) * 0.8;
        reticle.x = Math.max(-0.8, Math.min(0.8, reticle.x));
        reticle.y = Math.max(-0.8, Math.min(0.8, reticle.y));
      });
      joystick.addEventListener('touchend', () => {
        joystickActive = false;
        joystickInner.style.transform = 'translate(-50%, -50%)';
        reticle.x = 0;
        reticle.y = 0;
      });
      shootBtn.addEventListener('touchstart', e => {
        if (gameState !== 'playing' || autoQuestActive) return;
        e.preventDefault();
        isShooting = true;
      });
      shootBtn.addEventListener('touchend', () => {
        isShooting = false;
      });
      throttleBtn.addEventListener('touchstart', e => {
        if (gameState !== 'playing' || autoQuestActive) return;
        e.preventDefault();
        throttle = throttle === 100 ? 200 : 100;
        throttleBtn.classList.toggle('active', throttle === 200);
      });
      autoQuestBtn.addEventListener('touchstart', e => {
        if (gameState !== 'playing') return;
        e.preventDefault();
        autoQuestActive = !autoQuestActive;
        autoQuestBtn.classList.toggle('active', autoQuestActive);
        addConsoleMessage(autoQuestActive ? 'Auto Quest activated.' : 'Auto Quest deactivated.');
      });

      // Start and Auto Quest
      startBtn.addEventListener('click', () => {
        gameState = 'playing';
        startScreen.style.display = 'none';
        addConsoleMessage('Starquest initialized. Prepare for first mission.');
        currentMission = generateMission();
      });
      autoQuestStartBtn.addEventListener('click', () => {
        gameState = 'playing';
        startScreen.style.display = 'none';
        autoQuestActive = true;
        autoQuestBtn.classList.add('active');
        addConsoleMessage('Auto Quest initialized. AI taking control.');
        currentMission = generateMission();
      });
      restartBtn.addEventListener('click', () => {
        location.reload();
      });

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        if (gameState !== 'playing') {
          renderer.render(scene, camera);
          return;
        }

        const now = performance.now();
        const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
        lastTime = now;

        // Fallback enemy spawn
        if (enemies.length === 0 && now - lastEnemySpawn > 5000) {
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          for (let i = 0; i < 3; i++) {
            const angle = (Math.random() - 0.5) * Math.PI / 4;
            const offset = forward.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
            const enemy = new THREE.Mesh(geometries.enemyRed, materials.enemyRed);
            enemy.position.copy(camera.position).add(offset.multiplyScalar(400 + Math.random() * 200));
            enemy.userData = {
              type: 'enemy ships',
              velocity: new THREE.Vector3((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15),
              state: 'pursue',
              lastShot: 0,
              speed: 10 + Math.random() * 10,
              aggression: 0.5 + Math.random() * 0.5,
              health: 1
            };
            enemy.visible = true;
            scene.add(enemy);
            enemies.push(enemy);
            createParticleSystem(enemy.position, materials.enemyParticleRed);
            addConsoleMessage(`Fallback: Red enemy spawned at ${enemy.position.toArray().map(n => n.toFixed(0)).join(', ')}`);
          }
          lastEnemySpawn = now;
        }

        // Auto Quest
        if (autoQuestActive) {
          updateAutoQuest(deltaTime, now);
        }

        // Update rotation
        if (!autoQuestActive) {
          rotation.yaw = reticle.x * Math.PI / 4;
          rotation.pitch = reticle.y * Math.PI / 4;
          if (keys.ArrowLeft) rotation.roll = Math.min(rotation.roll + 0.1, Math.PI / 4);
          if (keys.ArrowRight) rotation.roll = Math.max(rotation.roll - 0.1, -Math.PI / 4);
          if (!keys.ArrowLeft && !keys.ArrowRight) rotation.roll *= 0.9;
        }

        camera.quaternion.setFromEuler(new THREE.Euler(rotation.pitch, rotation.yaw, rotation.roll || 0, 'YXZ'));

        // Update velocity
        if (!autoQuestActive) {
          throttle = keys.w ? 200 : keys.s ? 50 : 100;
        }
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        velocity.copy(forward.multiplyScalar(throttle));
        camera.position.add(velocity.clone().multiplyScalar(deltaTime));

        // Health regeneration
        if (now - lastHit > 2000 && !autoQuestActive) {
          playerHealth = Math.min(playerHealth + 0.5 * deltaTime, 100);
        }
        if (playerHealth <= 0) {
          endGame(false);
        }

        // Shooting with guidance
        let targetingEnemy = false;
        if ((keys.Control || isShooting) && now - lastShot > 200) {
          const projectile = new THREE.Mesh(geometries.projectile, materials.projectile);
          projectile.position.copy(camera.position).add(forward.multiplyScalar(20));
          let target = null;
          let minDist = Infinity;
          enemies.forEach(enemy => {
            const toEnemy = enemy.position.clone().sub(camera.position);
            const dist = toEnemy.length();
            const angle = forward.angleTo(toEnemy.normalize());
            if (angle < 30 * Math.PI / 180 && dist < minDist) {
              minDist = dist;
              target = enemy;
            }
          });
          projectile.userData = {
            velocity: forward.multiplyScalar(300),
            target: target,
            seekTime: 0,
            maxSeekTime: 2
          };
          if (target) {
            targetingEnemy = true;
            lockOnTarget = target;
            lockOnTime = now;
            createParticleSystem(projectile.position, materials.particle);
          }
          projectile.visible = true;
          scene.add(projectile);
          projectiles.push(projectile);
          lastShot = now;
        }
        hud.classList.toggle('targeting', targetingEnemy);

        // Lock-on assist
        if (lockOnTarget && now - lockOnTime < 500 && scene.children.includes(lockOnTarget) && !autoQuestActive) {
          const toTarget = lockOnTarget.position.clone().sub(camera.position);
          const dist = toTarget.length();
          const yaw = Math.atan2(toTarget.x, toTarget.z);
          const pitch = Math.asin(toTarget.y / dist);
          rotation.yaw = yaw * 0.5 + rotation.yaw * 0.5;
          rotation.pitch = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, pitch * 0.5 + rotation.pitch * 0.5));
        } else {
          lockOnTarget = null;
        }

        // Update entities
        enemies.forEach(enemy => {
          updateEnemyAI(enemy, deltaTime);
          const particleMaterial = enemy.userData.health > 1 ? materials.enemyParticleBoss : enemy.material === materials.enemyRed ? materials.enemyParticleRed : materials.enemyParticleYellow;
          createParticleSystem(enemy.position, particleMaterial);
        });

        planets.forEach(planet => {
          planet.visible = camera.position.distanceTo(planet.position) < 1000;
        });

        drones.forEach(drone => {
          if (drone.userData.planet && scene.children.includes(drone.userData.planet)) {
            const toPlanet = drone.userData.planet.position.clone().sub(drone.position);
            drone.userData.velocity.lerp(toPlanet.normalize().multiplyScalar(5), 0.1);
          } else if (drone.userData.boss && scene.children.includes(drone.userData.boss)) {
            const toBoss = drone.userData.boss.position.clone().sub(drone.position);
            drone.userData.velocity.lerp(toBoss.normalize().multiplyScalar(5), 0.1);
          } else if (drone.userData.type === 'escort drone') {
            const toDest = drone.userData.destination.clone().sub(drone.position);
            drone.userData.velocity.lerp(toDest.normalize().multiplyScalar(50), 0.1);
          }
          drone.position.add(drone.userData.velocity.clone().multiplyScalar(deltaTime));
          drone.visible = camera.position.distanceTo(drone.position) < 1000;
        });

        nodes.forEach((node, i) => {
          node.visible = camera.position.distanceTo(node.position) < 1000;
          if (currentMission && currentMission.type === 'visitNode' && currentMission.nodeIndex === i) {
            if (camera.position.distanceTo(node.position) < 50) {
              currentMission.progress++;
              checkMissionProgress();
            }
          }
          if (currentMission && currentMission.bonus && currentMission.bonus.type === 'visitNode' && currentMission.bonus.nodeIndex === i) {
            if (camera.position.distanceTo(node.position) < 50) {
              currentMission.bonus.progress++;
              checkMissionProgress();
            }
          }
        });

        nodeLines.forEach((line, i) => {
          if (i < nodes.length - 1) {
            const geometry = new THREE.BufferGeometry().setFromPoints([nodes[i].position, nodes[i + 1].position]);
            line.geometry.dispose();
            line.geometry = geometry;
          }
        });

        beacons.forEach((beacon, bIndex) => {
          beacon.visible = camera.position.distanceTo(beacon.position) < 1000;
          if (camera.position.distanceTo(beacon.position) < 20) {
            if (currentMission && currentMission.type === 'collectBeacons') {
              currentMission.progress++;
            }
            if (currentMission && currentMission.bonus && currentMission.bonus.type === 'collectBeacons') {
              currentMission.bonus.progress++;
            }
            playerHealth = Math.min(playerHealth + 20, 100);
            stats.beaconsCollected++;
            scene.remove(beacon);
            beacons.splice(bIndex, 1);
            checkMissionProgress();
          }
        });

        let toRemove = { enemies: [], planets: [], drones: [], projectiles: [], enemyProjectiles: [], particleSystems: [] };
        projectiles.forEach((projectile, pIndex) => {
          if (projectile.userData.target && scene.children.includes(projectile.userData.target) && projectile.userData.seekTime < projectile.userData.maxSeekTime) {
            const toTarget = projectile.userData.target.position.clone().sub(projectile.position).normalize();
            projectile.userData.velocity.lerp(toTarget.multiplyScalar(300), 0.1);
            projectile.userData.seekTime += deltaTime;
          }
          projectile.position.add(projectile.userData.velocity.clone().multiplyScalar(deltaTime));
          if (projectile.position.length() > 2000) {
            toRemove.projectiles.push(pIndex);
            return;
          }

          enemies.forEach((enemy, eIndex) => {
            if (projectile.position.distanceTo(enemy.position) < (enemy.userData.health > 1 ? 30 : 15)) {
              enemy.userData.health--;
              toRemove.projectiles.push(pIndex);
              if (enemy.userData.health <= 0) {
                toRemove.enemies.push(eIndex);
                stats.enemiesDestroyed++;
                lastEnemySpawn = now;
                if (currentMission && (currentMission.type === 'dogfight' || currentMission.type === 'destroyEnemies') && enemy.userData.type === currentMission.target) {
                  currentMission.progress++;
                  checkMissionProgress();
                }
              }
            }
          });

          planets.forEach((planet, plIndex) => {
            if (projectile.position.distanceTo(planet.position) < 55) {
              planet.userData.health--;
              toRemove.projectiles.push(pIndex);
              if (planet.userData.health <= 0) {
                toRemove.planets.push(plIndex);
                stats.planetsDestroyed++;
                if (currentMission && currentMission.type === 'destroyPlanets') {
                  currentMission.progress++;
                  checkMissionProgress();
                }
              }
            }
          });

          drones.forEach((drone, dIndex) => {
            if (projectile.position.distanceTo(drone.position) < 10 && drone.userData.type !== 'escort drone') {
              toRemove.drones.push(dIndex);
              toRemove.projectiles.push(pIndex);
            }
          });
        });

        enemyProjectiles.forEach((projectile, epIndex) => {
          projectile.position.add(projectile.userData.velocity.clone().multiplyScalar(deltaTime));
          if (projectile.position.length() > 2000) {
            toRemove.enemyProjectiles.push(epIndex);
            return;
          }
          if (camera.position.distanceTo(projectile.position) < 10 && !autoQuestActive) {
            playerHealth -= projectile.userData.source.userData.health > 1 ? 3 : 1;
            lastHit = now;
            toRemove.enemyProjectiles.push(epIndex);
            addConsoleMessage('Warning: Ship hit! Health remaining: ' + Math.max(0, playerHealth));
          }
        });

        particleSystems.forEach((system, sIndex) => {
          system.userData.age += deltaTime;
          if (system.userData.age > system.userData.maxAge) {
            toRemove.particleSystems.push(sIndex);
            return;
          }
          const positions = system.geometry.attributes.position.array;
          for (let i = 0; i < positions.length; i += 3) {
            positions[i] += (Math.random() - 0.5) * 5 * deltaTime;
            positions[i + 1] += (Math.random() - 0.5) * 5 * deltaTime;
            positions[i + 2] += (Math.random() - 0.5) * 5 * deltaTime;
          }
          system.geometry.attributes.position.needsUpdate = true;
          system.material.opacity = 1 - system.userData.age / system.userData.maxAge;
        });

        toRemove.enemies.sort((a, b) => b - a).forEach(idx => {
          scene.remove(enemies[idx]);
          enemies.splice(idx, 1);
        });
        toRemove.planets.sort((a, b) => b - a).forEach(idx => {
          scene.remove(planets[idx]);
          planets.splice(idx, 1);
          drones = drones.filter(d => d.userData.planet !== planets[idx]);
        });
        toRemove.drones.sort((a, b) => b - a).forEach(idx => {
          scene.remove(drones[idx]);
          drones.splice(idx, 1);
        });
        toRemove.projectiles.sort((a, b) => b - a).forEach(idx => {
          scene.remove(projectiles[idx]);
          projectiles.splice(idx, 1);
        });
        toRemove.enemyProjectiles.sort((a, b) => b - a).forEach(idx => {
          scene.remove(enemyProjectiles[idx]);
          enemyProjectiles.splice(idx, 1);
        });
        toRemove.particleSystems.sort((a, b) => b - a).forEach(idx => {
          scene.remove(particleSystems[idx]);
          particleSystems.splice(idx, 1);
        });

        enemyMarkers.forEach(marker => marker.remove());
        enemyMarkers = [];
        enemies.forEach(enemy => {
          const dist = camera.position.distanceTo(enemy.position);
          if (dist < 1000) {
            const screenPos = enemy.position.clone().project(camera);
            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
            const marker = document.createElement('div');
            marker.className = 'enemy-marker';
            marker.style.left = x + 'px';
            marker.style.top = y + 'px';
            marker.style.borderColor = enemy.userData.health > 1 ? '#800080' : enemy.material === materials.enemyRed ? '#ff0000' : '#ffff00';
            document.getElementById('gameCanvas').appendChild(marker);
            enemyMarkers.push(marker);
          }
        });

        statusOverlay.innerHTML = `Enemies: ${stats.enemiesDestroyed} | Planets: ${stats.planetsDestroyed} | Beacons: ${stats.beaconsCollected} | Missions: ${stats.missionsCompleted}/12 | Health: <div class="health-bar"><div class="health-fill" style="width: ${playerHealth}%"></div></div>`;

        renderer.render(scene, camera);
      }

      // Resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Initialize
      addConsoleMessage('Starquest loading...');
      animate();
    };
  </script>
</body>
</html>
