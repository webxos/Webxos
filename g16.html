<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Locker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #000000;
            font-family: 'Courier New', monospace;
            color: #00ff00;
            min-height: 100vh;
        }
        .app-container {
            width: 100%;
            max-width: 220px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 0;
            position: relative;
        }
        .hologram-container {
            width: 220px;
            height: 180px;
            position: relative;
            overflow: hidden;
            z-index: 1;
        }
        .hologram {
            width: 180px;
            height: 180px;
            position: absolute;
            top: 0;
            left: 20px;
            transform-style: preserve-3d;
            animation: rotateHologram 30s infinite linear;
        }
        .grid-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #00ff00, #00cc00);
            opacity: 0.5;
        }
        .grid-layer {
            position: absolute;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(45deg, transparent, transparent 8px, rgba(0, 255, 0, 0.5) 8px, rgba(0, 255, 0, 0.5) 10px);
            animation: shiftGrid 10s infinite linear;
        }
        .grid-wireframe {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 1px solid #00ff00;
        }
        .grid-plane {
            position: absolute;
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            animation: pulsePlane 5s infinite;
        }
        .neural-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #00ff00;
            border-radius: 50%;
            animation: pulseDot 2s infinite;
        }
        .neural-line {
            position: absolute;
            background: rgba(0, 255, 0, 0.5);
            height: 2px;
            transform-origin: 0 0;
            animation: pulseLine 3s infinite;
        }
        .protein-cluster {
            position: absolute;
            transform-style: preserve-3d;
            animation: foldCluster 6s infinite ease-in-out;
        }
        .button-container {
            display: flex;
            gap: 8px;
            margin: 10px 0;
            z-index: 1;
        }
        .btn {
            padding: 8px 14px;
            font-size: 12px;
            color: #000000;
            background: #00ff00;
            border: none;
            cursor: pointer;
        }
        .console-section {
            width: 100%;
            max-width: 220px;
            margin: 10px 0;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 0;
        }
        .console-section textarea {
            width: 100%;
            height: 100px;
            padding: 10px;
            background: #000000;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            box-sizing: border-box;
            resize: none;
            margin-top: 10px;
        }
        .console-section button {
            padding: 6px 12px;
            background: #00ff00;
            color: #000000;
            border: none;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
        }
        .console-section #consoleOutput {
            margin-top: 5px;
            font-size: 12px;
            color: #00ff00;
            word-wrap: break-word;
            max-height: 200px;
            overflow-y: auto;
        }
        .file-upload {
            margin-top: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .file-upload input[type="file"] {
            display: none;
        }
        .file-upload label {
            padding: 6px 12px;
            background: #00ff00;
            color: #000000;
            border: none;
            cursor: pointer;
            font-size: 12px;
            display: inline-block;
        }
        .file-upload span {
            font-size: 12px;
            color: #00ff00;
        }
        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 180px;
            padding: 12px;
            background: #000000;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 1000;
        }
        .popup h3 {
            margin: 0 0 10px;
            font-size: 14px;
        }
        .popup input, .popup textarea {
            width: 100%;
            padding: 6px;
            background: #000000;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-bottom: 8px;
        }
        .popup .btn {
            width: 100%;
            margin: 5px 0 0;
            padding: 8px 14px;
        }
        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }
        footer {
            width: 100%;
            max-width: 220px;
            text-align: center;
            font-size: 10px;
            color: #00ff00;
            margin-top: 10px;
        }
        @keyframes rotateHologram {
            0% { transform: rotateY(0deg) rotateX(15deg); }
            100% { transform: rotateY(360deg) rotateX(15deg); }
        }
        @keyframes shiftGrid {
            0% { background-position: 0 0; }
            100% { background-position: 80px 80px; }
        }
        @keyframes pulsePlane {
            0%, 100% { transform: scale(1) translateZ(0); }
            50% { transform: scale(1.1) translateZ(12px); }
        }
        @keyframes pulseDot {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.5); opacity: 1; }
        }
        @keyframes pulseLine {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
        }
        @keyframes foldCluster {
            0% { transform: rotateX(0deg) rotateY(0deg) scale(1); }
            50% { transform: rotateX(180deg) rotateY(180deg) scale(1.2); }
            100% { transform: rotateX(360deg) rotateY(360deg) scale(1); }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="hologram-container">
            <div class="hologram" id="hologram"></div>
        </div>
        <div class="console-section">
            <textarea id="consoleInput" placeholder="Enter message"></textarea>
            <div class="file-upload">
                <label for="fileInput" class="btn">Upload File</label>
                <input type="file" id="fileInput">
                <span id="fileName"></span>
            </div>
            <button onclick="clearConsole()">Clear</button>
            <div id="consoleOutput"></div>
        </div>
        <div class="button-container">
            <button class="btn" onclick="generateGrid()">Generate</button>
            <button class="btn" onclick="copyCode()">Copy</button>
            <button class="btn" onclick="showExecutePopup()">Execute</button>
        </div>
    </div>

    <div class="popup-overlay" id="executeOverlay"></div>
    <div class="popup" id="executePopup">
        <h3>Execute Grid</h3>
        <textarea id="executeInput" placeholder="Paste all Ω holo codes (Ω1_, Ω2_, Ω3_, Ω4_, ΩK_) or legacy code"></textarea>
        <button class="btn" onclick="executeGrid()">Submit</button>
        <button class="btn" onclick="closeExecutePopup()">Cancel</button>
    </div>

    <footer>
        © WebXOS 2025<br>
        Usage: Generate compresses and encrypts data into four Ω holo codes plus a key code. Copy to share (e.g., via email). Execute decompresses and decrypts data from all codes pasted together. Legacy codes supported. Offline capable. Max 10 MB uploads. Use at your own risk.
    </footer>

    <script>
        // IndexedDB setup with promise
        const dbName = 'GridLockerDB';
        const storeName = 'grids';
        let db;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(dbName, 12);
                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    if (!db.objectStoreNames.contains(storeName)) {
                        db.createObjectStore(storeName, { keyPath: 'serial' });
                        console.log('IndexedDB store created');
                    } else {
                        console.log('IndexedDB store already exists');
                    }
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('IndexedDB initialized');
                    resolve(db);
                };
                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // Compression utilities
        function compressData(data) {
            try {
                const encoded = new TextEncoder().encode(data);
                const compressed = pako.gzip(encoded);
                return Array.from(compressed);
            } catch (e) {
                console.error('Compression failed:', e);
                throw e;
            }
        }

        function decompressData(compressed) {
            try {
                const decompressed = pako.ungzip(new Uint8Array(compressed));
                return new TextDecoder().decode(decompressed);
            } catch (e) {
                console.error('Decompression failed:', e);
                throw e;
            }
        }

        function compressBinary(data) {
            try {
                const compressed = pako.gzip(new Uint8Array(data));
                return Array.from(compressed);
            } catch (e) {
                console.error('Binary compression failed:', e);
                throw e;
            }
        }

        function decompressBinary(compressed) {
            try {
                return Array.from(pako.ungzip(new Uint8Array(compressed)));
            } catch (e) {
                console.error('Binary decompression failed:', e);
                throw e;
            }
        }

        // Utility functions
        async function generateKey() {
            try {
                return await crypto.subtle.generateKey(
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );
            } catch (e) {
                console.error('Key generation failed:', e);
                throw e;
            }
        }

        async function exportKey(key) {
            try {
                const exported = await crypto.subtle.exportKey('raw', key);
                return Array.from(new Uint8Array(exported));
            } catch (e) {
                console.error('Key export failed:', e);
                throw e;
            }
        }

        async function importKey(keyData) {
            try {
                return await crypto.subtle.importKey(
                    'raw',
                    new Uint8Array(keyData),
                    { name: 'AES-GCM' },
                    true,
                    ['encrypt', 'decrypt']
                );
            } catch (e) {
                console.error('Key import failed:', e);
                throw e;
            }
        }

        async function encryptData(data, key) {
            try {
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv },
                    key,
                    new Uint8Array(data)
                );
                return { iv: Array.from(iv), data: Array.from(new Uint8Array(encrypted)) };
            } catch (e) {
                console.error('Encryption failed:', e);
                throw e;
            }
        }

        async function decryptData(encrypted, key) {
            try {
                const iv = new Uint8Array(encrypted.iv);
                const data = new Uint8Array(encrypted.data);
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv },
                    key,
                    data
                );
                return Array.from(new Uint8Array(decrypted));
            } catch (e) {
                console.error('Decryption failed:', e);
                throw e;
            }
        }

        // Random Tree Node
        class TreeNode {
            constructor(data, depth = 0) {
                this.data = data;
                this.children = [];
                this.depth = depth;
                this.id = Math.random().toString(36).substr(2, 9);
            }

            addChild(node) {
                this.children.push(node);
            }
        }

        function buildRandomTree(dataChunks, maxDepth = 3, maxChildren = 3) {
            console.log('Building tree with', dataChunks.length, 'chunks');
            const root = new TreeNode(null, 0);
            let nodes = [root];
            let chunkIndex = 0;

            while (nodes.length > 0 && chunkIndex < dataChunks.length) {
                const current = nodes.shift();
                if (current.depth >= maxDepth) continue;

                const childCount = Math.floor(Math.random() * maxChildren) + 1;
                for (let i = 0; i < childCount && chunkIndex < dataChunks.length; i++) {
                    const child = new TreeNode(dataChunks[chunkIndex], current.depth + 1);
                    current.addChild(child);
                    nodes.push(child);
                    chunkIndex++;
                }
            }

            while (chunkIndex < dataChunks.length) {
                const node = nodes[Math.floor(Math.random() * nodes.length)] || root;
                const child = new TreeNode(dataChunks[chunkIndex], node.depth + 1);
                node.addChild(child);
                chunkIndex++;
            }

            return root;
        }

        // Visualization with multi-grids and protein clusters
        function generateVisualization(tree, serial) {
            console.log('Generating visualization for serial:', serial);
            const hologram = document.getElementById('hologram');
            hologram.innerHTML = '';

            // Multi-grid layers from original code
            const gridBase = document.createElement('div');
            gridBase.className = 'grid-base';
            gridBase.style.opacity = 0.5;
            hologram.appendChild(gridBase);

            const layerCount = Math.floor(Math.random() * 3) + 2;
            for (let i = 0; i < layerCount; i++) {
                const layer = document.createElement('div');
                layer.className = 'grid-layer';
                const z = (Math.random() - 0.5) * 60 * (i + 1) / layerCount;
                layer.style.cssText = `
                    transform: translateZ(${z}px) rotateY(${Math.random() * 24 - 12}deg) rotateX(${Math.random() * 24 - 12}deg);
                    opacity: ${Math.random() * 0.4 + 0.3};
                `;
                hologram.appendChild(layer);
            }

            const wireframeCount = Math.floor(Math.random() * 2) + 1;
            for (let i = 0; i < wireframeCount; i++) {
                const wireframe = document.createElement('div');
                wireframe.className = 'grid-wireframe';
                const z = (Math.random() - 0.5) * 50;
                const scale = Math.random() * 0.3 + 0.8;
                wireframe.style.cssText = `
                    transform: translateZ(${z}px) scale(${scale}) rotateX(${Math.random() * 40 - 20}deg) rotateY(${Math.random() * 40 - 20}deg);
                    opacity: ${Math.random() * 0.4 + 0.5};
                `;
                hologram.appendChild(wireframe);
            }

            const planeCount = Math.floor(Math.random() * 2) + 2;
            for (let i = 0; i < planeCount; i++) {
                const plane = document.createElement('div');
                plane.className = 'grid-plane';
                const width = Math.random() * 60 + 40;
                const height = Math.random() * 60 + 40;
                const left = Math.random() * (100 - width / 1.8);
                const top = Math.random() * (100 - height / 1.8);
                const z = (Math.random() - 0.5) * 80;
                plane.style.cssText = `
                    width: ${width}px;
                    height: ${height}px;
                    left: ${left}%;
                    top: ${top}%;
                    transform: translateZ(${z}px) rotateX(${Math.random() * 70 - 35}deg) rotateY(${Math.random() * 70 - 35}deg);
                `;
                hologram.appendChild(plane);
            }

            // Protein-like clusters
            const clusters = [];
            function traverse(node, x = 90, y = 90, z = 0, depth = 0) {
                if (node.data) {
                    clusters.push({ nodes: [{ x, y, z, id: node.id }], depth });
                } else {
                    let clusterNodes = [];
                    node.children.forEach((child, i) => {
                        const angle = (i / node.children.length) * 2 * Math.PI;
                        const radius = 20 / (depth + 1);
                        const childX = x + radius * Math.cos(angle);
                        const childY = y + radius * Math.sin(angle);
                        const childZ = z + (Math.random() - 0.5) * 15;
                        if (child.data) {
                            clusterNodes.push({ x: childX, y: childY, z: childZ, id: child.id });
                        }
                        traverse(child, childX, childY, childZ, depth + 1);
                    });
                    if (clusterNodes.length > 0) {
                        clusters.push({ nodes: clusterNodes, depth });
                    }
                }
            }
            traverse(tree);

            // Render clusters
            clusters.forEach((cluster, index) => {
                const clusterDiv = document.createElement('div');
                clusterDiv.className = 'protein-cluster';
                clusterDiv.style.left = `${cluster.nodes[0].x}px`;
                clusterDiv.style.top = `${cluster.nodes[0].y}px`;
                clusterDiv.style.transform = `translateZ(${cluster.nodes[0].z}px)`;

                cluster.nodes.forEach(node => {
                    const dot = document.createElement('div');
                    dot.className = 'neural-dot';
                    dot.style.left = `${node.x - cluster.nodes[0].x}px`;
                    dot.style.top = `${node.y - cluster.nodes[0].y}px`;
                    dot.style.transform = `translateZ(${node.z - cluster.nodes[0].z}px)`;
                    clusterDiv.appendChild(dot);
                });

                for (let i = 0; i < cluster.nodes.length - 1; i++) {
                    const n1 = cluster.nodes[i];
                    const n2 = cluster.nodes[i + 1];
                    const line = document.createElement('div');
                    line.className = 'neural-line';
                    const dx = n2.x - n1.x;
                    const dy = n2.y - n1.y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    line.style.width = `${length}px`;
                    line.style.left = `${n1.x - cluster.nodes[0].x}px`;
                    line.style.top = `${n1.y - cluster.nodes[0].y}px`;
                    line.style.transform = `rotate(${angle}deg) translateZ(${n1.z - cluster.nodes[0].z}px)`;
                    clusterDiv.appendChild(line);
                }

                hologram.appendChild(clusterDiv);
            });
        }

        // Main app logic
        const consoleInput = document.getElementById('consoleInput');
        const consoleOutput = document.getElementById('consoleOutput');
        const fileInput = document.getElementById('fileInput');
        const fileNameDisplay = document.getElementById('fileName');
        const executePopup = document.getElementById('executePopup');
        const executeOverlay = document.getElementById('executeOverlay');
        const executeInput = document.getElementById('executeInput');
        let currentFile = null;
        let serialCounter = 1;

        async function generateGrid() {
            console.log('generateGrid called');
            try {
                if (!db) {
                    alert('Database not ready. Please try again.');
                    console.error('Database not initialized');
                    return;
                }

                const message = consoleInput.value;
                if (!message && !currentFile) {
                    alert('Enter a message or upload a file!');
                    console.warn('No input provided');
                    return;
                }

                console.log('Generating key');
                const key = await generateKey();
                const keyData = await exportKey(key);

                let dataChunks = [];
                if (message) {
                    console.log('Compressing message');
                    const compressedMessage = compressData(message);
                    console.log('Encrypting compressed message');
                    const encrypted = await encryptData(compressedMessage, key);
                    dataChunks.push({ type: 'message', data: encrypted, compressed: true });
                }
                if (currentFile) {
                    console.log('Processing file:', currentFile.name);
                    if (currentFile.size > 10 * 1024 * 1024) {
                        alert('File exceeds 10 MB limit!');
                        console.warn('File too large:', currentFile.size);
                        return;
                    }
                    const fileData = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = () => reject(reader.error);
                        reader.readAsArrayBuffer(currentFile);
                    });
                    console.log('Compressing file');
                    const compressedFile = compressBinary(new Uint8Array(fileData));
                    console.log('Encrypting compressed file');
                    const encrypted = await encryptData(compressedFile, key);
                    dataChunks.push({ type: 'file', data: encrypted, compressed: true, name: currentFile.name, mimeType: currentFile.type });
                }

                console.log('Building tree');
                const tree = buildRandomTree(dataChunks);
                const serial = `HOLO-${String(serialCounter++).padStart(6, '0')}-${Math.random().toString(36).substr(2, 3).toUpperCase()}`;

                console.log('Serializing data');
                const serialized = JSON.stringify({
                    serial,
                    tree: serializeTree(tree)
                });
                console.log('Compressing serialized data');
                const compressedSerialized = compressData(serialized);
                const compressedKey = compressBinary(keyData);

                console.log('Splitting into holo codes');
                const chunkSize = Math.ceil(compressedSerialized.length / 4);
                const holoCodes = [];
                for (let i = 0; i < 4; i++) {
                    const chunk = compressedSerialized.slice(i * chunkSize, (i + 1) * chunkSize);
                    const base64 = btoa(String.fromCharCode(...chunk));
                    holoCodes.push(`Ω${i + 1}_${base64}`);
                }
                const keyBase64 = btoa(String.fromCharCode(...compressedKey));
                holoCodes.push(`ΩK_${keyBase64}`);

                console.log('Storing in IndexedDB');
                const tx = db.transaction([storeName], 'readwrite');
                const store = tx.objectStore(storeName);
                store.put({ serial, tree, key: keyData });
                await new Promise((resolve, reject) => {
                    tx.oncomplete = resolve;
                    tx.onerror = () => reject(tx.error);
                });

                console.log('Updating UI');
                consoleOutput.textContent = `Serial: ${serial}\nHolo Codes:\n${holoCodes.join('\n')}`;
                generateVisualization(tree, serial);
            } catch (e) {
                console.error('generateGrid error:', e);
                alert('Failed to generate grid: ' + e.message);
            }
        }

        function serializeTree(tree) {
            return {
                data: tree.data,
                children: tree.children.map(child => serializeTree(child))
            };
        }

        function deserializeTree(obj) {
            const node = new TreeNode(obj.data);
            obj.children.forEach(childObj => node.addChild(deserializeTree(childObj)));
            return node;
        }

        async function executeGrid() {
            console.log('executeGrid called');
            try {
                const input = executeInput.value.trim();
                if (!input) {
                    alert('Paste holo codes or legacy code!');
                    console.warn('No input provided');
                    return;
                }

                // Split input by newlines or spaces, filter out empty strings
                const codes = input.split(/[\n\s]+/).filter(code => code.trim());
                let serialized, keyData;

                if (codes.length === 1) {
                    // Assume legacy code
                    console.log('Processing legacy code');
                    try {
                        const decoded = JSON.parse(atob(codes[0]));
                        serialized = JSON.stringify(decoded);
                        keyData = Uint8Array.from(atob(decoded.key), c => c.charCodeAt(0));
                    } catch (e) {
                        throw new Error('Invalid legacy code format');
                    }
                } else {
                    // Handle holo codes
                    if (codes.length !== 5) {
                        alert('Paste exactly five holo codes (Ω1_, Ω2_, Ω3_, Ω4_, ΩK_)!');
                        console.warn('Incorrect number of holo codes:', codes.length);
                        return;
                    }

                    // Validate holo code prefixes
                    const expectedPrefixes = ['Ω1_', 'Ω2_', 'Ω3_', 'Ω4_', 'ΩK_'];
                    const holoCodes = codes.slice(0, 4);
                    const keyCode = codes[4];
                    if (!holoCodes.every((code, i) => code.startsWith(`Ω${i + 1}_`)) || !keyCode.startsWith('ΩK_')) {
                        alert('Invalid holo code format! Ensure correct prefixes (Ω1_, Ω2_, Ω3_, Ω4_, ΩK_).');
                        console.warn('Invalid holo code prefixes');
                        return;
                    }

                    console.log('Recombining holo codes');
                    const chunks = holoCodes.map(code => {
                        const base64 = code.split('_')[1];
                        return Uint8Array.from(atob(base64), c => c.charCodeAt(0));
                    });
                    const compressedSerialized = [].concat(...chunks);
                    console.log('Decompressing serialized data');
                    serialized = decompressData(compressedSerialized);

                    console.log('Decompressing key');
                    const keyBase64 = keyCode.split('_')[1];
                    keyData = decompressBinary(Uint8Array.from(atob(keyBase64), c => c.charCodeAt(0)));
                }

                const { serial, tree: treeObj } = JSON.parse(serialized);
                console.log('Importing key');
                const key = await importKey(keyData);
                console.log('Deserializing tree');
                const tree = deserializeTree(treeObj);

                let message = '';
                let fileData = null;
                async function traverse(node) {
                    if (node.data) {
                        console.log('Decrypting data');
                        let decrypted = await decryptData(node.data.data, key);
                        if (node.data.compressed) {
                            console.log('Decompressing data');
                            if (node.data.type === 'message') {
                                message = decompressData(decrypted);
                            } else if (node.data.type === 'file') {
                                decrypted = decompressBinary(decrypted);
                                fileData = {
                                    name: node.data.name,
                                    type: node.data.mimeType,
                                    data: new Uint8Array(decrypted)
                                };
                            }
                        } else {
                            // Legacy data (uncompressed)
                            if (node.data.type === 'message') {
                                message = new TextDecoder().decode(new Uint8Array(decrypted));
                            } else if (node.data.type === 'file') {
                                const parsed = JSON.parse(new TextDecoder().decode(new Uint8Array(decrypted)));
                                fileData = {
                                    name: parsed.name,
                                    type: parsed.type,
                                    data: new Uint8Array(parsed.data)
                                };
                            }
                        }
                    }
                    for (const child of node.children) {
                        await traverse(child);
                    }
                }
                await traverse(tree);

                console.log('Updating UI');
                consoleInput.value = message;
                consoleOutput.innerHTML = `Serial: ${serial}`;
                if (fileData) {
                    const blob = new Blob([fileData.data], { type: fileData.type });
                    const url = URL.createObjectURL(blob);
                    consoleOutput.innerHTML += `\nFile: <a href="${url}" download="${fileData.name}" style="color: #00ff00;">${fileData.name}</a> (${fileData.type}, ${formatFileSize(fileData.data.length)})`;
                }
                generateVisualization(tree, serial);

                console.log('Storing in IndexedDB');
                const tx = db.transaction([storeName], 'readwrite');
                const store = tx.objectStore(storeName);
                store.put({ serial, tree, key: keyData });
                await new Promise((resolve, reject) => {
                    tx.oncomplete = resolve;
                    tx.onerror = () => reject(tx.error);
                });

                closeExecutePopup();
            } catch (e) {
                console.error('executeGrid error:', e);
                alert('Invalid or corrupted code: ' + e.message);
            }
        }

        function copyCode() {
            console.log('copyCode called');
            const output = consoleOutput.textContent;
            if (output.includes('Holo Codes:')) {
                const codes = output.split('Holo Codes:')[1].trim();
                navigator.clipboard.writeText(codes).then(() => {
                    alert('Holo codes copied!');
                }).catch(err => {
                    console.error('Copy failed:', err);
                    alert('Failed to copy: ' + err);
                });
            } else {
                alert('Generate a grid first!');
                console.warn('No codes to copy');
            }
        }

        function clearConsole() {
            console.log('clearConsole called');
            consoleInput.value = '';
            fileInput.value = '';
            fileNameDisplay.textContent = '';
            consoleOutput.textContent = '';
            currentFile = null;
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            else if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        fileInput.addEventListener('change', (e) => {
            console.log('fileInput changed');
            if (e.target.files.length > 0) {
                currentFile = e.target.files[0];
                fileNameDisplay.textContent = `${currentFile.name} (${formatFileSize(currentFile.size)})`;
            } else {
                currentFile = null;
                fileNameDisplay.textContent = '';
            }
        });

        function showExecutePopup() {
            console.log('showExecutePopup called');
            executeInput.value = '';
            executePopup.style.display = 'block';
            executeOverlay.style.display = 'block';
        }

        function closeExecutePopup() {
            console.log('closeExecutePopup called');
            executePopup.style.display = 'none';
            executeOverlay.style.display = 'none';
        }

        // Initialize
        window.addEventListener('load', async () => {
            console.log('Window loaded, initializing');
            try {
                await initDB();
                const initTree = new TreeNode(null);
                initTree.addChild(new TreeNode({ type: 'init', data: {} }));
                generateVisualization(initTree, 'HOLO-INIT');
                consoleOutput.textContent = 'Serial: HOLO-INIT';
            } catch (e) {
                console.error('Initialization failed:', e);
                alert('Failed to initialize app: ' + e.message);
            }
        });
    </script>
</body>
</html>
