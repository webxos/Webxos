<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Exoskeleton AI</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #0f0;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            overscroll-behavior: none;
        }
        .header {
            width: 100%;
            max-width: 320px;
            text-align: center;
            padding: 8px;
            font-size: 16px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0, 0 0 10px #0f0;
            height: 40px;
            position: fixed;
            top: 0;
            background: rgba(0,0,0,0.8);
            z-index: 20;
        }
        .app-container {
            width: 100%;
            max-width: 320px;
            height: 320px;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 40px;
            margin-bottom: 10px;
        }
        .hologram-container {
            width: 100%;
            max-width: 320px;
            height: 320px;
            position: relative;
            overflow: visible;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .hologram {
            width: 320px;
            height: 320px;
            position: absolute;
            top: 0;
            left: 0;
            transform-style: preserve-3d;
            animation: rotateHologram 30s infinite linear;
            display: grid;
            grid-gap: 2px;
            z-index: 5;
        }
        .grid-square {
            background: rgba(0,255,0,0.6);
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
            animation: pulseSquare 4s infinite;
        }
        .signature-layer {
            position: absolute;
            width: 200px;
            height: 100px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.6;
            z-index: 10;
            filter: drop-shadow(0 0 5px #0f0);
            display: grid;
            grid-template-columns: repeat(20, 10px);
            grid-template-rows: repeat(10, 10px);
            gap: 1px;
        }
        .signature-cell {
            background: rgba(0,255,0,0.8);
            border: 1px solid #0f0;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .signature-cell.active {
            opacity: 1;
        }
        .bottom-section {
            width: 100%;
            max-width: 320px;
            position: fixed;
            bottom: 0;
            display: flex;
            flex-direction: column;
            background: rgba(0,0,0,0.8);
            box-shadow: 0 0 10px #0f0;
            z-index: 10;
        }
        .console-section {
            width: 100%;
            max-height: calc(100vh - 40px - 320px - 52px - 20px);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #console {
            width: 100%;
            flex: 1;
            overflow-y: auto;
            touch-action: auto;
            font-size: 14px;
            padding: 8px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: #0f0 rgba(0,0,0,0.8);
            overscroll-behavior: contain;
        }
        #console::-webkit-scrollbar {
            width: 8px;
        }
        #console::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.8);
        }
        #console::-webkit-scrollbar-thumb {
            background: #0f0;
            border-radius: 4px;
            box-shadow: 0 0 5px #0f0;
        }
        .entry {
            margin: 4px 0;
            word-wrap: break-word;
        }
        .timestamp {
            color: #080;
            margin-right: 8px;
        }
        .input-area {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            width: 100%;
            padding: 8px;
            background: rgba(0,0,0,0.8);
            border-top: 1px solid #0f0;
            min-height: 52px;
        }
        input {
            flex: 1;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            padding: 8px;
            box-shadow: 0 0 5px #0f0;
            min-height: 36px;
            min-width: 100px;
            touch-action: auto;
        }
        button {
            flex: 0 0 auto;
            background: rgba(0,255,0,0.1);
            color: #0f0;
            border: 2px solid #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            padding: 8px;
            border-radius: 8px;
            min-height: 36px;
            min-width: 70px;
            text-transform: uppercase;
            transition: all 0.2s ease;
            box-shadow: 0 0 8px #0f0;
            touch-action: auto;
        }
        button:hover {
            background: #0f0;
            color: #000;
            cursor: pointer;
            box-shadow: 0 0 12px #0f0;
            transform: scale(1.05);
        }
        button:active {
            transform: scale(0.95);
            box-shadow: 0 0 5px #0f0;
        }
        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            padding: 12px;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 1000;
            box-shadow: 0 0 10px #0f0;
            touch-action: auto;
        }
        .popup h3 {
            margin: 0 0 10px;
            font-size: 14px;
            text-shadow: 0 0 5px #0f0;
        }
        .popup canvas {
            width: 100%;
            height: 150px;
            background: #000;
            border: 1px solid #0f0;
            margin-bottom: 8px;
            touch-action: auto;
        }
        .popup input[type="file"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            font-size: 12px;
        }
        .popup .btn {
            width: 100%;
            margin: 5px 0;
            padding: 8px;
            background: rgba(0,255,0,0.1);
            color: #0f0;
            border: 2px solid #0f0;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 8px #0f0;
            transition: all 0.2s ease;
            touch-action: auto;
        }
        .popup .btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 12px #0f0;
        }
        .popup .btn:active {
            transform: scale(0.95);
        }
        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 999;
            touch-action: none;
        }
        footer {
            width: 100%;
            text-align: center;
            font-size: 10px;
            color: #0f0;
            padding: 4px 0;
            text-shadow: 0 0 3px #0f0;
            height: 20px;
            background: rgba(0,0,0,0.8);
            border-top: 1px solid #0f0;
        }
        @media (max-width: 480px) {
            .header {
                max-width: 280px;
                font-size: 14px;
                padding: 6px;
                height: 36px;
            }
            .app-container {
                max-width: 280px;
                height: 280px;
                margin-top: 36px;
            }
            .hologram-container {
                max-width: 280px;
                height: 280px;
            }
            .hologram {
                width: 280px;
                height: 280px;
                left: 0;
            }
            .signature-layer {
                width: 150px;
                height: 75px;
                grid-template-columns: repeat(15, 10px);
                grid-template-rows: repeat(8, 9.375px);
            }
            .bottom-section {
                max-width: 100%;
            }
            .console-section {
                max-height: calc(100vh - 36px - 280px - 48px - 18px);
            }
            #console {
                font-size: 12px;
                padding: 6px;
            }
            .input-area {
                gap: 5px;
                padding: 6px;
                min-height: 48px;
            }
            input {
                font-size: 12px;
                padding: 6px;
                min-height: 32px;
                min-width: 90px;
            }
            button {
                font-size: 12px;
                padding: 6px;
                min-height: 32px;
                min-width: 60px;
                border-radius: 6px;
            }
            .popup {
                width: 260px;
            }
            .popup .btn {
                font-size: 12px;
                padding: 6px;
            }
            footer {
                font-size: 9px;
                padding: 3px;
                height: 18px;
            }
        }
        @keyframes rotateHologram {
            0% { transform: rotateY(0deg) rotateX(15deg); }
            100% { transform: rotateY(360deg) rotateX(15deg); }
        }
        @keyframes pulseSquare {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <div class="header">Exoskeleton AI</div>
    <div class="app-container">
        <div class="hologram-container">
            <div class="hologram" id="hologram"></div>
        </div>
    </div>
    <div class="bottom-section">
        <div class="console-section">
            <div id="console">
                <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Exoskeleton AI v1.0 - Holographic Console initialized</div>
                <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Type 'HELP' for commands</div>
                <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Serials and holo grid codes encode data in memory; persists via codes (use at your own risk.)</div>
            </div>
        </div>
        <div class="input-area">
            <input type="text" id="commandInput" placeholder="Enter command..." onkeydown="if(event.key === 'Enter') executeCommand()">
            <button onclick="executeCommand()">Execute</button>
            <button onclick="clearConsole()">Clear</button>
        </div>
        <footer>webXOS 2025. Use at your own risk.</footer>
    </div>
    <div class="popup-overlay" id="signOverlay"></div>
    <div class="popup" id="signPopup">
        <h3>Sign Exoskeleton AI</h3>
        <canvas id="signCanvas"></canvas>
        <button class="btn" onclick="submitSignature()">Submit</button>
        <button class="btn" onclick="closeSignPopup()">Cancel</button>
    </div>
    <div class="popup-overlay" id="uploadOverlay"></div>
    <div class="popup" id="uploadPopup">
        <h3>Upload File</h3>
        <p>Max file size: 5MB per file</p>
        <input type="file" id="fileInput">
        <button class="btn" onclick="submitUpload()">Upload</button>
        <button class="btn" onclick="closeUploadPopup()">Cancel</button>
    </div>
    <script>
        let database = [];
        let currentSerial = '';
        let currentHoloCode = '';
        let serialCounter = 1;
        let strokes = [];
        let usedSerials = new Set();
        const hologram = document.getElementById('hologram');
        const commandInput = document.getElementById('commandInput');
        const consoleDiv = document.getElementById('console');
        const signCanvas = document.getElementById('signCanvas');
        const signCtx = signCanvas.getContext('2d');
        const signPopup = document.getElementById('signPopup');
        const signOverlay = document.getElementById('signOverlay');
        const uploadPopup = document.getElementById('uploadPopup');
        const uploadOverlay = document.getElementById('uploadOverlay');
        const fileInput = document.getElementById('fileInput');
        let painting = false;
        let currentStroke = [];
        const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
        const MAX_SERIAL_SIZE = 10 * 1024 * 1024; // 10MB for serial code
        let signatureGrid = Array(10).fill().map(() => Array(20).fill(0)); // 10x20 grid for signature

        // IndexedDB Setup
        let db;
        const dbName = 'ExoskeletonAI';
        const storeName = 'signatures';
        const dbRequest = indexedDB.open(dbName, 1);

        dbRequest.onupgradeneeded = (event) => {
            db = event.target.result;
            if (!db.objectStoreNames.contains(storeName)) {
                db.createObjectStore(storeName, { keyPath: 'id' });
            }
        };

        dbRequest.onsuccess = (event) => {
            db = event.target.result;
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>IndexedDB initialized</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        };

        dbRequest.onerror = (event) => {
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: IndexedDB initialization failed - ${event.target.error}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        };

        function storeMiniSignature(id, miniImage) {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.put({ id, miniImage });

            request.onsuccess = () => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Mini signature stored in IndexedDB with ID: ${id}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            };

            request.onerror = (event) => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to store mini signature - ${event.target.error}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            };
        }

        function retrieveMiniSignature(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(id);

                request.onsuccess = (event) => {
                    const result = event.target.result;
                    if (result) {
                        resolve(result.miniImage);
                    } else {
                        resolve(null);
                    }
                };

                request.onerror = (event) => {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to retrieve mini signature - ${event.target.error}</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    reject(event.target.error);
                };
            });
        }

        // Exoskeleton AI Agent
        const ExoskeletonAIAgent = {
            organizeData(entries) {
                const fileEntries = entries.filter(entry => entry.isFile && entry.text !== ':DELETED');
                const nonFileEntries = entries.filter(entry => !entry.isFile && entry.text !== ':DELETED');
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Agent: Organized ${fileEntries.length} file entries for serial, ${nonFileEntries.length} non-file entries for holo grid</div>`;
                fileEntries.forEach((entry, idx) => {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Agent: File entry ${idx}: ${entry.fileName}, ${entry.fileSize} bytes, text=${entry.text.slice(0, 50)}${entry.text.length > 50 ? '...' : ''}, isFile=${entry.isFile}, hasData=${!!entry.fileData}</div>`;
                });
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return { fileEntries, nonFileEntries };
            },
            validateFileEntry(entry, index) {
                if (!entry.isFile) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Agent: Invalid file entry at index ${index}: Not marked as file</div>`;
                    return false;
                }
                const isValid = entry.fileName && entry.fileSize > 0 && entry.fileType && entry.fileData && /^[A-Za-z0-9+/=]+$/.test(entry.fileData) && entry.text && !entry.text.includes(':DELETED');
                if (!isValid) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Agent: Invalid file entry at index ${index}: ${JSON.stringify({ fileName: entry.fileName, fileSize: entry.fileSize, fileType: entry.fileType, hasData: !!entry.fileData, text: entry.text })})</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                }
                return isValid;
            },
            calculateDataUsage(entries) {
                let fileSizeKB = 0;
                let nonFileSizeKB = 0;
                entries.forEach((entry, index) => {
                    if (entry.isFile && entry.text !== ':DELETED') {
                        if (this.validateFileEntry(entry, index)) {
                            fileSizeKB += entry.fileSize / 1024;
                        }
                    } else if (entry.text !== ':DELETED') {
                        const textSize = (entry.text || '').length * 2 / 1024; // Approx. 2 bytes per char
                        const sigSize = entry.signature ? (entry.miniSignature.length / 1024) : 0; // Approx. base64 size
                        const gridSize = entry.signatureGrid ? (JSON.stringify(entry.signatureGrid).length * 2 / 1024) : 0;
                        nonFileSizeKB += textSize + sigSize + gridSize;
                    }
                });
                const totalSizeKB = fileSizeKB + nonFileSizeKB;
                const remainingSizeKB = (MAX_SERIAL_SIZE / 1024) - fileSizeKB; // Only files count toward serial limit
                return { totalSizeKB, fileSizeKB, nonFileSizeKB, remainingSizeKB };
            }
        };

        // Initialize canvas
        signCanvas.width = 280;
        signCanvas.height = 150;
        signCtx.lineWidth = 3;
        signCtx.lineCap = 'round';
        signCtx.lineJoin = 'round';
        signCtx.strokeStyle = '#0f0';

        // Prevent page scrolling on touch
        document.addEventListener('touchmove', (e) => {
            if (!e.target.closest('#console') && !e.target.closest('.popup') && !e.target.closest('.input-area')) {
                e.preventDefault();
            }
        }, { passive: false });

        // Ensure console scrolling
        consoleDiv.addEventListener('touchstart', () => {
            consoleDiv.style.scrollBehavior = 'smooth';
        });

        function getFullTimestamp() {
            return new Date().toLocaleString();
        }

        function hashCode(str, salt = '') {
            let hash = 2166136261;
            const saltedStr = str + salt;
            for (let i = 0; i < saltedStr.length; i++) {
                hash ^= saltedStr.charCodeAt(i);
                hash *= 16777619;
            }
            return Math.abs(hash);
        }

        function seededRandom(seed) {
            let x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        function compressDatabase(entries, isFile = false) {
            try {
                const serialized = entries.map((entry, idx) => {
                    if (isFile) {
                        if (!ExoskeletonAIAgent.validateFileEntry(entry, idx)) {
                            throw new Error(`Invalid file entry at index ${idx}`);
                        }
                        return {
                            text: entry.text,
                            time: entry.time.toISOString(),
                            isFile: true,
                            fileName: entry.fileName,
                            fileSize: entry.fileSize,
                            fileType: entry.fileType,
                            fileData: entry.fileData
                        };
                    } else {
                        return {
                            text: entry.text,
                            time: entry.time.toISOString(),
                            signature: entry.signature,
                            miniSignature: entry.miniSignature,
                            fullSignature: entry.fullSignature || '',
                            signatureGrid: entry.signatureGrid || []
                        };
                    }
                });
                const jsonString = JSON.stringify(serialized);
                const byteLength = new TextEncoder().encode(jsonString).length;
                if (isFile && byteLength > MAX_SERIAL_SIZE) {
                    throw new Error(`File data exceeds ${MAX_SERIAL_SIZE / 1024 / 1024}MB limit`);
                }
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Agent: Compressed ${serialized.length} ${isFile ? 'file' : 'non-file'} entries, ${byteLength / 1024} KB</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return jsonString;
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to compress database - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return '[]';
            }
        }

        function decompressDatabase(compressed, isFile = false) {
            try {
                const entries = JSON.parse(compressed);
                const result = entries.map((entry, index) => {
                    const parsed = {
                        text: entry.text || '',
                        time: new Date(entry.time || Date.now()),
                        signature: isFile ? false : (entry.signature || false),
                        miniSignature: isFile ? '' : (entry.miniSignature || ''),
                        fullSignature: isFile ? '' : (entry.fullSignature || ''),
                        signatureGrid: isFile ? [] : (entry.signatureGrid || []),
                        isFile: isFile,
                        fileName: isFile ? (entry.fileName || '') : '',
                        fileSize: isFile ? (entry.fileSize || 0) : 0,
                        fileType: isFile ? (entry.fileType || '') : '',
                        fileData: isFile ? (entry.fileData || '') : ''
                    };
                    if (isFile && parsed.text !== ':DELETED') {
                        if (!ExoskeletonAIAgent.validateFileEntry(parsed, index)) {
                            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Agent: Skipping invalid file entry at index ${index}</div>`;
                            return null;
                        }
                    }
                    return parsed;
                }).filter(entry => entry !== null);
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Agent: Decompressed ${result.length} ${isFile ? 'file' : 'non-file'} entries</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return result;
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Decompression failed - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return [];
            }
        }

        function encodeData(data, seed) {
            try {
                const compressed = compressDatabase(data, data.length > 0 && data[0].isFile);
                let encoded = '';
                for (let i = 0; i < compressed.length; i++) {
                    const charCode = compressed.charCodeAt(i);
                    const shift = (seed >> (i % 32)) & 0xFF;
                    encoded += String.fromCharCode((charCode + shift) % 256);
                }
                const base64 = btoa(encoded);
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Agent: Encoded data, length ${base64.length} chars</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return base64;
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Encoding failed - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return '';
            }
        }

        function decodeData(encoded, seed, isFile = false) {
            try {
                const decoded = atob(encoded);
                let decompressed = '';
                for (let i = 0; i < decoded.length; i++) {
                    const charCode = decoded.charCodeAt(i);
                    const shift = (seed >> (i % 32)) & 0xFF;
                    decompressed += String.fromCharCode((charCode - shift + 256) % 256);
                }
                const entries = decompressDatabase(decompressed, isFile);
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Agent: Decoded ${entries.length} ${isFile ? 'file' : 'non-file'} entries</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return entries;
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Decoding failed - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return [];
            }
        }

        function generateRandomSuffix() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let suffix = '';
            for (let i = 0; i < 3; i++) {
                suffix += chars.charAt(Math.floor(seededRandom(hashCode(suffix + i)) * chars.length));
            }
            return suffix.toUpperCase();
        }

        function generateSerialNumber(fileEntries) {
            let serial;
            let attempts = 0;
            const maxAttempts = 1000;
            do {
                if (serialCounter > 999999) serialCounter = 1;
                const paddedNumber = String(serialCounter++).padStart(6, '0');
                const suffix = generateRandomSuffix();
                const baseSerial = `HOLO-${paddedNumber}-${suffix}`;
                const seed = hashCode(baseSerial);
                const encodedFiles = encodeData(fileEntries, seed);
                if (!encodedFiles) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to encode file data</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return null;
                }
                serial = `${baseSerial}:${encodedFiles.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '')}`;
                attempts++;
                if (attempts > maxAttempts) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to generate unique serial</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return null;
                }
            } while (usedSerials.has(serial.split(':')[0]));
            usedSerials.add(serial.split(':')[0]);
            return serial;
        }

        function decodeSerialNumber(serial) {
            const [baseSerial, encodedFiles] = serial.split(':');
            if (!baseSerial.match(/^HOLO-\d{6}-[A-Z0-9]{3}$/)) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid serial format</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return [];
            }
            if (!encodedFiles) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No file data in serial</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return [];
            }
            const seed = hashCode(baseSerial);
            const paddedData = encodedFiles.replace(/-/g, '+').replace(/_/g, '/');
            const padding = (4 - (paddedData.length % 4)) % 4;
            const finalData = paddedData + '='.repeat(padding);
            const fileEntries = decodeData(finalData, seed, true);
            fileEntries.forEach((entry, index) => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Agent: Decoded file entry ${index}: ${entry.fileName}, ${entry.fileSize} bytes, text=${entry.text.slice(0, 50)}${entry.text.length > 50 ? '...' : ''}, isFile=${entry.isFile}, hasData=${!!entry.fileData}</div>`;
            });
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            return fileEntries;
        }

        function generateHoloGridCode(serialBase, nonFileEntries) {
            const seed = hashCode(serialBase);
            const encodedData = encodeData(nonFileEntries, seed);
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            const seedValue = hashCode(serialBase + 'GRID');
            for (let i = 0; i < 9; i++) {
                code += chars.charAt(Math.floor(seededRandom(seedValue + i) * chars.length));
            }
            code += '-' + encodedData.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
            return `GRID: ${code}`;
        }

        function decodeHoloGridCode(code, serialBase) {
            if (!code.startsWith('GRID: ')) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid holo grid code format</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return [];
            }
            const codeContent = code.slice(6);
            const parts = codeContent.split('-');
            if (parts.length < 2) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Malformed holo grid code</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return [];
            }
            const encodedData = parts.slice(1).join('-').replace(/-/g, '+').replace(/_/g, '/');
            const padding = (4 - (encodedData.length % 4)) % 4;
            const paddedData = encodedData + '='.repeat(padding);
            const seed = hashCode(serialBase);
            const nonFileEntries = decodeData(paddedData, seed, false);
            nonFileEntries.forEach((entry, index) => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Agent: Decoded non-file entry ${index}: text=${entry.text.slice(0, 50)}${entry.text.length > 50 ? '...' : ''}</div>`;
            });
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            return nonFileEntries;
        }

        function generateCodeSign(serial, timestamp) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let sign = '';
            const seedValue = hashCode(serial.split(':')[0] + timestamp);
            for (let i = 0; i < 8; i++) {
                sign += chars.charAt(Math.floor(seededRandom(seedValue + i) * chars.length));
                if (i === 3) sign += '-';
            }
            return `Ω-SIGN: ${sign}`;
        }

        function createStrokeReplica(codesign) {
            const glyphMap = {
                'A': 'Λ', 'B': 'β', 'C': 'C', 'D': 'Δ', 'E': 'Σ', 'F': 'F', 'G': 'Γ', 'H': 'H',
                'I': 'I', 'J': 'J', 'K': 'K', 'L': 'L', 'M': 'M', 'N': 'N', 'O': 'O', 'P': 'Π',
                'Q': 'Q', 'R': 'R', 'S': 'S', 'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X',
                'Y': 'Y', 'Z': 'Z', '0': '0', '1': '|', '2': '2', '3': '3', '4': '4', '5': '5',
                '6': '6', '7': '7', '8': '8', '9': '9', '-': '-'
            };
            return codesign.replace(/./g, c => glyphMap[c] || c);
        }

        function startPainting(e) {
            painting = true;
            const rect = signCanvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            currentStroke = [{ x, y }];
            signCtx.beginPath();
            signCtx.moveTo(x, y);
            updateSignatureGrid(x, y);
        }

        function stopPainting() {
            if (painting) {
                painting = false;
                if (currentStroke.length > 1) strokes.push([...currentStroke]);
                currentStroke = [];
                signCtx.beginPath();
            }
        }

        function draw(e) {
            if (!painting) return;
            e.preventDefault();
            const rect = signCanvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            currentStroke.push({ x, y });
            signCtx.lineTo(x, y);
            signCtx.stroke();
            signCtx.beginPath();
            signCtx.moveTo(x, y);
            updateSignatureGrid(x, y);
        }

        function updateSignatureGrid(x, y) {
            const cellWidth = 280 / 20; // Canvas width / grid columns
            const cellHeight = 150 / 10; // Canvas height / grid rows
            const col = Math.floor(x / cellWidth);
            const row = Math.floor(y / cellHeight);
            if (row >= 0 && row < 10 && col >= 0 && col < 20) {
                signatureGrid[row][col] = 1;
            }
        }

        signCanvas.addEventListener('mousedown', startPainting);
        signCanvas.addEventListener('mouseup', stopPainting);
        signCanvas.addEventListener('mousemove', draw);
        signCanvas.addEventListener('touchstart', startPainting);
        signCanvas.addEventListener('touchend', stopPainting);
        signCanvas.addEventListener('touchmove', draw);
        signCanvas.addEventListener('mouseleave', stopPainting);

        function clearSignCanvas() {
            signCtx.clearRect(0, 0, signCanvas.width, signCanvas.height);
            strokes = [];
            currentStroke = [];
            painting = false;
            signCtx.beginPath();
            signatureGrid = Array(10).fill().map(() => Array(20).fill(0));
        }

        function drawSignatureStrokes(canvas, ctx, strokes, width, height) {
            ctx.clearRect(0, 0, width, height);
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = '#0f0';
            strokes.forEach(stroke => {
                if (stroke.length < 2) return;
                ctx.beginPath();
                stroke.forEach((point, idx) => {
                    const x = (point.x / 280) * width;
                    const y = (point.y / 150) * height;
                    if (idx === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            });
        }

        function renderSignatureGrid(grid) {
            const signatureLayer = document.createElement('div');
            signatureLayer.className = 'signature-layer';
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 20; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'signature-cell';
                    if (grid[row][col] === 1) {
                        cell.classList.add('active');
                    }
                    signatureLayer.appendChild(cell);
                }
            }
            return signatureLayer;
        }

        function submitSignature() {
            if (strokes.length === 0 && currentStroke.length <= 1) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Draw a signature first</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (strokes.reduce((sum, stroke) => sum + stroke.length, 0) + currentStroke.length < 5) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Signature too short</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (currentStroke.length > 1) strokes.push([...currentStroke]);
            const timestamp = Date.now().toString();
            const codesign = generateCodeSign(currentSerial, timestamp);
            const strokeReplica = createStrokeReplica(codesign);
            const fullImage = signCanvas.toDataURL('image/png');
            const miniCanvas = document.createElement('canvas');
            miniCanvas.width = 50;
            miniCanvas.height = 50;
            const miniCtx = miniCanvas.getContext('2d');
            drawSignatureStrokes(miniCanvas, miniCtx, strokes, 50, 50);
            const miniImage = miniCanvas.toDataURL('image/png');
            storeMiniSignature(codesign, miniImage);
            database.push({
                text: `Signed by: ${codesign} (${strokeReplica})`,
                time: new Date(),
                signature: true,
                miniSignature: miniImage,
                fullSignature: fullImage,
                signatureGrid: signatureGrid,
                isFile: false
            });
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Signature added: ${codesign}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            closeSignPopup();
            generateGrid(currentSerial.split(':')[0], { serial: currentSerial, entries: database, code: currentHoloCode });
        }

        function showSignPopup() {
            if (database.some(entry => entry.signature)) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Exoskeleton AI already signed</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            clearSignCanvas();
            signPopup.style.display = 'block';
            signOverlay.style.display = 'block';
        }

        function closeSignPopup() {
            signPopup.style.display = 'none';
            signOverlay.style.display = 'none';
            clearSignCanvas();
        }

        function showUploadPopup() {
            fileInput.value = '';
            uploadPopup.style.display = 'block';
            uploadOverlay.style.display = 'block';
        }

        function closeUploadPopup() {
            uploadPopup.style.display = 'none';
            uploadOverlay.style.display = 'none';
            fileInput.value = '';
        }

        function submitUpload() {
            const file = fileInput.files[0];
            if (!file) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No file selected</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (file.size > MAX_FILE_SIZE) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: File size exceeds 5MB limit</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const base64Data = reader.result.split(',')[1];
                    if (!base64Data) {
                        consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to encode file</div>`;
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        return;
                    }
                    const fileEntry = {
                        text: `File: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`,
                        time: new Date(),
                        signature: false,
                        miniSignature: '',
                        isFile: true,
                        fileName: file.name,
                        fileSize: file.size,
                        fileType: file.type || 'application/octet-stream',
                        fileData: base64Data
                    };
                    if (!ExoskeletonAIAgent.validateFileEntry(fileEntry, database.length)) {
                        consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid file entry format</div>`;
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        return;
                    }
                    database.push(fileEntry);
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Agent: File uploaded: ${file.name}, ${file.size} bytes, index ${database.length - 1}, isFile=${fileEntry.isFile}, hasData=${!!fileEntry.fileData}</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    closeUploadPopup();
                } catch (error) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to process file - ${error.message}</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                }
            };
            reader.onerror = () => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to read file</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            };
            reader.readAsDataURL(file);
        }

        function downloadFile(index) {
            if (isNaN(index) || index < 0 || index >= database.length) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid index ${index}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            const entry = database[index];
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Agent: Checking entry at index ${index}: ${JSON.stringify({ isFile: entry.isFile, fileName: entry.fileName, fileSize: entry.fileSize, hasData: !!entry.fileData, text: entry.text.slice(0, 50)})})</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            if (!entry.isFile) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Entry at index ${index} is not a file</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (entry.text === ':DELETED' || !entry.fileData) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: File at index ${index} has been deleted or is corrupted</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            try {
                const byteCharacters = atob(entry.fileData);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], { type: entry.fileType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = entry.fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>File downloaded: ${entry.fileName}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } catch (error) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to download file - ${error.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        function removeEntry(index) {
            if (isNaN(index) || index < 0 || index >= database.length) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid index ${index}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            database[index].text = ':DELETED';
            if (database[index].isFile) {
                database[index].fileData = '';
            } else if (database[index].signature) {
                database[index].miniSignature = '';
                database[index].fullSignature = '';
                database[index].signatureGrid = [];
            }
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Entry at index ${index} marked as deleted</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function showDataUsage() {
            const { totalSizeKB, fileSizeKB, nonFileSizeKB, remainingSizeKB } = ExoskeletonAIAgent.calculateDataUsage(database);
            consoleDiv.innerHTML += `
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Data Usage for current session:</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Total: ${totalSizeKB.toFixed(2)} KB</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Files (Serial): ${fileSizeKB.toFixed(2)} KB</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Non-Files (Holo Grid): ${nonFileSizeKB.toFixed(2)} KB</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Remaining (Serial): ${remainingSizeKB.toFixed(2)} KB (of 10240 KB)</div>
            `;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function generateImageFromSeed(holoCode, serialBase) {
            hologram.innerHTML = '';
            const seed = hashCode(holoCode + serialBase);
            const rowCount = 4 + Math.floor(seededRandom(seed) * 5); // 4-8 rows
            const colCount = 4 + Math.floor(seededRandom(seed + 1) * 5); // 4-8 cols
            hologram.style.gridTemplateRows = `repeat(${rowCount}, 1fr)`;
            hologram.style.gridTemplateColumns = `repeat(${colCount}, 1fr)`;
            const squareCount = rowCount * colCount;
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Generating grid: ${rowCount}x${colCount}, ${squareCount} squares</div>`;
            for (let i = 0; i < squareCount; i++) {
                if (seededRandom(seed + i) > 0.2) {
                    const square = document.createElement('div');
                    square.className = 'grid-square';
                    const size = 10 + (seededRandom(seed + i + 1) * 20); // 10-30px
                    square.style.width = `${size}px`;
                    square.style.height = `${size}px`;
                    square.style.gridRow = `${Math.floor(i / colCount) + 1}`;
                    square.style.gridColumn = `${(i % colCount) + 1}`;
                    square.style.animationDelay = `${(seededRandom(seed + i + 2) * 2).toFixed(2)}s`;
                    hologram.appendChild(square);
                }
            }
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Grid squares appended</div>`;
            const signatureData = database.find(entry => entry.signature && entry.signatureGrid);
            if (signatureData) {
                const signatureLayer = renderSignatureGrid(signatureData.signatureGrid);
                hologram.appendChild(signatureLayer);
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Signature grid layer added</div>`;
                retrieveMiniSignature(signatureData.text.split('Signed by: ')[1].split(' ')[0]).then(miniImage => {
                    if (miniImage) {
                        const miniSigCanvas = document.createElement('canvas');
                        miniSigCanvas.width = 50;
                        miniSigCanvas.height = 50;
                        miniSigCanvas.style.position = 'absolute';
                        miniSigCanvas.style.top = '10px';
                        miniSigCanvas.style.right = '10px';
                        miniSigCanvas.style.opacity = '0.7';
                        const miniCtx = miniSigCanvas.getContext('2d');
                        const img = new Image();
                        img.src = miniImage;
                        img.onload = () => {
                            miniCtx.drawImage(img, 0, 0, 50, 50);
                            hologram.appendChild(miniSigCanvas);
                            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Mini signature retrieved from IndexedDB and displayed</div>`;
                        };
                    }
                });
            }
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function generateGrid(serialBase, data) {
            if (!serialBase || !data.code) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid serial or holo code for grid generation</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            generateImageFromSeed(data.code, serialBase);
        }

        function displayDatabaseEntries() {
            if (database.length === 0) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>No entries in database</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Database entries:</div>`;
            database.forEach((entry, index) => {
                let displayText = entry.text;
                if (entry.isFile) {
                    displayText = `File: ${entry.fileName} (${(entry.fileSize / 1024).toFixed(2)} KB)`;
                }
                if (entry.text !== ':DELETED') {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>[${index}] ${entry.time.toLocaleString()} - ${displayText}</div>`;
                }
            });
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function initializeGrid() {
            if (!currentSerial) {
                const initSerialBase = `HOLO-${String(serialCounter).padStart(6,'0')}-INIT`;
                const initSerial = `${initSerialBase}:`;
                const initHoloCode = generateHoloGridCode(initSerialBase, []);
                usedSerials.add(initSerialBase);
                currentSerial = initSerial;
                currentHoloCode = initHoloCode;
                database = [];
            }
            generateGrid(currentSerial.split(':')[0], { serial: currentSerial, entries: database, code: currentHoloCode });
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Initial grid initialized</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            const helpText = `
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Available Commands:</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ADD [data] - Add entry to database</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>VIEW - Show all entries</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>CLEAR - Clear console and current session</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>REMOVE [index] - Remove entry at index (e.g., REMOVE 1)</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>GENERATE - Generate grid with encoded database</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HTML - Generate HTML data sheet and copy to clipboard</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SIGN - Sign the current Exoskeleton AI</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>UPLOAD - Upload a file to the database (max 5MB)</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>DOWNLOAD [index] - Download file at index (e.g., DOWNLOAD 5)</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>DATA - Show database storage usage</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HELP - Show this help</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Enter [serial] [holo_code] to load grid (e.g., HOLO-000001-A7K:... GRID: ABCDEFGHI-...)</div>
            `;
            consoleDiv.innerHTML += helpText;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function generateDatabase() {
            if (database.length === 0) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No data to generate</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            const { fileEntries, nonFileEntries } = ExoskeletonAIAgent.organizeData(database);
            const serial = generateSerialNumber(fileEntries);
            if (!serial) return;
            const serialBase = serial.split(':')[0];
            const newHoloCode = generateHoloGridCode(serialBase, nonFileEntries);
            currentSerial = serial;
            currentHoloCode = newHoloCode;
            navigator.clipboard.writeText(`${serial}\n${newHoloCode}`).then(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Serial and holo grid code copied to clipboard!</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }).catch(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to copy serial and code</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            });
            generateGrid(serialBase, { serial, entries: database, code: newHoloCode });
        }

        function loadGridFromSerial(userSerial, userHoloCode) {
            if (!userSerial || !userHoloCode) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Serial and holo grid code required</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            const serialBase = userSerial.split(':')[0];
            if (!serialBase.match(/^HOLO-\d{6}-[A-Z0-9]{3}$/)) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid serial format</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (!userHoloCode.startsWith('GRID: ')) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid holo grid code format</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            const fileEntries = decodeSerialNumber(userSerial);
            const nonFileEntries = decodeHoloGridCode(userHoloCode, serialBase);
            if (fileEntries.length === 0 && nonFileEntries.length === 0) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No valid data decoded from codes</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            database = [...fileEntries, ...nonFileEntries];
            currentSerial = userSerial;
            currentHoloCode = userHoloCode;
            usedSerials.add(serialBase);
            navigator.clipboard.writeText(`${userSerial}\n${userHoloCode}`).then(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Serial and holo grid code copied to clipboard!</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }).catch(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to copy serial and code</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            });
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Grid loaded successfully</div>`;
            displayDatabaseEntries();
            generateGrid(serialBase, { serial: userSerial, entries: database, code: userHoloCode });
        }

        function generateHTMLSheet() {
            if (database.length === 0) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: No data to generate HTML</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            let htmlContent = `
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Exoskeleton AI Data Sheet</title>
                    <style>
                        body { font-family: 'Courier New', monospace; background: #000; color: #0f0; padding: 20px; }
                        table { width: 100%; border-collapse: collapse; }
                        th, td { border: 1px solid #0f0; padding: 8px; text-align: left; }
                        th { background: rgba(0,255,0,0.1); }
                        img.signature { max-width: 100px; vertical-align: middle; }
                        .signature-grid { display: grid; grid-template-columns: repeat(20, 10px); grid-template-rows: repeat(10, 10px); gap: 1px; width: 200px; height: 100px; }
                        .signature-cell { background: rgba(0,255,0,0.8); border: 1px solid #0f0; }
                        .signature-cell.active { background: #0f0; }
                        h1 { text-align: center; text-shadow: 0 0 5px #0f0; }
                    </style>
                </head>
                <body>
                    <h1>Exoskeleton AI Data Sheet</h1>
                    <table>
                        <tr>
                            <th>Index</th>
                            <th>Timestamp</th>
                            <th>Data</th>
                            <th>Type</th>
                        </tr>
            `;
            database.forEach((entry, index) => {
                const type = entry.signature ? 'Signature' : entry.isFile ? 'File' : 'Text';
                let dataDisplay = entry.text;
                if (entry.isFile) {
                    dataDisplay = `File: ${entry.fileName} (${(entry.fileSize / 1024).toFixed(2)} KB)`;
                } else if (entry.signature) {
                    dataDisplay += `<div class="signature-grid">`;
                    for (let row = 0; row < 10; row++) {
                        for (let col = 0; col < 20; col++) {
                            dataDisplay += `<div class="signature-cell ${entry.signatureGrid[row][col] === 1 ? 'active' : ''}"></div>`;
                        }
                    }
                    dataDisplay += `</div>`;
                }
                if (entry.text !== ':DELETED') {
                    htmlContent += `
                        <tr>
                            <td>${index}</td>
                            <td>${entry.time.toLocaleString()}</td>
                            <td>${dataDisplay}</td>
                            <td>${type}</td>
                        </tr>
                    `;
                }
            });
            htmlContent += `
                    </table>
                </body>
                </html>
            `;
            navigator.clipboard.writeText(htmlContent).then(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HTML data sheet copied to clipboard</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }).catch(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Failed to copy HTML data sheet</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            });
        }

        function clearConsole() {
            database = [];
            currentSerial = '';
            currentHoloCode = '';
            usedSerials.clear();
            serialCounter = 1;
            strokes = [];
            signatureGrid = Array(10).fill().map(() => Array(20).fill(0));
            consoleDiv.innerHTML = `
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Exoskeleton AI v1.0 - Holographic Console initialized</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Type 'HELP' for commands</div>
                <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Serials and holo grid codes encode data in memory; persists via codes (use at your own risk.)</div>
            `;
            initializeGrid();
        }

        function executeCommand() {
            const input = commandInput.value.trim();
            commandInput.value = '';
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>> ${input}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            const parts = input.split(' ');
            const command = parts[0].toUpperCase();
            const args = parts.slice(1).join(' ');

            if (command === 'HELP') {
                const helpText = `
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Available Commands:</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ADD [data] - Add entry to database</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>VIEW - Show all entries</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>CLEAR - Clear console and current session</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>REMOVE [index] - Remove entry at index (e.g., REMOVE 1)</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>GENERATE - Generate grid with encoded database</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HTML - Generate HTML data sheet and copy to clipboard</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>SIGN - Sign the current Exoskeleton AI</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>UPLOAD - Upload a file to the database (max 5MB)</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>DOWNLOAD [index] - Download file at index (e.g., DOWNLOAD 5)</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>DATA - Show database storage usage</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>HELP - Show this help</div>
                    <div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Enter [serial] [holo_code] to load grid (e.g., HOLO-000001-A7K:... GRID: ABCDEFGHI-...)</div>
                `;
                consoleDiv.innerHTML += helpText;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } else if (command === 'ADD') {
                if (!args) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Data required for ADD</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                database.push({
                    text: args,
                    time: new Date(),
                    signature: false,
                    miniSignature: '',
                    isFile: false
                });
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>Data added: ${args}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } else if (command === 'VIEW') {
                displayDatabaseEntries();
            } else if (command === 'CLEAR') {
                clearConsole();
            } else if (command === 'REMOVE') {
                const index = parseInt(args, 10);
                if (isNaN(index)) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid index for REMOVE</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                removeEntry(index);
            } else if (command === 'GENERATE') {
                generateDatabase();
            } else if (command === 'HTML') {
                generateHTMLSheet();
            } else if (command === 'SIGN') {
                showSignPopup();
            } else if (command === 'UPLOAD') {
                showUploadPopup();
            } else if (command === 'DOWNLOAD') {
                const index = parseInt(args, 10);
                if (isNaN(index)) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Invalid index for DOWNLOAD</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                downloadFile(index);
            } else if (command === 'DATA') {
                showDataUsage();
            } else if (command.match(/^HOLO-\d{6}-[A-Z0-9]{3}/)) {
                const serial = parts[0] + (parts[1].startsWith(':') ? ':' + parts.slice(1).join(' ').split(' ')[0].slice(1) : '');
                const holoCode = parts.slice(parts[1].startsWith(':') ? 2 : 1).join(' ');
                loadGridFromSerial(serial, holoCode);
            } else {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${getFullTimestamp()}]</span>ERROR: Unknown command '${command}'</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        initializeGrid();
    </script>
</body>
</html>
