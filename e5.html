<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="keywords" content="Exoskeleton AI, holographic database, text storage, file storage, cyberpunk app, WebXOS, secure database">
    <meta name="description" content="Exoskeleton AI: Manage text and file databases with holographic 3D grid visualization, encoded in serials and codes.">
    <title>Exoskeleton AI</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #0f0;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            overscroll-behavior: none;
        }
        .header {
            width: 100%;
            max-width: 320px;
            text-align: center;
            padding: 8px;
            font-size: 16px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
            height: 40px;
            position: fixed;
            top: 0;
            background: rgba(0,0,0,0.8);
            z-index: 20;
        }
        .app-container {
            width: 100%;
            max-width: 320px;
            height: 320px;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 40px;
            margin-bottom: 10px;
        }
        .hologram-container {
            width: 360px;
            height: 320px;
            position: relative;
            overflow: hidden;
        }
        .hologram {
            width: 320px;
            height: 320px;
            position: absolute;
            top: 0;
            left: 20px;
            transform-style: preserve-3d;
            animation: rotateHologram 30s infinite linear;
        }
        .grid-square {
            position: absolute;
            background: rgba(0,255,0,0.6);
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
            animation: pulseSquare 4s infinite;
        }
        .signature-layer {
            position: absolute;
            width: 200px;
            height: 100px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.6;
            z-index: 10;
            filter: drop-shadow(0 0 5px #0f0);
        }
        .signature-layer canvas {
            width: 100%;
            height: 100%;
        }
        .bottom-section {
            width: 100%;
            max-width: 320px;
            position: fixed;
            bottom: 0;
            display: flex;
            flex-direction: column;
            background: rgba(0,0,0,0.8);
            box-shadow: 0 0 10px #0f0;
            z-index: 10;
        }
        .console-section {
            width: 100%;
            max-height: calc(100vh - 40px - 320px - 52px - 20px);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #console {
            width: 100%;
            flex: 1;
            overflow-y: auto;
            touch-action: auto;
            font-size: 14px;
            padding: 8px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
            scroll-behavior: smooth;
            scrollbar-width: thin;
            scrollbar-color: #0f0 rgba(0,0,0,0.8);
        }
        #console::-webkit-scrollbar {
            width: 8px;
            background: rgba(0,0,0,0.8);
        }
        #console::-webkit-scrollbar-thumb {
            background: #0f0;
            border-radius: 4px;
            box-shadow: 0 0 5px #0f0;
        }
        .entry {
            margin: 4px 0;
            word-wrap: break-word;
        }
        .timestamp {
            color: #080;
            margin-right: 8px;
        }
        .input-area {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            width: 100%;
            padding: 8px;
            background: rgba(0,0,0,0.8);
            border-top: 1px solid #0f0;
            min-height: 52px;
        }
        input {
            flex: 1;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            padding: 8px;
            box-shadow: 0 0 5px #0f0;
            min-height: 36px;
            min-width: 100px;
        }
        button {
            background: rgba(0,255,0,0.1);
            color: #0f0;
            border: 2px solid #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            padding: 8px;
            border-radius: 8px;
            min-height: 36px;
            min-width: 70px;
            text-transform: uppercase;
            transition: all 0.2s ease;
            box-shadow: 0 0 8px #0f0;
        }
        button:hover {
            background: #0f0;
            color: #000;
            cursor: pointer;
            box-shadow: 0 0 12px #0f0;
            transform: scale(1.05);
        }
        button:active {
            transform: scale(0.95);
            box-shadow: 0 0 5px #0f0;
        }
        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            padding: 12px;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 1000;
            box-shadow: 0 0 10px #0f0;
        }
        .popup h3 {
            margin: 0 0 10px;
            font-size: 14px;
            text-shadow: 0 0 5px #0f0;
        }
        .popup canvas {
            width: 100%;
            height: 150px;
            background: #000;
            border: 1px solid #0f0;
            margin-bottom: 8px;
        }
        .popup input[type="file"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            font-size: 12px;
        }
        .popup .btn {
            width: 100%;
            margin: 5px 0;
            padding: 8px;
            background: rgba(0,255,0,0.1);
            color: #0f0;
            border: 2px solid #0f0;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 8px #0f0;
            transition: all 0.2s ease;
        }
        .popup .btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 12px #0f0;
        }
        footer {
            width: 100%;
            text-align: center;
            font-size: 10px;
            color: #0f0;
            padding: 4px 0;
            text-shadow: 0 0 3px #0f0;
            height: 20px;
            background: rgba(0,0,0,0.8);
            border-top: 1px solid #0f0;
        }
        @media (max-width: 480px) {
            .header { max-width: 280px; font-size: 14px; height: 36px; }
            .app-container { max-width: 280px; height: 280px; margin-top: 36px; }
            .hologram-container { width: 300px; height: 280px; }
            .hologram { width: 280px; height: 280px; left: 10px; }
            .signature-layer { width: 150px; height: 75px; }
            .console-section { max-height: calc(100vh - 36px - 280px - 48px - 18px); }
            #console { font-size: 12px; }
            .input-area { min-height: 48px; }
            input { font-size: 12px; min-height: 32px; }
            button { font-size: 12px; min-height: 32px; min-width: 60px; }
            .popup { width: 260px; }
            footer { font-size: 9px; height: 18px; }
        }
        @keyframes rotateHologram {
            0% { transform: rotateY(0deg) rotateX(15deg); }
            100% { transform: rotateY(360deg) rotateX(15deg); }
        }
        @keyframes pulseSquare {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <div class="header">Exoskeleton AI</div>
    <div class="app-container">
        <div class="hologram-container">
            <div class="hologram" id="hologram"></div>
        </div>
    </div>
    <div class="bottom-section">
        <div class="console-section">
            <div id="console">
                <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Type 'HELP' for commands</div>
            </div>
        </div>
        <div class="input-area">
            <input type="text" id="commandInput" placeholder="Enter command..." onkeydown="event.key === 'Enter' && executeCommand()">
            <button onclick="executeCommand()">Execute</button>
            <button onclick="clearConsole()">Clear</button>
        </div>
        <footer>WebXOS 2025</footer>
    </div>
    <div class="popup-overlay" id="signOverlay"></div>
    <div class="popup" id="signPopup">
        <h3>Sign Exoskeleton AI</h3>
        <canvas id="signCanvas"></canvas>
        <button class="btn" onclick="submitSignature()">Submit</button>
        <button class="btn" onclick="closeSignPopup()">Cancel</button>
    </div>
    <div class="popup-overlay" id="uploadOverlay"></div>
    <div class="popup" id="uploadPopup">
        <h3>Upload File</h3>
        <p>Max file size: 5MB</p>
        <p id="storageInfo">Checking storage...</p>
        <input type="file" id="fileInput">
        <button class="btn" onclick="submitUpload()">Upload</button>
        <button class="btn" onclick="closeUploadPopup()">Cancel</button>
    </div>
    <script>
        let database = [], currentSerial = '', currentCode = '', serialCounter = 1, serialMap = new Map();
        const hologram = document.getElementById('hologram'), commandInput = document.getElementById('commandInput'),
              consoleDiv = document.getElementById('console'), signCanvas = document.getElementById('signCanvas'),
              signCtx = signCanvas.getContext('2d'), signPopup = document.getElementById('signPopup'),
              signOverlay = document.getElementById('signOverlay'), uploadPopup = document.getElementById('uploadPopup'),
              uploadOverlay = document.getElementById('uploadOverlay'), fileInput = document.getElementById('fileInput'),
              storageInfo = document.getElementById('storageInfo');
        let painting = false, strokes = [], currentStroke = [];
        const DB_NAME = 'ExoskeletonAI', STORE_NAME = 'Files', MAX_FILE_SIZE = 5 * 1024 * 1024, DEFAULT_MAX_DB_SIZE = 50 * 1024 * 1024;

        signCanvas.width = 280; signCanvas.height = 150;
        signCtx.lineWidth = 3; signCtx.lineCap = 'round'; signCtx.lineJoin = 'round'; signCtx.strokeStyle = '#0f0';

        document.addEventListener('touchmove', e => {
            if (!e.target.closest('#console') && !e.target.closest('.popup') && !e.target.closest('.input-area')) {
                e.preventDefault();
            }
        }, { passive: false });

        consoleDiv.addEventListener('touchstart', () => consoleDiv.style.scrollBehavior = 'smooth');

        async function getStorageQuota() {
            try {
                if (navigator.storage?.estimate) {
                    const { quota, usage } = await navigator.storage.estimate();
                    return { total: quota || DEFAULT_MAX_DB_SIZE, used: usage || 0, remaining: (quota || DEFAULT_MAX_DB_SIZE) - (usage || 0) };
                }
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>WARNING: Storage quota not supported. Using ${DEFAULT_MAX_DB_SIZE / (1024 * 1024)} MB</div>`;
                return { total: DEFAULT_MAX_DB_SIZE, used: 0, remaining: DEFAULT_MAX_DB_SIZE };
            } catch (e) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Storage quota failed - ${e.message}</div>`;
                return { total: DEFAULT_MAX_DB_SIZE, used: 0, remaining: DEFAULT_MAX_DB_SIZE };
            }
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        let dbPromise = null;
        function openDB() {
            if (dbPromise) return dbPromise;
            dbPromise = new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onupgradeneeded = e => e.target.result.createObjectStore(STORE_NAME, { keyPath: 'id' });
                request.onsuccess = e => resolve(e.target.result);
                request.onerror = e => {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: IndexedDB failed - ${e.target.error.message}</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    reject(e.target.error);
                };
            });
            return dbPromise;
        }

        function encryptData(data, key) {
            const seed = hashCode(key), result = new Uint8Array(data.length);
            for (let i = 0; i < data.length; i++) result[i] = data[i] ^ ((seed >> (i % 32)) & 0xFF);
            return result;
        }

        function decryptData(data, key) {
            return encryptData(data, key);
        }

        async function storeFile(serial, file, index) {
            try {
                const db = await openDB(), reader = new FileReader();
                return new Promise((resolve, reject) => {
                    reader.onload = async () => {
                        const uint8Array = new Uint8Array(reader.result), encryptedData = encryptData(uint8Array, serial);
                        const transaction = db.transaction([STORE_NAME], 'readwrite'), store = transaction.objectStore(STORE_NAME);
                        const fileData = { id: `${serial}_${index}`, serial, index, name: file.name, type: file.type, size: file.size, data: encryptedData.buffer };
                        const request = store.put(fileData);
                        request.onsuccess = () => resolve(fileData);
                        request.onerror = () => {
                            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Store file failed - ${request.error.message}</div>`;
                            consoleDiv.scrollTop = consoleDiv.scrollHeight;
                            reject(request.error);
                        };
                    };
                    reader.onerror = () => {
                        consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Read file failed</div>`;
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        reject(reader.error);
                    };
                    reader.readAsArrayBuffer(file);
                });
            } catch (e) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Store file failed - ${e.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                throw e;
            }
        }

        async function getFile(serial, index) {
            try {
                const db = await openDB(), transaction = db.transaction([STORE_NAME], 'readonly'), store = transaction.objectStore(STORE_NAME);
                const request = store.get(`${serial}_${index}`);
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        const fileData = request.result;
                        if (fileData?.data) {
                            const encryptedData = new Uint8Array(fileData.data), decryptedData = decryptData(encryptedData, serial);
                            resolve({ ...fileData, data: decryptedData.buffer });
                        } else resolve(null);
                    };
                    request.onerror = () => {
                        consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Retrieve file failed - ${request.error.message}</div>`;
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        reject(request.error);
                    };
                });
            } catch (e) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Retrieve file failed - ${e.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                throw e;
            }
        }

        async function getDatabaseSize(serial) {
            try {
                const db = await openDB(), transaction = db.transaction([STORE_NAME], 'readonly'), store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result.filter(f => f.serial === serial).reduce((sum, f) => sum + f.size, 0));
                    request.onerror = () => {
                        consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Database size failed - ${request.error.message}</div>`;
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        reject(request.error);
                    };
                });
            } catch (e) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Database size failed - ${e.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                throw e;
            }
        }

        async function clearDatabase(serial) {
            try {
                const db = await openDB(), transaction = db.transaction([STORE_NAME], 'readwrite'), store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        const files = request.result.filter(f => f.serial === serial);
                        Promise.all(files.map(f => new Promise((res, rej) => {
                            const delReq = store.delete(f.id);
                            delReq.onsuccess = res;
                            delReq.onerror = () => rej(delReq.error);
                        }))).then(resolve).catch(e => {
                            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Clear database failed - ${e.message}</div>`;
                            consoleDiv.scrollTop = consoleDiv.scrollHeight;
                            reject(e);
                        });
                    };
                    request.onerror = () => {
                        consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Clear database failed - ${request.error.message}</div>`;
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        reject(request.error);
                    };
                });
            } catch (e) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Clear database failed - ${e.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                throw e;
            }
        }

        function hashCode(str, salt = '') {
            let hash = 2166136261;
            for (let i = 0; i < str.length + salt.length; i++) {
                hash ^= (str + salt).charCodeAt(i);
                hash *= 16777619;
            }
            return Math.abs(hash);
        }

        function seededRandom(seed) {
            return Math.sin(seed++) * 10000 - Math.floor(Math.sin(seed++) * 10000);
        }

        function saveState() {
            try {
                localStorage.setItem('exoskeletonAISerialMap', JSON.stringify([...serialMap]));
                localStorage.setItem('exoskeletonAISerialCounter', serialCounter);
            } catch (e) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Save state failed - ${e.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        function loadState() {
            try {
                const savedMap = localStorage.getItem('exoskeletonAISerialMap'), savedCounter = localStorage.getItem('exoskeletonAISerialCounter');
                if (savedMap) serialMap = new Map(JSON.parse(savedMap));
                serialCounter = parseInt(savedCounter) || 1;
                if (serialCounter < 1 || serialCounter > 999999) serialCounter = 1;
                const maxSerial = Math.max(...Array.from(serialMap.keys()).filter(s => s.startsWith('HOLO-')).map(s => parseInt(s.split('-')[1]) || 0), 0);
                if (maxSerial >= serialCounter) serialCounter = maxSerial + 1;
            } catch (e) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Load state failed - ${e.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        function compressDatabase(entries) {
            return JSON.stringify(entries.map(e => ({
                text: e.text, time: e.time.toISOString(), signature: e.signature, miniSignature: e.miniSignature,
                isFile: e.isFile || false, fileName: e.fileName || '', fileSize: e.fileSize || 0, fileType: e.fileType || ''
            })));
        }

        function decompressDatabase(compressed) {
            try {
                return JSON.parse(compressed).map(e => ({
                    text: e.text, time: new Date(e.time), signature: e.signature || false, miniSignature: e.miniSignature || '',
                    isFile: e.isFile || false, fileName: e.fileName || '', fileSize: e.fileSize || 0, fileType: e.fileType || ''
                }));
            } catch (e) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Decompression failed - ${e.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return [];
            }
        }

        async function encodeDatabase(entries, serial) {
            try {
                const compressed = compressDatabase(entries), seed = hashCode(serial);
                let encoded = '';
                for (let i = 0; i < compressed.length; i++) {
                    encoded += String.fromCharCode((compressed.charCodeAt(i) + ((seed >> (i % 32)) & 0xFF)) % 256);
                }
                let fileDataString = '';
                for (let i = 0; i < entries.length; i++) {
                    if (entries[i].isFile) {
                        const fileData = await getFile(serial, i);
                        if (fileData) {
                            const fileMeta = JSON.stringify({ index: i, name: fileData.name, size: fileData.size, type: fileData.type });
                            const fileContent = btoa(String.fromCharCode(...new Uint8Array(fileData.data)));
                            fileDataString += `${fileMeta}|${fileContent};`;
                        }
                    }
                }
                return btoa(`${encoded}|${fileDataString}`);
            } catch (e) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Encoding failed - ${e.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return '';
            }
        }

        async function decodeDatabase(encoded, serial) {
            try {
                const seed = hashCode(serial), combinedData = atob(encoded), [entryData, fileDataString] = combinedData.split('|', 2);
                let decompressed = '';
                for (let i = 0; i < entryData.length; i++) {
                    decompressed += String.fromCharCode((entryData.charCodeAt(i) - ((seed >> (i % 32)) & 0xFF) + 256) % 256);
                }
                const entries = decompressDatabase(decompressed);
                if (fileDataString) {
                    for (const fileEntry of fileDataString.split(';').filter(f => f)) {
                        const [meta, content] = fileEntry.split('|'), fileMeta = JSON.parse(meta);
                        const fileContent = new Uint8Array(atob(content).split('').map(c => c.charCodeAt(0)));
                        await storeFile(serial, new File([encryptData(fileContent, serial)], fileMeta.name, { type: fileMeta.type }), fileMeta.index);
                    }
                }
                return entries;
            } catch (e) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Decoding failed - ${e.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return [];
            }
        }

        function generateRandomSuffix() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let suffix = '';
            for (let i = 0; i < 3; i++) suffix += chars.charAt(Math.floor(seededRandom(hashCode(suffix + i)) * chars.length));
            return suffix.toUpperCase();
        }

        function generateSerialNumber(code) {
            let serial, attempts = 0;
            do {
                if (serialCounter > 999999) serialCounter = 1;
                const paddedNumber = String(serialCounter++).padStart(6, '0');
                serial = `HOLO-${paddedNumber}-${generateRandomSuffix()}`;
                if (++attempts > 1000) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Failed to generate unique serial</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return null;
                }
            } while (serialMap.has(serial));
            serialMap.set(serial, { code, encryptedDatabase: '', strokes: [] });
            saveState();
            return serial;
        }

        function generateCrypticCode(serial) {
            const glyphs = 'ΔΩΨΘΣΦΩΓΛΞΠΩ0123456789#@&%*+-=<>';
            let code = '';
            const seedValue = hashCode(serial + 'CODE');
            for (let i = 0; i < 9; i++) code += glyphs.charAt(Math.floor(seededRandom(seedValue + i) * glyphs.length));
            return `Ω-CODE: ${code}`;
        }

        function generateCodeSign(serial, timestamp) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let sign = '', seedValue = hashCode(serial + timestamp);
            for (let i = 0; i < 8; i++) {
                sign += chars.charAt(Math.floor(seededRandom(seedValue + i) * chars.length));
                if (i === 3) sign += '-';
            }
            return `Ω-SIGN: ${sign}`;
        }

        function createStrokeReplica(codesign) {
            const glyphMap = { 'A': 'Λ', 'B': 'β', 'C': 'C', 'D': 'Δ', 'E': 'Σ', 'F': 'F', 'G': 'Γ', 'H': 'H', 'I': 'I', 'J': 'J', 'K': 'K', 'L': 'L', 'M': 'M', 'N': 'N', 'O': 'O', 'P': 'Π', 'Q': 'Q', 'R': 'R', 'S': 'S', 'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', 'Z': 'Z', '0': '0', '1': '|', '2': '2', '3': '3', '4': '4', '5': '5', '6': '6', '7': '7', '8': '8', '9': '9', '-': '-' };
            return codesign.replace(/./g, c => glyphMap[c] || c);
        }

        function startPainting(e) {
            painting = true;
            const rect = signCanvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            currentStroke = [{ x, y }];
            signCtx.beginPath();
            signCtx.moveTo(x, y);
        }

        function stopPainting() {
            if (painting) {
                painting = false;
                if (currentStroke.length > 1) strokes.push([...currentStroke]);
                currentStroke = [];
                signCtx.beginPath();
            }
        }

        function draw(e) {
            if (!painting) return;
            e.preventDefault();
            const rect = signCanvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            currentStroke.push({ x, y });
            signCtx.lineTo(x, y);
            signCtx.stroke();
            signCtx.beginPath();
            signCtx.moveTo(x, y);
        }

        signCanvas.addEventListener('mousedown', startPainting);
        signCanvas.addEventListener('mouseup', stopPainting);
        signCanvas.addEventListener('mousemove', draw);
        signCanvas.addEventListener('touchstart', startPainting);
        signCanvas.addEventListener('touchend', stopPainting);
        signCanvas.addEventListener('touchmove', draw);
        signCanvas.addEventListener('mouseleave', stopPainting);

        function drawSignatureStrokes(canvas, ctx, strokes, width, height) {
            ctx.clearRect(0, 0, width, height);
            ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.strokeStyle = '#0f0';
            strokes.forEach(stroke => {
                if (stroke.length < 2) return;
                ctx.beginPath();
                stroke.forEach((p, i) => {
                    const x = (p.x / 280) * width, y = (p.y / 150) * height;
                    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                });
                ctx.stroke();
            });
        }

        async function submitSignature() {
            if (strokes.length === 0 && currentStroke.length <= 1) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Draw a signature</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (strokes.reduce((sum, s) => sum + s.length, 0) + currentStroke.length < 5) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Signature too short</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (currentStroke.length > 1) strokes.push([...currentStroke]);
            const codesign = generateCodeSign(currentSerial, Date.now().toString()), strokeReplica = createStrokeReplica(codesign);
            const fullImage = signCanvas.toDataURL('image/png'), miniCanvas = document.createElement('canvas');
            miniCanvas.width = 50; miniCanvas.height = 50;
            drawSignatureStrokes(miniCanvas, miniCanvas.getContext('2d'), strokes, 50, 50);
            const miniImage = miniCanvas.toDataURL('image/png');
            database.push({ text: `Signed by: ${fullImage} ${codesign} (${strokeReplica})`, time: new Date(), signature: true, miniSignature: miniImage });
            serialMap.get(currentSerial).strokes = strokes;
            saveState();
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Signature added: ${codesign}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            closeSignPopup();
            const encodedData = await encodeDatabase(database, currentSerial);
            serialMap.set(currentSerial, { code: currentCode, encryptedDatabase: encodedData, strokes });
            saveState();
            generateGrid(currentSerial, { serial: currentSerial, entries: database, code: currentCode }, encodedData);
        }

        function showSignPopup() {
            if (database.some(e => e.signature)) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Already signed</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            signCtx.clearRect(0, 0, signCanvas.width, signCanvas.height);
            strokes = []; currentStroke = []; painting = false; signCtx.beginPath();
            signPopup.style.display = 'block';
            signOverlay.style.display = 'block';
        }

        function closeSignPopup() {
            signPopup.style.display = 'none';
            signOverlay.style.display = 'none';
            signCtx.clearRect(0, 0, signCanvas.width, signCanvas.height);
            strokes = []; currentStroke = []; painting = false; signCtx.beginPath();
        }

        async function showUploadPopup() {
            fileInput.value = '';
            try {
                const quota = await getStorageQuota(), browser = navigator.userAgent;
                const browserName = browser.includes('Chrome') ? 'Chrome' : browser.includes('Firefox') ? 'Firefox' : browser.includes('Safari') ? 'Safari' : 'browser';
                const localSize = await getDatabaseSize(currentSerial);
                storageInfo.textContent = `${browserName}: ${(quota.total / (1024 * 1024)).toFixed(2)} MB, ${(quota.remaining / (1024 * 1024)).toFixed(2)} MB free (${(localSize / (1024 * 1024)).toFixed(2)} MB used).`;
                uploadPopup.style.display = 'block';
                uploadOverlay.style.display = 'block';
            } catch (e) {
                storageInfo.textContent = `ERROR: Storage check failed. Using ${DEFAULT_MAX_DB_SIZE / (1024 * 1024)} MB.`;
                uploadPopup.style.display = 'block';
                uploadOverlay.style.display = 'block';
            }
        }

        function closeUploadPopup() {
            uploadPopup.style.display = 'none';
            uploadOverlay.style.display = 'none';
            fileInput.value = '';
        }

        async function submitUpload() {
            const file = fileInput.files[0];
            if (!file) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: No file selected</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (file.size > MAX_FILE_SIZE) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: File exceeds 5MB</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            try {
                const quota = await getStorageQuota(), localSize = await getDatabaseSize(currentSerial);
                if (localSize + file.size > quota.remaining) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Insufficient storage</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                const index = database.length;
                await storeFile(currentSerial, file, index);
                database.push({ text: `File: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`, time: new Date(), signature: false, miniSignature: '', isFile: true, fileName: file.name, fileSize: file.size, fileType: file.type });
                const encodedData = await encodeDatabase(database, currentSerial);
                serialMap.set(currentSerial, { code: currentCode, encryptedDatabase: encodedData, strokes: serialMap.get(currentSerial).strokes });
                saveState();
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>File uploaded: ${file.name} (${(file.size / 1024).toFixed(2)} KB)</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                closeUploadPopup();
                generateGrid(currentSerial, { serial: currentSerial, entries: database, code: currentCode }, encodedData);
            } catch (e) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Upload failed - ${e.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        async function downloadFile(index) {
            if (isNaN(index) || index < 0 || index >= database.length) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Invalid index ${index}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            const entry = database[index];
            if (!entry.isFile) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Not a file at index ${index}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            try {
                const fileData = await getFile(currentSerial, index);
                if (!fileData) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: File not found</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                const blob = new Blob([fileData.data], { type: fileData.type }), url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = fileData.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>File downloaded: ${fileData.name}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } catch (e) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Download failed - ${e.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        async function showDatabaseStats() {
            try {
                const quota = await getStorageQuota(), localSize = await getDatabaseSize(currentSerial), browser = navigator.userAgent;
                const browserName = browser.includes('Chrome') ? 'Chrome' : browser.includes('Firefox') ? 'Firefox' : browser.includes('Safari') ? 'Safari' : 'browser';
                consoleDiv.innerHTML += `
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Database Stats:</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>${browserName}: ${(quota.total / (1024 * 1024)).toFixed(2)} MB</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Used: ${(quota.used / (1024 * 1024)).toFixed(2)} MB</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Database: ${(localSize / (1024 * 1024)).toFixed(2)} MB</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Remaining: ${(quota.remaining / (1024 * 1024)).toFixed(2)} MB</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } catch (e) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Stats failed - ${e.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        async function generateDatabase() {
            if (!database.length) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: No data to generate</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            let newCode;
            do { newCode = generateCrypticCode('TEMP' + serialCounter + database.length); } while (Array.from(serialMap.values()).some(d => d.code === newCode));
            const serial = generateSerialNumber(newCode);
            if (!serial) return;
            const encodedData = await encodeDatabase(database, serial);
            if (!encodedData) return;
            serialMap.set(serial, { code: newCode, encryptedDatabase: encodedData, strokes: serialMap.get(currentSerial).strokes });
            saveState();
            currentSerial = serial; currentCode = newCode;
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Grid generated: ${serial} | ${newCode}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            navigator.clipboard.writeText(`${serial}\n${newCode}`).then(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Copied to clipboard</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }).catch(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Copy failed</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            });
            generateGrid(serial, { serial, entries: database, code: newCode }, encodedData);
        }

        async function loadGridFromSerial(userSerial, userCode) {
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Loading: ${userSerial} | ${userCode}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            if (!userSerial || !userCode) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Serial/code required</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            const serialMatch = userSerial.match(/^HOLO-\d{6}-[A-Z0-9]{3}$/), validSerial = serialMatch ? serialMatch[0] : null;
            if (!validSerial) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Invalid serial (HOLO-XXXXXX-XXX)</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            const codeMatch = userCode.match(/^Ω-CODE: [ΔΩΨΘΣΦΩΓΛΞΠΩ0123456789#@&%*+=\-<>]{9}$/), validCode = codeMatch ? codeMatch[0] : null;
            if (!validCode) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Invalid code (Ω-CODE: XXXXXXXXX)</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (serialMap.has(validSerial)) {
                const { code, encryptedDatabase, strokes } = serialMap.get(validSerial);
                if (code !== validCode) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Invalid code for ${validSerial}</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                    return;
                }
                database = encryptedDatabase ? await decodeDatabase(encryptedDatabase, validSerial) : [];
                currentSerial = validSerial; currentCode = validCode;
                for (let i = 0; i < database.length; i++) {
                    if (database[i].isFile && !(await getFile(validSerial, i))) {
                        consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>WARNING: File at ${i} (${database[i].fileName}) missing</div>`;
                        database[i].isFile = false; database[i].fileName = `[MISSING] ${database[i].fileName}`;
                    }
                }
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Grid loaded: ${validSerial} | ${validCode}</div>`;
                displayEntries(database, `Loaded contents:`);
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                generateGrid(validSerial, { serial: validSerial, entries: database, code: validCode }, encryptedDatabase);
            } else {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Serial ${validSerial} not found</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        function addToDatabase(data) {
            if (!data.trim()) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: No data</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            database.push({ text: data, time: new Date(), signature: false, miniSignature: '', isFile: false });
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Added: ${data}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function replaceInDatabase(index, data) {
            if (isNaN(index) || index < 0 || index >= database.length) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Invalid index ${index}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (!data.trim()) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: No data</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            if (database[index].signature || database[index].isFile) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Cannot replace signature/file</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            database[index] = { text: data, time: new Date(), signature: false, miniSignature: '', isFile: false };
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Replaced [${index}]: ${data}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function generateHTML() {
            if (!database.length) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: No data for HTML</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            let listContent = 'Exoskeleton AI Data Sheet\n------------------\n';
            database.forEach((e, i) => {
                const time = e.time.toLocaleTimeString(), date = e.time.toISOString().split('T')[0];
                const text = e.signature ? `<img src="${e.text.split(' ')[2]}" alt="Signature" width="100">` : e.isFile ? `File: ${e.fileName} (${(e.fileSize / 1024).toFixed(2)} KB)` : e.text;
                listContent += `${i}. Time: ${time} Date: ${date} Data: ${text}\n`;
            });
            const htmlContent = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exoskeleton AI Data Sheet</title>
    <style>
        body { background: #000; color: #0f0; font-family: 'Courier New', monospace; margin: 20px; display: flex; flex-direction: column; align-items: center; }
        pre { font-size: 14px; white-space: pre-wrap; word-wrap: break-word; max-width: 800px; text-align: left; }
        h1 { font-size: 20px; text-align: center; margin-bottom: 10px; text-shadow: 0 0 5px #0f0; }
        img { vertical-align: middle; }
    </style>
</head>
<body>
    <h1>WebXOS 2025 Exoskeleton AI</h1>
    <pre>${listContent}</pre>
</body>
</html>`;
            navigator.clipboard.writeText(htmlContent).then(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>HTML copied</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }).catch(() => {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: HTML copy failed</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            });
        }

        function displayEntries(entries, header = 'Database contents:') {
            let output = `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>${header}</div>`;
            if (!entries.length) output += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>No entries</div>`;
            else entries.forEach((e, i) => {
                const text = e.signature ? `<img src="${e.miniSignature}" alt="Signature" width="50"> ${e.text.split(' ').slice(3).join(' ')}` : e.isFile ? `File: ${e.fileName} (${(e.fileSize / 1024).toFixed(2)} KB)` : e.text;
                output += `<div class="entry"><span class="timestamp">[${e.time.toLocaleString()}]</span>[${i}] ${text}</div>`;
            });
            consoleDiv.innerHTML += output;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function sortEntries(method) {
            const sorted = [...database];
            if (method === 'time-asc') sorted.sort((a, b) => a.time - b.time);
            else if (method === 'time-desc') sorted.sort((a, b) => b.time - a.time);
            else if (method === 'alpha-asc') sorted.sort((a, b) => a.text.localeCompare(b.text));
            else if (method === 'alpha-desc') sorted.sort((a, b) => b.text.localeCompare(a.text));
            database = sorted;
            displayEntries(database, 'Sorted database:');
        }

        async function generateGrid(serial, dbData, encodedData) {
            currentSerial = serial; currentCode = dbData.code;
            await clearDatabase(serial);
            for (let i = 0; i < dbData.entries.length; i++) {
                if (dbData.entries[i].isFile) {
                    const fileData = await getFile(serial, i);
                    if (fileData) await storeFile(serial, new File([fileData.data], fileData.name, { type: fileData.type }), i);
                }
            }
            serialMap.set(serial, { code: dbData.code, encryptedDatabase: encodedData, strokes: serialMap.get(serial).strokes });
            saveState();
            hologram.innerHTML = '';
            const hash = hashCode(serial + encodedData);
            let seedValue = hash;
            const rand = (min, max) => { seedValue = hashCode(String(seedValue)); return min + (seedValue % (max - min + 1)); };
            const randFloat = (min, max) => { seedValue = hashCode(String(seedValue)); return min + ((seedValue % 10000) / 10000) * (max - min); };
            const scale = 0.82;
            for (let i = 0; i < rand(20, 50); i++) {
                const square = document.createElement('div');
                square.className = 'grid-square';
                const size = randFloat(30, 80) * scale;
                square.style.width = `${size}px`;
                square.style.height = `${size}px`;
                square.style.left = `${randFloat(0, 320 - size) * scale}px`;
                square.style.top = `${randFloat(0, 320 - size) * scale}px`;
                square.style.transform = `translateZ(${randFloat(-100, 100) * scale}px) rotateX(${randFloat(-30, 30)}deg) rotateY(${randFloat(-30, 30)}deg)`;
                square.style.opacity = randFloat(0.4, 0.8);
                square.style.background = `rgba(0,${rand(192, 255)},0,${randFloat(0.5, 0.8)})`;
                hologram.appendChild(square);
            }
            const strokes = serialMap.get(serial)?.strokes || [];
            if (strokes.length) {
                const sigLayer = document.createElement('div');
                sigLayer.className = 'signature-layer';
                const sigCanvas = document.createElement('canvas');
                sigCanvas.width = 200; sigCanvas.height = 100;
                drawSignatureStrokes(sigCanvas, sigCanvas.getContext('2d'), strokes, 200, 100);
                sigLayer.appendChild(sigCanvas);
                hologram.appendChild(sigLayer);
            }
        }

        async function clearConsole() {
            try {
                await clearDatabase(currentSerial);
                database = []; currentSerial = ''; currentCode = '';
                consoleDiv.innerHTML = `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Console cleared</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                initializeGrid();
            } catch (e) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Clear failed - ${e.message}</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
        }

        function executeCommand() {
            const input = commandInput.value.trim();
            commandInput.value = '';
            if (!input) {
                consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Enter command</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
                return;
            }
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Command: ${input}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            const inputUpper = input.toUpperCase();
            if (inputUpper === 'HELP') {
                consoleDiv.innerHTML += `
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Commands:</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ADD [data] - Add entry</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>VIEW - Show entries</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>CLEAR - Clear console</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>SORT TIME-ASC - Sort by time ascending</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>SORT TIME-DESC - Sort by time descending</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>SORT ALPHA-ASC - Sort alphabetically ascending</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>SORT ALPHA-DESC - Sort alphabetically descending</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>REPLACE# [data] - Replace at index #</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>GENERATE - Generate grid</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>HTML - Copy HTML data sheet</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>SIGN - Sign grid</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>UPLOAD - Upload file (max 5MB)</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>DOWNLOAD [index] - Download file</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>DATA - Show storage usage</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>HELP - Show this</div>
                    <div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>[serial] [code] - Load grid (e.g., HOLO-000001-A7K Ω-CODE: ---111---)</div>`;
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } else if (inputUpper === 'SIGN') showSignPopup();
            else if (inputUpper === 'UPLOAD') showUploadPopup();
            else if (inputUpper.startsWith('DOWNLOAD ')) {
                const index = parseInt(input.substring(9));
                if (isNaN(index)) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Invalid index</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                } else downloadFile(index);
            } else if (inputUpper === 'DATA') showDatabaseStats();
            else if (inputUpper.startsWith('ADD ')) addToDatabase(input.substring(4));
            else if (inputUpper.startsWith('REPLACE')) {
                const match = inputUpper.match(/^REPLACE(\d+)\s+(.+)$/);
                if (!match) {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Use REPLACE# [data]</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                } else replaceInDatabase(parseInt(match[1]), match[2]);
            } else if (inputUpper === 'VIEW') displayEntries(database);
            else if (inputUpper === 'CLEAR') clearConsole();
            else if (inputUpper === 'SORT TIME-ASC') sortEntries('time-asc');
            else if (inputUpper === 'SORT TIME-DESC') sortEntries('time-desc');
            else if (inputUpper === 'SORT ALPHA-ASC') sortEntries('alpha-asc');
            else if (inputUpper === 'SORT ALPHA-DESC') sortEntries('alpha-desc');
            else if (inputUpper === 'GENERATE') generateDatabase();
            else if (inputUpper === 'HTML') generateHTML();
            else {
                const match = input.trim().match(/^(\S+)\s+(.+)$/);
                if (match) loadGridFromSerial(match[1], match[2]);
                else {
                    consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>ERROR: Unknown command</div>`;
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                }
            }
        }

        function initializeGrid() {
            loadState();
            const initCode = generateCrypticCode('INIT' + serialCounter), initSerial = `HOLO-${String(serialCounter).padStart(6, '0')}-INIT`;
            if (!serialMap.has(initSerial)) {
                serialMap.set(initSerial, { code: initCode, encryptedDatabase: '', strokes: [] });
                saveState();
            }
            currentSerial = initSerial; currentCode = initCode; database = [];
            generateGrid(initSerial, { serial: initSerial, entries: [], code: initCode }, '');
            consoleDiv.innerHTML += `<div class="entry"><span class="timestamp">[${new Date().toLocaleString()}]</span>Grid: ${initSerial} | ${initCode}</div>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        initializeGrid();
    </script>
</body>
</html>
