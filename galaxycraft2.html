<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Galaxycraft v2.0 Lite Cyber Edition</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: monospace;
    }
    body {
      background: #000;
      color: #00ff00;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
      -webkit-tap-highlight-color: transparent;
    }
    #cosmicCanvas {
      flex: 1;
      width: 100%;
      touch-action: none;
      background: #000;
    }
    .controls {
      position: fixed;
      bottom: 5px;
      left: 5px;
      right: 5px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      z-index: 10;
    }
    button {
      background: #000;
      border: 1px solid #00ff00;
      color: #00ff00;
      padding: 6px;
      font-size: 10px;
      cursor: pointer;
      min-width: 50px;
      box-shadow: 0 0 5px #00ff00;
    }
    button.active {
      background: #00ff00;
      color: #000;
    }
    button:active {
      transform: scale(0.95);
    }
    #console {
      position: fixed;
      bottom: 50px;
      width: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10;
      padding: 4px;
    }
    #consoleInput {
      width: 100%;
      background: transparent;
      border: 1px solid #00ff00;
      color: #00ff00;
      font-size: 10px;
      padding: 4px;
      outline: none;
    }
    #prompt {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.5);
      padding: 4px 8px;
      font-size: 10px;
      color: #00ff00;
      border: 1px solid #00ff00;
      opacity: 0;
      transition: opacity 0.3s;
    }
    #prompt.active {
      opacity: 1;
    }
    #status {
      position: fixed;
      top: 0;
      left: 0;
      font-size: 8px;
      color: #00ff00;
      padding: 2px;
      background: rgba(0, 0, 0, 0.5);
    }
    .checkpoint-text {
      position: fixed;
      color: #00ff00;
      font-size: 16px;
      text-shadow: 0 0 5px #00ff00;
      pointer-events: none;
      z-index: 10;
    }
    @media (max-width: 600px) {
      button {
        font-size: 8px;
        padding: 4px;
        min-width: 40px;
      }
      #consoleInput {
        font-size: 8px;
        padding: 3px;
      }
      #prompt {
        font-size: 8px;
        padding: 3px 6px;
      }
      #status {
        font-size: 7px;
      }
      .checkpoint-text {
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <div id="cosmicCanvas"></div>
  <div id="status"></div>
  <div id="prompt"></div>
  <div id="console">
    <input id="consoleInput" type="text" placeholder="/help for commands">
  </div>
  <div class="controls">
    <button id="throttleBtn">Thrust</button>
    <button id="addComet" class="craft-only">Comet</button>
    <button id="addSystem" class="craft-only">System</button>
    <button id="addGalaxy" class="craft-only">Galaxy</button>
    <button id="addNode" class="craft-only">Node</button>
    <button id="autopilotBtn">Auto</button>
    <button id="shootBtn" class="craft-only">Shoot</button>
    <button id="resetBtn">Reset</button>
    <button id="modeBtn">Mode</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    try {
      // Scene setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 3000);
      const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'low-power' });
      renderer.setPixelRatio(/Mobi|Android|iPhone/i.test(navigator.userAgent) ? 0.5 : 1);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000);
      document.getElementById('cosmicCanvas').appendChild(renderer.domElement);
      camera.position.set(0, 0, 0);

      // Starship (static neon green wireframe)
      const shipMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
      const shipGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, -15), new THREE.Vector3(-8, -4, 0),
        new THREE.Vector3(-8, -4, 0), new THREE.Vector3(8, -4, 0),
        new THREE.Vector3(8, -4, 0), new THREE.Vector3(0, 0, -15),
        new THREE.Vector3(0, 4, 0), new THREE.Vector3(0, 0, -15)
      ]);
      const starship = new THREE.LineSegments(shipGeometry, shipMaterial);
      starship.position.set(0, -2, -8);
      camera.add(starship);
      scene.add(camera);

      // Shared resources
      const greenMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
      const geometries = {
        comet: new THREE.SphereGeometry(5, 6, 6),
        star: new THREE.SphereGeometry(80, 6, 6),
        planet: new THREE.SphereGeometry(15, 6, 6),
        galaxyStar: new THREE.SphereGeometry(8, 6, 6),
        projectile: new THREE.SphereGeometry(3, 6, 6),
        node: new THREE.BoxGeometry(8, 8, 8),
        checkpoint: new THREE.BoxGeometry(40, 40, 40)
      };

      // Entities
      let entities = [];
      let nodeLines = [];
      let checkpointTexts = [];
      let throttle = 0;
      let rotation = { pitch: 0, yaw: 0 };
      let rotationVelocity = { pitch: 0, yaw: 0 };
      let velocity = new THREE.Vector3();
      let gameMode = 'craft';
      let autopilot = false;
      let currentNode = 0;
      let checkpointProgress = 0;
      let entityCount = 0;
      let fps = 60;
      let lastTime = performance.now();
      let frameCount = 0;
      let fpsCheckTime = lastTime;

      // Object pool
      const pool = [];
      function getMesh(type) {
        const mesh = pool.find(m => !m.visible && m.userData.type === type) || new THREE.Mesh(geometries[type], greenMaterial);
        mesh.visible = true;
        mesh.userData.type = type;
        return mesh;
      }

      // Simplified WebXOS
      function encodeState() {
        const state = {
          mode: gameMode,
          pos: camera.position.toArray(),
          entities: entities.map(e => ({
            type: e.userData.type,
            pos: e.position.toArray(),
            vel: e.userData.velocity?.toArray() || [0, 0, 0]
          })),
          progress: checkpointProgress
        };
        return btoa(JSON.stringify(state)).slice(0, 50);
      }
      function decodeState(code) {
        try {
          return JSON.parse(atob(code));
        } catch {
          return null;
        }
      }

      // Console
      const consoleInput = document.getElementById('consoleInput');
      const status = document.getElementById('status');
      function log(message) {
        consoleInput.placeholder = message.slice(0, 20);
      }
      function updateStatus() {
        status.textContent = `Mode: ${gameMode} | Entities: ${entityCount} | FPS: ${Math.round(fps)}`;
      }

      // Commands
      function handleCommand(cmd) {
        cmd = cmd.trim().toLowerCase().slice(1);
        if (!cmd) return;
        const [command, arg] = cmd.split(' ');
        if (gameMode === 'explore' && ['add', 'shoot'].includes(command)) {
          log('Command unavailable in Explore');
          return;
        }
        switch (command) {
          case 'help':
            log(gameMode === 'craft' ? '/add comet|system|galaxy|node, /shoot, /reset, /throttle, /autopilot' : '/reset, /throttle, /autopilot');
            break;
          case 'add':
            if (arg === 'comet') addEntity('comet');
            else if (arg === 'system') addEntity('system');
            else if (arg === 'galaxy') addEntity('galaxy');
            else if (arg === 'node') addEntity('node');
            else log('Use: /add comet|system|galaxy|node');
            break;
          case 'shoot':
            addEntity('projectile');
            break;
          case 'reset':
            reset();
            break;
          case 'throttle':
            toggleThrottle();
            break;
          case 'autopilot':
            toggleAutopilot();
            break;
          case 'save':
            const code = encodeState();
            log(`Saved: ${code}`);
            showPrompt(`Code: ${code}`);
            break;
          case 'load':
            const state = decodeState(arg);
            if (state) loadState(state);
            else log('Invalid code');
            break;
          default:
            log('Unknown command');
        }
      }
      consoleInput.addEventListener('keydown', e => {
        if (e.key === 'Enter' && consoleInput.value.startsWith('/')) {
          handleCommand(consoleInput.value);
          consoleInput.value = '';
        }
      });

      // Entity management
      function addEntity(type) {
        if (entityCount >= 300) {
          showPrompt('Entity limit reached');
          return;
        }
        const mesh = getMesh(type);
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        mesh.position.copy(camera.position).add(forward.multiplyScalar(type === 'projectile' ? 10 : 500));
        mesh.userData = {
          type,
          velocity: type === 'projectile' ? forward.multiplyScalar(30) : new THREE.Vector3((Math.random() - 0.5) * 7.5, (Math.random() - 0.5) * 7.5, (Math.random() - 0.5) * 7.5),
          created: Date.now()
        };
        if (type === 'system') mesh.userData.mass = 1000;
        else if (type === 'galaxy') mesh.userData.mass = 50;
        else if (type === 'comet') mesh.userData.mass = 1;
        scene.add(mesh);
        entities.push(mesh);
        entityCount++;
        if (type === 'node' && entities.filter(e => e.userData.type === 'node').length > 1) {
          const nodes = entities.filter(e => e.userData.type === 'node');
          const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([nodes[nodes.length - 2].position, mesh.position]), lineMaterial);
          scene.add(line);
          nodeLines.push(line);
        }
        showPrompt(`${type.charAt(0).toUpperCase() + type.slice(1)} added`);
        log(`${type} added`);
        updateStatus();
      }

      function loadState(state) {
        reset();
        gameMode = state.mode;
        document.getElementById('modeBtn').textContent = gameMode === 'craft' ? 'Explore' : 'Craft';
        camera.position.fromArray(state.pos);
        state.entities.forEach(e => {
          if (entityCount >= 300) return;
          const mesh = getMesh(e.type);
          mesh.position.fromArray(e.pos);
          mesh.userData = {
            type: e.type,
            velocity: new THREE.Vector3().fromArray(e.vel),
            created: Date.now(),
            mass: e.type === 'system' ? 1000 : e.type === 'galaxy' ? 50 : e.type === 'comet' ? 1 : 0
          };
          scene.add(mesh);
          entities.push(mesh);
          entityCount++;
        });
        const nodes = entities.filter(e => e.userData.type === 'node');
        for (let i = 1; i < nodes.length; i++) {
          const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([nodes[i - 1].position, nodes[i].position]), lineMaterial);
          scene.add(line);
          nodeLines.push(line);
        }
        checkpointProgress = state.progress || 0;
        if (gameMode === 'explore') initExplore();
        updateControls();
        log('State loaded');
        updateStatus();
      }

      function reset() {
        entities.forEach(e => {
          e.visible = false;
          pool.push(e);
          scene.remove(e);
        });
        nodeLines.forEach(l => scene.remove(l));
        checkpointTexts.forEach(t => document.body.removeChild(t));
        entities = [];
        nodeLines = [];
        checkpointTexts = [];
        entityCount = 0;
        throttle = 0;
        autopilot = false;
        currentNode = 0;
        checkpointProgress = 0;
        document.getElementById('throttleBtn').classList.remove('active');
        document.getElementById('autopilotBtn').classList.remove('active');
        showPrompt('Reset complete');
        log('Galaxy reset');
        updateStatus();
      }

      function initExplore() {
        for (let i = 0; i < 10; i++) {
          if (entityCount >= 300) break;
          const mesh = getMesh('checkpoint');
          mesh.position.set(0, 0, i * 1000);
          mesh.userData = { type: 'checkpoint', created: Date.now(), index: i };
          scene.add(mesh);
          entities.push(mesh);
          entityCount++;
        }
        for (let i = 0; i < 50; i++) {
          if (entityCount >= 300) break;
          const mesh = getMesh('node');
          mesh.position.set((Math.random() - 0.5) * 1000, (Math.random() - 0.5) * 1000, Math.random() * 10000);
          mesh.userData = { type: 'node', created: Date.now() };
          scene.add(mesh);
          entities.push(mesh);
          entityCount++;
        }
        const nodes = entities.filter(e => e.userData.type === 'node');
        for (let i = 1; i < nodes.length; i++) {
          const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([nodes[i - 1].position, nodes[i].position]), lineMaterial);
          scene.add(line);
          nodeLines.push(line);
        }
        log('Explore mode ready');
      }

      // Controls
      function toggleThrottle() {
        if (autopilot) return;
        throttle = throttle === 0 ? 200 : 0;
        document.getElementById('throttleBtn').classList.toggle('active', throttle > 0);
        showPrompt(throttle > 0 ? 'Thrust on' : 'Thrust off');
        log(throttle > 0 ? 'Thrust engaged' : 'Thrust off');
        updateStatus();
      }
      function toggleAutopilot() {
        const targets = gameMode === 'explore' ? entities.filter(e => e.userData.type === 'checkpoint') : entities.filter(e => e.userData.type === 'node');
        if (targets.length < 2) {
          showPrompt('Need 2+ nodes');
          log('Need 2+ nodes');
          return;
        }
        autopilot = !autopilot;
        if (autopilot) throttle = 0;
        document.getElementById('autopilotBtn').classList.toggle('active', autopilot);
        document.getElementById('throttleBtn').classList.remove('active');
        currentNode = 0;
        showPrompt(autopilot ? 'Autopilot on' : 'Autopilot off');
        log(autopilot ? 'Autopilot on' : 'Autopilot off');
        updateStatus();
      }
      function toggleMode() {
        gameMode = gameMode === 'craft' ? 'explore' : 'craft';
        document.getElementById('modeBtn').textContent = gameMode === 'craft' ? 'Explore' : 'Craft';
        reset();
        if (gameMode === 'explore') initExplore();
        updateControls();
        showPrompt(`Mode: ${gameMode}`);
        log(`Switched to ${gameMode}`);
      }
      function updateControls() {
        document.querySelectorAll('.craft-only').forEach(b => {
          b.style.display = gameMode === 'craft' ? 'inline-block' : 'none';
        });
      }

      // Input
      let isDragging = false;
      let prevTouch = { x: 0, y: 0 };
      renderer.domElement.addEventListener('mousedown', e => {
        if (!autopilot) {
          isDragging = true;
          prevTouch = { x: e.clientX, y: e.clientY };
        }
      });
      renderer.domElement.addEventListener('mousemove', e => {
        if (isDragging && !autopilot) {
          rotationVelocity.yaw -= (e.clientX - prevTouch.x) * 0.02;
          rotationVelocity.pitch -= (e.clientY - prevTouch.y) * 0.02;
          prevTouch = { x: e.clientX, y: e.clientY };
        }
      });
      renderer.domElement.addEventListener('mouseup', () => {
        isDragging = false;
      });
      renderer.domElement.addEventListener('touchstart', e => {
        if (!autopilot) {
          e.preventDefault();
          prevTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
      });
      renderer.domElement.addEventListener('touchmove', e => {
        if (!autopilot) {
          e.preventDefault();
          const deltaX = e.touches[0].clientX - prevTouch.x;
          const deltaY = e.touches[0].clientY - prevTouch.y;
          rotationVelocity.yaw -= deltaX * 0.02;
          rotationVelocity.pitch -= deltaY * 0.02;
          prevTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
      });

      const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
      window.addEventListener('keydown', e => {
        if (e.key in keys) {
          keys[e.key] = true;
          e.preventDefault();
        }
      });
      window.addEventListener('keyup', e => {
        if (e.key in keys) keys[e.key] = false;
      });

      // Prompt
      const prompt = document.getElementById('prompt');
      function showPrompt(text) {
        prompt.textContent = text;
        prompt.classList.add('active');
        setTimeout(() => prompt.classList.remove('active'), 1000);
      }

      // FPS-based entity limit
      function limitEntities() {
        if (fps < 25 && entityCount > 100) {
          const toRemove = entities.filter(e => e.userData.type !== 'checkpoint' && e.userData.type !== 'node').sort((a, b) => a.userData.created - b.userData.created).slice(0, Math.min(10, entityCount - 100));
          toRemove.forEach(e => {
            e.visible = false;
            pool.push(e);
            scene.remove(e);
            entities = entities.filter(ent => ent !== e);
            entityCount--;
          });
          log('Entities reduced for FPS');
          updateStatus();
        }
      }

      // Animation loop
      let isActive = true;
      function animate() {
        if (!isActive) return;
        requestAnimationFrame(animate);
        const now = performance.now();
        const deltaTime = Math.min((now - lastTime) / 1000, 0.05);
        lastTime = now;

        // FPS tracking
        frameCount++;
        if (now - fpsCheckTime > 5000) {
          fps = frameCount / ((now - fpsCheckTime) / 1000);
          frameCount = 0;
          fpsCheckTime = now;
          limitEntities();
        }

        // Rotation
        if (!autopilot) {
          if (keys.ArrowLeft) rotationVelocity.yaw += 0.1;
          if (keys.ArrowRight) rotationVelocity.yaw -= 0.1;
          if (keys.ArrowUp) rotationVelocity.pitch -= 0.1;
          if (keys.ArrowDown) rotationVelocity.pitch += 0.1;
          rotation.pitch += rotationVelocity.pitch * deltaTime;
          rotation.yaw += rotationVelocity.yaw * deltaTime;
          rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.pitch));
          rotationVelocity.pitch *= 0.9;
          rotationVelocity.yaw *= 0.9;
          camera.quaternion.setFromEuler(new THREE.Euler(rotation.pitch, rotation.yaw, 0, 'YXZ'));
        }

        // Movement
        if (!autopilot) {
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          velocity.copy(forward.multiplyScalar(throttle));
          camera.position.add(velocity.multiplyScalar(deltaTime));
        } else {
          const targets = gameMode === 'explore' ? entities.filter(e => e.userData.type === 'checkpoint') : entities.filter(e => e.userData.type === 'node');
          if (targets.length === 0) return;
          const target = targets[currentNode];
          const dir = target.position.clone().sub(camera.position);
          const dist = dir.length();
          if (dist < 50) {
            if (gameMode === 'explore') {
              checkpointProgress = Math.max(checkpointProgress, currentNode + 1);
              const text = document.createElement('div');
              text.className = 'checkpoint-text';
              text.textContent = `CP ${currentNode + 1}`;
              document.body.appendChild(text);
              checkpointTexts.push(text);
              setTimeout(() => {
                if (document.body.contains(text)) document.body.removeChild(text);
                checkpointTexts = checkpointTexts.filter(t => t !== text);
              }, 2000);
              log(`Checkpoint ${currentNode + 1} reached`);
            }
            currentNode = (currentNode + 1) % targets.length;
          }
          dir.normalize();
          velocity.copy(dir.multiplyScalar(200));
          camera.position.add(velocity.multiplyScalar(deltaTime));
          camera.lookAt(target.position);
        }

        // Simplified physics
        const G = 50;
        const softening = 20;
        entities.forEach(e => {
          if (e.userData.velocity && e.position.distanceTo(camera.position) < 800) {
            e.position.add(e.userData.velocity.clone().multiplyScalar(deltaTime));
          }
        });

        // Projectiles
        entities.forEach((e, i) => {
          if (e.userData.type === 'projectile' && e.position.length() > 1500) {
            e.visible = false;
            pool.push(e);
            scene.remove(e);
            entities.splice(i, 1);
            entityCount--;
          }
        });

        // Checkpoint text
        checkpointTexts.forEach(text => {
          const cp = entities.find(e => e.userData.type === 'checkpoint' && text.textContent.includes(`CP ${e.userData.index + 1}`));
          if (cp) {
            const pos = cp.position.clone().project(camera);
            text.style.left = `${(pos.x * 0.5 + 0.5) * window.innerWidth}px`;
            text.style.top = `${(-pos.y * 0.5 + 0.5) * window.innerHeight}px`;
          }
        });

        renderer.render(scene, camera);
      }

      // Event listeners
      document.getElementById('throttleBtn').addEventListener('click', toggleThrottle);
      document.getElementById('addComet').addEventListener('click', () => addEntity('comet'));
      document.getElementById('addSystem').addEventListener('click', () => addEntity('system'));
      document.getElementById('addGalaxy').addEventListener('click', () => addEntity('galaxy'));
      document.getElementById('addNode').addEventListener('click', () => addEntity('node'));
      document.getElementById('autopilotBtn').addEventListener('click', toggleAutopilot);
      document.getElementById('shootBtn').addEventListener('click', () => addEntity('projectile'));
      document.getElementById('resetBtn').addEventListener('click', reset);
      document.getElementById('modeBtn').addEventListener('click', toggleMode);

      // Green coding: pause when inactive
      document.addEventListener('visibilitychange', () => {
        isActive = document.visibilityState === 'visible';
        if (isActive) {
          lastTime = performance.now();
          animate();
        }
      });

      // Resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Initialize
      log('Galaxycraft Lite initialized');
      updateControls();
      updateStatus();
      animate();
    } catch (e) {
      console.error(e);
      document.getElementById('prompt').textContent = 'Error: Refresh page';
      document.getElementById('prompt').classList.add('active');
    }
  </script>
</body>
</html>
