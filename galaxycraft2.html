<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Galaxycraft - BETA</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    }
    body {
      background: #000;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #cosmicCanvas {
      flex: 1;
      width: 100%;
      touch-action: none;
      position: relative;
    }
    .controls {
      position: fixed;
      bottom: 0;
      width: 100%;
      background: rgba(20, 20, 50, 0.9);
      padding: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      backdrop-filter: blur(5px);
    }
    .control-item {
      flex: 1;
      min-width: 80px;
      text-align: center;
    }
    button {
      background: #4a90e2;
      border: none;
      padding: 10px 20px;
      color: white;
      border-radius: 20px;
      cursor: pointer;
      font-size: 16px;
      transition: transform 0.2s, background 0.2s;
    }
    button:hover {
      background: #357abd;
    }
    button.active {
      background: #ff4444;
    }
    button:active {
      transform: scale(0.95);
    }
    select {
      background: #4a90e2;
      border: none;
      padding: 10px;
      color: white;
      border-radius: 20px;
      font-size: 16px;
      cursor: pointer;
      width: 100%;
      max-width: 150px;
    }
    select:hover {
      background: #357abd;
    }
    .prompt {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 10px;
      font-size: 14px;
      max-width: 90%;
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s;
    }
    .prompt.active {
      opacity: 1;
    }
    .hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.4;
    }
    .hud::before {
      content: '';
      position: absolute;
      top: 10%;
      left: 10%;
      right: 10%;
      bottom: 10%;
      border: 2px solid #4a90e2;
      border-radius: 20px;
      box-shadow: 0 0 10px #4a90e2;
    }
    .hud::after {
      content: '+';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #4a90e2;
      font-size: 24px;
    }
    .throttle-indicator {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      color: #4a90e2;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .throttle-indicator.active {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="cosmicCanvas">
    <div class="hud"></div>
    <div id="throttleIndicator" class="throttle-indicator"></div>
  </div>
  <div class="controls">
    <div class="control-item">
      <button id="throttleBtn">Full Throttle</button>
    </div>
    <div class="control-item">
      <button id="addComet">Add Comet</button>
    </div>
    <div class="control-item">
      <button id="addSystem">Add System</button>
    </div>
    <div class="control-item">
      <button id="addGalaxy">Add Galaxy</button>
    </div>
    <div class="control-item">
      <button id="shootBtn">Shoot</button>
    </div>
    <div class="control-item">
      <button id="resetBtn">Reset</button>
    </div>
    <div class="control-item">
      <button id="autopilotBtn">Autopilot</button>
    </div>
    <div class="control-item">
      <select id="constellationSelect">
        <option value="milkyWay">Milky Way</option>
        <option value="andromeda">Andromeda</option>
        <option value="triangulum">Triangulum</option>
      </select>
    </div>
  </div>
  <div id="prompt" class="prompt"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    window.onload = () => {
      try {
        // Scene setup
        if (!window.THREE) throw new Error('Three.js not loaded');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        const canvas = document.getElementById('cosmicCanvas');
        if (!canvas) throw new Error('Canvas element not found');
        canvas.appendChild(renderer.domElement);

        camera.position.set(0, 0, 0);
        const frustum = new THREE.Frustum();
        const cameraMatrix = new THREE.Matrix4();

        // Shared resources
        const sharedMaterials = {
          glow: new THREE.MeshBasicMaterial({ color: 0xffffff }),
          star: new THREE.MeshBasicMaterial({ color: 0xaaaaaa })
        };
        const sharedGeometries = {
          comet: new THREE.SphereGeometry(2, 4, 4),
          star: new THREE.SphereGeometry(8, 6, 6),
          planet: new THREE.SphereGeometry(2, 4, 4),
          galaxyStar: new THREE.SphereGeometry(1, 4, 4),
          projectile: new THREE.SphereGeometry(5, 4, 4)
        };

        // Entities
        let comets = [];
        let systems = [];
        let galaxies = [];
        let projectiles = [];
        let cometInstances = null;
        let projectileInstances = null;
        let cometCount = 0;
        let projectileCount = 0;
        let throttle = 0;
        let rotation = { pitch: 0, yaw: 0 };
        let rotationVelocity = { pitch: 0, yaw: 0 };
        let velocity = new THREE.Vector3(0, 0, 0);
        let lastTime = performance.now();
        let entityCount = 0;
        let autopilotActive = false;
        let autopilotPhase = 0;
        let autopilotTimer = 0;
        let selectedConstellation = 'milkyWay';

        // Keyboard controls
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        window.addEventListener('keydown', e => {
          if (autopilotActive) return;
          if (e.key in keys) {
            keys[e.key] = true;
            e.preventDefault();
          }
        });
        window.addEventListener('keyup', e => {
          if (e.key in keys) keys[e.key] = false;
        });

        // Object pools
        const cometPool = [];
        const projectilePool = [];
        function getCometFromPool() {
          if (cometPool.length > 0) {
            const comet = cometPool.pop();
            comet.visible = true;
            return comet;
          }
          return new THREE.Mesh(sharedGeometries.comet, sharedMaterials.glow);
        }
        function getProjectileFromPool() {
          if (projectilePool.length > 0) {
            const projectile = projectilePool.pop();
            projectile.visible = true;
            return projectile;
          }
          return new THREE.Mesh(sharedGeometries.projectile, sharedMaterials.glow);
        }

        // Simulated data
        const trainingData = {
          comets: Array(100).fill().map(() => ({
            semiMajorAxis: Math.random() * 50 + 20,
            eccentricity: Math.random() * 0.8,
            velocity: Math.random() * 3 + 1
          })),
          systems: Array(50).fill().map(() => ({
            planets: Math.floor(Math.random() * 3) + 1,
            orbitalRadius: Math.random() * 30 + 10
          })),
          galaxies: Array(20).fill().map(() => ({
            radius: Math.random() * 100 + 50,
            type: ['spiral', 'elliptical'][Math.floor(Math.random() * 2)]
          }))
        };

        // Constellation definitions
        const constellations = {
          milkyWay: {
            phases: [
              {
                throttle: 100,
                duration: 5,
                spawn: [
                  { type: 'galaxy', count: 1, params: { radius: 150, type: 'spiral' } },
                  { type: 'system', count: 2, params: { planets: 3, orbitalRadius: 20 } }
                ]
              },
              {
                throttle: 50,
                duration: 5,
                spawn: [
                  { type: 'galaxy', count: 1, params: { radius: 100, type: 'spiral' } },
                  { type: 'comet', count: 5 }
                ]
              },
              {
                throttle: 0,
                duration: 5,
                spawn: [
                  { type: 'system', count: 3, params: { planets: 2, orbitalRadius: 15 } },
                  { type: 'comet', count: 3 }
                ]
              }
            ]
          },
          andromeda: {
            phases: [
              {
                throttle: 120,
                duration: 4,
                spawn: [
                  { type: 'galaxy', count: 1, params: { radius: 200, type: 'elliptical' } },
                  { type: 'system', count: 1, params: { planets: 4, orbitalRadius: 25 } }
                ]
              },
              {
                throttle: 60,
                duration: 4,
                spawn: [
                  { type: 'galaxy', count: 1, params: { radius: 120, type: 'elliptical' } },
                  { type: 'comet', count: 4 }
                ]
              },
              {
                throttle: 0,
                duration: 4,
                spawn: [
                  { type: 'system', count: 2, params: { planets: 3, orbitalRadius: 20 } },
                  { type: 'comet', count: 2 }
                ]
              }
            ]
          },
          triangulum: {
            phases: [
              {
                throttle: 80,
                duration: 6,
                spawn: [
                  { type: 'galaxy', count: 1, params: { radius: 80, type: 'spiral' } },
                  { type: 'system', count: 1, params: { planets: 2, orbitalRadius: 15 } }
                ]
              },
              {
                throttle: 40,
                duration: 6,
                spawn: [
                  { type: 'galaxy', count: 1, params: { radius: 60, type: 'spiral' } },
                  { type: 'comet', count: 3 }
                ]
              },
              {
                throttle: 0,
                duration: 6,
                spawn: [
                  { type: 'system', count: 1, params: { planets: 2, orbitalRadius: 10 } },
                  { type: 'comet', count: 2 }
                ]
              }
            ]
          }
        };

        // Add entities
        function addComet(autopilot = false, position = null) {
          const params = trainingData.comets[Math.floor(Math.random() * trainingData.comets.length)];
          const comet = getCometFromPool();
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          let pos;
          if (position) {
            pos = position;
          } else {
            const offset = new THREE.Vector3(
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 10
            );
            pos = camera.position.clone().add(forward.multiplyScalar(100)).add(offset);
          }
          comet.position.copy(pos);
          comet.userData = {
            type: 'comet',
            semiMajorAxis: params.semiMajorAxis,
            eccentricity: params.eccentricity,
            velocity: params.velocity,
            angle: Math.random() * Math.PI * 2,
            origin: comet.position.clone(),
            created: Date.now(),
            instanceId: cometCount
          };
          scene.add(comet);
          comets.push(comet);
          cometCount++;
          entityCount++;
          updateCometInstances();
          if (entityCount > 500 && !autopilot) showPrompt(6);
          if (!autopilot) showPrompt(1);
        }

        function updateCometInstances() {
          if (cometInstances) scene.remove(cometInstances);
          cometInstances = new THREE.InstancedMesh(sharedGeometries.comet, sharedMaterials.glow, cometCount);
          const matrix = new THREE.Matrix4();
          comets.forEach((comet, i) => {
            matrix.setPosition(comet.position);
            cometInstances.setMatrixAt(i, matrix);
          });
          scene.add(cometInstances);
        }

        function addPlanetarySystem(autopilot = false, params = null, position = null) {
          const systemParams = params || trainingData.systems[Math.floor(Math.random() * trainingData.systems.length)];
          const systemGroup = new THREE.Group();
          const star = new THREE.Mesh(sharedGeometries.star, sharedMaterials.star);
          star.userData = { type: 'star' };
          systemGroup.add(star);
          for (let i = 0; i < systemParams.planets; i++) {
            const planet = new THREE.Mesh(sharedGeometries.planet, sharedMaterials.glow);
            const orbitalRadius = (i + 1) * systemParams.orbitalRadius / systemParams.planets;
            planet.position.set(orbitalRadius, 0, 0);
            planet.userData = {
              type: 'planet',
              orbitalRadius,
              velocity: Math.sqrt(1 / orbitalRadius),
              angle: Math.random() * Math.PI * 2
            };
            systemGroup.add(planet);
          }
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          let pos;
          if (position) {
            pos = position;
          } else {
            const offset = new THREE.Vector3(
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 10
            );
            pos = camera.position.clone().add(forward.multiplyScalar(200)).add(offset);
          }
          systemGroup.position.copy(pos);
          systemGroup.userData = { created: Date.now() };
          scene.add(systemGroup);
          systems.push(systemGroup);
          entityCount += 1 + systemParams.planets;
          if (entityCount > 500 && !autopilot) showPrompt(6);
          if (!autopilot) showPrompt(2);
        }

        function addGalaxy(autopilot = false, params = null, position = null) {
          const galaxyParams = params || trainingData.galaxies[Math.floor(Math.random() * trainingData.galaxies.length)];
          const galaxyGroup = new THREE.Group();
          const starCount = galaxyParams.type === 'spiral' ? 10 : 5;
          for (let i = 0; i < starCount; i++) {
            const star = new THREE.Mesh(sharedGeometries.galaxyStar, sharedMaterials.glow);
            const r = Math.random() * galaxyParams.radius;
            const theta = Math.random() * Math.PI * 2;
            const phi = galaxyParams.type === 'spiral' ? Math.random() * 0.2 : Math.random() * Math.PI;
            star.position.set(
              r * Math.sin(phi) * Math.cos(theta),
              r * Math.sin(phi) * Math.sin(theta),
              r * Math.cos(phi)
            );
            star.userData = { type: 'star', velocity: Math.sqrt(1 / r), angle: theta };
            galaxyGroup.add(star);
          }
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          let pos;
          if (position) {
            pos = position;
          } else {
            const offset = new THREE.Vector3(
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 10,
              (Math.random() - 0.5) * 10
            );
            pos = camera.position.clone().add(forward.multiplyScalar(500)).add(offset);
          }
          galaxyGroup.position.copy(pos);
          galaxyGroup.userData = { radius: galaxyParams.radius, created: Date.now() };
          scene.add(galaxyGroup);
          galaxies.push(galaxyGroup);
          entityCount += starCount;
          if (entityCount > 500 && !autopilot) showPrompt(6);
          if (!autopilot) showPrompt(3);
        }

        function shoot() {
          if (autopilotActive) return;
          const projectile = getProjectileFromPool();
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          projectile.position.copy(camera.position).add(forward.multiplyScalar(10));
          projectile.userData = {
            type: 'projectile',
            velocity: forward.multiplyScalar(20),
            remove: false,
            instanceId: projectileCount
          };
          scene.add(projectile);
          projectiles.push(projectile);
          projectileCount++;
          updateProjectileInstances();
          showPrompt(4);
        }

        function updateProjectileInstances() {
          if (projectileInstances) scene.remove(projectileInstances);
          projectileInstances = new THREE.InstancedMesh(sharedGeometries.projectile, sharedMaterials.glow, projectileCount);
          const matrix = new THREE.Matrix4();
          projectiles.forEach((projectile, i) => {
            matrix.setPosition(projectile.position);
            projectileInstances.setMatrixAt(i, matrix);
          });
          scene.add(projectileInstances);
        }

        function reset() {
          comets.forEach(comet => {
            comet.visible = false;
            cometPool.push(comet);
            scene.remove(comet);
          });
          comets = [];
          systems.forEach(system => scene.remove(system));
          systems = [];
          galaxies.forEach(galaxy => scene.remove(galaxy));
          galaxies = [];
          projectiles.forEach(projectile => {
            projectile.visible = false;
            projectilePool.push(projectile);
            scene.remove(projectile);
          });
          projectiles = [];
          if (cometInstances) {
            scene.remove(cometInstances);
            cometInstances = null;
          }
          if (projectileInstances) {
            scene.remove(projectileInstances);
            projectileInstances = null;
          }
          cometCount = 0;
          projectileCount = 0;
          entityCount = 0;
          autopilotActive = false;
          autopilotPhase = 0;
          autopilotTimer = 0;
          const autopilotBtn = document.getElementById('autopilotBtn');
          autopilotBtn.classList.remove('active');
          showPrompt(5);
        }

        // Viewing controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function updateRotation(deltaX, deltaY) {
          if (autopilotActive) return;
          rotationVelocity.yaw -= deltaX * 0.01;
          rotationVelocity.pitch -= deltaY * 0.01;
        }

        renderer.domElement.addEventListener('mousedown', e => {
          if (autopilotActive) return;
          isDragging = true;
          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', e => {
          if (isDragging && !autopilotActive) {
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            updateRotation(deltaX, deltaY);
            previousMousePosition = { x: e.clientX, y: e.clientY };
          }
        });

        renderer.domElement.addEventListener('mouseup', () => {
          isDragging = false;
        });

        renderer.domElement.addEventListener('touchstart', e => {
          if (autopilotActive) return;
          e.preventDefault();
          previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        renderer.domElement.addEventListener('touchmove', e => {
          if (autopilotActive) return;
          e.preventDefault();
          const deltaX = e.touches[0].clientX - previousMousePosition.x;
          const deltaY = e.touches[0].clientY - previousMousePosition.y;
          updateRotation(deltaX, deltaY);
          previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        // Autopilot logic
        function runAutopilot(deltaTime) {
          if (!autopilotActive) return;

          const constellation = constellations[selectedConstellation];
          if (autopilotPhase >= constellation.phases.length) {
            autopilotActive = false;
            const autopilotBtn = document.getElementById('autopilotBtn');
            autopilotBtn.classList.remove('active');
            throttle = 0;
            const throttleIndicator = document.getElementById('throttleIndicator');
            throttleIndicator.textContent = '';
            throttleIndicator.classList.remove('active');
            showPrompt(7);
            return;
          }

          const phase = constellation.phases[autopilotPhase];
          autopilotTimer += deltaTime;

          throttle = phase.throttle;
          const throttleIndicator = document.getElementById('throttleIndicator');
          throttleIndicator.textContent = throttle > 0 ? `Thrust: ${throttle}` : '';
          throttleIndicator.classList.toggle('active', throttle > 0);

          if (autopilotTimer >= phase.duration) {
            phase.spawn.forEach(item => {
              for (let i = 0; i < item.count; i++) {
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const pos = camera.position.clone().add(forward.multiplyScalar(200));
                if (item.type === 'galaxy') {
                  addGalaxy(true, item.params, pos);
                } else if (item.type === 'system') {
                  addPlanetarySystem(true, item.params, pos);
                } else if (item.type === 'comet') {
                  addComet(true, pos);
                }
              }
            });
            autopilotPhase++;
            autopilotTimer = 0;
            showPrompt(8);
          }
        }

        // Animation loop
        function animate() {
          requestAnimationFrame(animate);

          const now = performance.now();
          const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
          lastTime = now;

          // Run autopilot
          runAutopilot(deltaTime);

          // Keyboard rotation
          if (!autopilotActive) {
            if (keys.ArrowLeft) rotationVelocity.yaw += 0.05;
            if (keys.ArrowRight) rotationVelocity.yaw -= 0.05;
            if (keys.ArrowUp) rotationVelocity.pitch -= 0.05;
            if (keys.ArrowDown) rotationVelocity.pitch += 0.05;
          }

          // Apply rotation with momentum
          rotation.pitch += rotationVelocity.pitch * deltaTime;
          rotation.yaw += rotationVelocity.yaw * deltaTime;
          rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.pitch));
          rotationVelocity.pitch *= 0.95;
          rotationVelocity.yaw *= 0.95;

          camera.quaternion.setFromEuler(new THREE.Euler(rotation.pitch, rotation.yaw, 0, 'YXZ'));

          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          velocity.copy(forward.multiplyScalar(throttle));
          camera.position.add(velocity.clone().multiplyScalar(deltaTime));

          // Update frustum
          cameraMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          frustum.setFromProjectionMatrix(cameraMatrix);

          // Update entities
          const matrix = new THREE.Matrix4();
          comets.forEach((comet, i) => {
            if (!frustum.containsPoint(comet.position)) {
              comet.visible = false;
              return;
            }
            comet.visible = true;
            comet.userData.angle += comet.userData.velocity * 0.01 * deltaTime * 60;
            const r = comet.userData.semiMajorAxis * (1 - comet.userData.eccentricity ** 2) /
                      (1 + comet.userData.eccentricity * Math.cos(comet.userData.angle));
            const relativePos = new THREE.Vector3(
              r * Math.cos(comet.userData.angle),
              r * Math.sin(comet.userData.angle),
              0
            );
            comet.position.copy(comet.userData.origin).add(relativePos);
            comet.userData.origin.copy(comet.position);
            matrix.setPosition(comet.position);
            cometInstances.setMatrixAt(i, matrix);
          });
          if (cometInstances) cometInstances.instanceMatrix.needsUpdate = true;

          systems.forEach(system => {
            if (!frustum.containsPoint(system.position)) return;
            system.children.forEach(child => {
              if (child.userData.orbitalRadius) {
                child.userData.angle += child.userData.velocity * 0.01 * deltaTime * 60;
                child.position.set(
                  child.userData.orbitalRadius * Math.cos(child.userData.angle),
                  child.userData.orbitalRadius * Math.sin(child.userData.angle),
                  0
                );
              }
            });
          });

          galaxies.forEach(galaxy => {
            if (!frustum.containsPoint(galaxy.position)) return;
            galaxy.children.forEach(star => {
              star.userData.angle += star.userData.velocity * 0.001 * deltaTime * 60;
              const r = star.position.length();
              star.position.set(
                r * Math.cos(star.userData.angle),
                r * Math.sin(star.userData.angle),
                star.position.z
              );
            });
          });

          // Process projectiles
          let projectilesToRemove = [];
          projectiles.forEach((projectile, pIndex) => {
            if (projectile.userData.remove) return;

            projectile.position.add(projectile.userData.velocity.clone().multiplyScalar(deltaTime));
            if (projectile.position.length() > 2000) {
              projectile.userData.remove = true;
              projectilesToRemove.push(pIndex);
              return;
            }
            matrix.setPosition(projectile.position);
            projectileInstances.setMatrixAt(pIndex, matrix);

            if (!frustum.containsPoint(projectile.position)) return;

            let hits = [];
            const now = Date.now();
            const relativePos = projectile.position.clone();

            comets.forEach((comet, index) => {
              if (!comet.visible) return;
              const age = (now - comet.userData.created) / 1000;
              const distance = relativePos.distanceTo(comet.position);
              if (distance < 20) {
                hits.push({ type: 'comet', obj: comet, index, age });
              }
            });

            systems.forEach((system, index) => {
              if (!frustum.containsPoint(system.position)) return;
              const age = (now - system.userData.created) / 1000;
              if (relativePos.distanceTo(system.position) < 40) {
                hits.push({ type: 'system', obj: system, index, age });
                return;
              }
              for (let child of system.children) {
                if (child.userData.type === 'star' || child.userData.type === 'planet') {
                  const worldPos = new THREE.Vector3();
                  child.getWorldPosition(worldPos);
                  const distance = relativePos.distanceTo(worldPos);
                  const threshold = child.userData.type === 'star' ? 30 : 25;
                  if (distance < threshold) {
                    hits.push({ type: 'system', obj: system, index, age });
                    break;
                  }
                }
              }
            });

            galaxies.forEach((galaxy, index) => {
              if (!frustum.containsPoint(galaxy.position)) return;
              const age = (now - galaxy.userData.created) / 1000;
              if (relativePos.distanceTo(galaxy.position) < 40) {
                hits.push({ type: 'galaxy', obj: galaxy, index, age });
                return;
              }
              for (let star of galaxy.children) {
                const worldPos = new THREE.Vector3();
                star.getWorldPosition(worldPos);
                const distance = relativePos.distanceTo(worldPos);
                if (distance < 20) {
                  hits.push({ type: 'galaxy', obj: galaxy, index, age });
                  break;
                }
              }
            });

            if (hits.length > 0) {
              hits.sort((a, b) => a.age - b.age);
              for (let hit of hits) {
                scene.remove(hit.obj);
                if (hit.type === 'comet') {
                  comets.splice(hit.index, 1);
                  cometPool.push(hit.obj);
                  cometCount--;
                  entityCount--;
                  updateCometInstances();
                } else if (hit.type === 'system') {
                  systems.splice(hit.index, 1);
                  entityCount -= hit.obj.children.length;
                } else if (hit.type === 'galaxy') {
                  galaxies.splice(hit.index, 1);
                  entityCount -= hit.obj.children.length;
                }
              }
              projectile.userData.remove = true;
              projectilesToRemove.push(pIndex);
            }
          });

          if (projectileInstances) projectileInstances.instanceMatrix.needsUpdate = true;

          projectilesToRemove.sort((a, b) => b - a);
          projectilesToRemove.forEach(idx => {
            const projectile = projectiles[idx];
            projectile.visible = false;
            projectilePool.push(projectile);
            scene.remove(projectile);
            projectiles.splice(idx, 1);
            projectileCount--;
            updateProjectileInstances();
          });

          renderer.render(scene, camera);
        }

        // Controls
        try {
          const throttleBtn = document.getElementById('throttleBtn');
          const addCometBtn = document.getElementById('addComet');
          const addSystemBtn = document.getElementById('addSystem');
          const addGalaxyBtn = document.getElementById('addGalaxy');
          const shootBtn = document.getElementById('shootBtn');
          const resetBtn = document.getElementById('resetBtn');
          const autopilotBtn = document.getElementById('autopilotBtn');
          const constellationSelect = document.getElementById('constellationSelect');
          const throttleIndicator = document.getElementById('throttleIndicator');
          const prompt = document.getElementById('prompt');

          if (!throttleBtn || !addCometBtn || !addSystemBtn || !addGalaxyBtn || !shootBtn || !resetBtn || !autopilotBtn || !constellationSelect || !prompt || !throttleIndicator) {
            throw new Error('One or more control elements not found');
          }

          throttleBtn.addEventListener('click', () => {
            if (autopilotActive) return;
            throttle = throttle === 0 ? 150 : 0;
            throttleBtn.classList.toggle('active', throttle > 0);
            throttleIndicator.textContent = throttle > 0 ? `Thrust: ${throttle}` : '';
            throttleIndicator.classList.toggle('active', throttle > 0);
            showPrompt(0);
          });

          addCometBtn.addEventListener('click', () => {
            if (autopilotActive) return;
            addComet();
          });

          addSystemBtn.addEventListener('click', () => {
            if (autopilotActive) return;
            addPlanetarySystem();
          });

          addGalaxyBtn.addEventListener('click', () => {
            if (autopilotActive) return;
            addGalaxy();
          });

          shootBtn.addEventListener('click', () => {
            if (autopilotActive) return;
            shoot();
          });

          resetBtn.addEventListener('click', () => {
            reset();
          });

          autopilotBtn.addEventListener('click', () => {
            autopilotActive = !autopilotActive;
            autopilotBtn.classList.toggle('active', autopilotActive);
            autopilotPhase = 0;
            autopilotTimer = 0;
            if (autopilotActive) {
              throttleBtn.classList.remove('active');
              showPrompt(9);
            } else {
              throttle = 0;
              throttleIndicator.textContent = '';
              throttleIndicator.classList.remove('active');
              showPrompt(10);
            }
          });

          constellationSelect.addEventListener('change', (e) => {
            selectedConstellation = e.target.value;
            if (autopilotActive) {
              autopilotPhase = 0;
              autopilotTimer = 0;
              reset();
              showPrompt(11);
            }
          });

          const prompts = [
            "Full Throttle engaged! Cruise the cosmos!",
            "Comet added to your galaxy.",
            "Planetary system created ahead.",
            "Galaxy spawned with stars.",
            "Projectile fired!",
            "Galaxy reset to blank slate.",
            "Warning: Adding more may slow performance!",
            "Autopilot completed constellation creation!",
            "Autopilot advancing to next phase...",
            "Autopilot engaged! Building constellation...",
            "Autopilot disengaged. Manual control restored.",
            "Constellation changed. Restarting autopilot..."
          ];

          function showPrompt(index) {
            prompt.textContent = prompts[index];
            prompt.classList.add('active');
            setTimeout(() => prompt.classList.remove('active'), 2000);
          }
        } catch (e) {
          console.error('Control setup error:', e);
        }

        // Initialize
        try {
          animate();
        } catch (e) {
          console.error('Initialization error:', e);
        }

        // Resize
        window.addEventListener('resize', () => {
          try {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          } catch (e) {
            console.error('Resize error:', e);
          }
        });
      } catch (e) {
        console.error('Main script error:', e);
      }
    };
  </script>
</body>
</html>
