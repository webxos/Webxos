<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Galaxycraft - BETA</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    }
    body {
      background: #000;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #cosmicCanvas {
      flex: 1;
      width: 100%;
      touch-action: none;
      position: relative;
    }
    .controls {
      position: fixed;
      bottom: 0;
      width: 100%;
      background: rgba(20, 20, 50, 0.9);
      padding: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      backdrop-filter: blur(5px);
    }
    .control-item {
      flex: 1;
      min-width: 80px;
      text-align: center;
    }
    button {
      background: #4a90e2;
      border: none;
      padding: 10px 20px;
      color: white;
      border-radius: 20px;
      cursor: pointer;
      font-size: 16px;
      transition: transform 0.2s, background 0.2s;
    }
    button:hover {
      background: #357abd;
    }
    button.active {
      background: #ff4444;
    }
    button:active {
      transform: scale(0.95);
    }
    .prompt {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 10px;
      font-size: 14px;
      max-width: 90%;
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s;
    }
    .prompt.active {
      opacity: 1;
    }
    .throttle-indicator {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      color: #4a90e2;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .throttle-indicator.active {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="cosmicCanvas">
    <div id="throttleIndicator" class="throttle-indicator"></div>
  </div>
  <div class="controls">
    <div class="control-item">
      <button id="throttleBtn">Full Throttle</button>
    </div>
    <div class="control-item">
      <button id="addComet">Add Comet</button>
    </div>
    <div class="control-item">
      <button id="addSystem">Add System</button>
    </div>
    <div class="control-item">
      <button id="addGalaxy">Add Galaxy</button>
    </div>
    <div class="control-item">
      <button id="shootBtn">Shoot</button>
    </div>
    <div class="control-item">
      <button id="resetBtn">Reset</button>
    </div>
    <div class="control-item">
      <button id="autopilotBtn">Autopilot</button>
    </div>
  </div>
  <div id="prompt" class="prompt"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    window.onload = () => {
      try {
        // Scene setup
        if (!window.THREE) throw new Error('Three.js not loaded');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        const canvas = document.getElementById('cosmicCanvas');
        if (!canvas) throw new Error('Canvas element not found');
        canvas.appendChild(renderer.domElement);

        camera.position.set(0, 0, 0);
        const frustum = new THREE.Frustum();
        const cameraMatrix = new THREE.Matrix4();

        // Shared resources
        const sharedMaterials = {
          glow: new THREE.MeshBasicMaterial({ color: 0xffffff }),
          star: new THREE.MeshBasicMaterial({ color: 0xaaaaaa })
        };
        const sharedGeometries = {
          comet: new THREE.SphereGeometry(2, 4, 4),
          star: new THREE.SphereGeometry(8, 6, 6),
          planet: new THREE.SphereGeometry(2, 4, 4),
          galaxyStar: new THREE.SphereGeometry(1, 4, 4),
          projectile: new THREE.SphereGeometry(5, 4, 4)
        };

        // Entities
        let comets = [];
        let systems = [];
        let galaxies = [];
        let projectiles = [];
        let cometInstances = null;
        let projectileInstances = null;
        let cometCount = 0;
        let projectileCount = 0;
        let throttle = 0;
        let rotation = { pitch: 0, yaw: 0 };
        let rotationVelocity = { pitch: 0, yaw: 0 };
        let velocity = new THREE.Vector3(0, 0, 0);
        let lastTime = performance.now();
        let entityCount = 0;
        let autopilotActive = false;
        let autopilotTargets = [];
        let autopilotCurrentTarget = null;

        // Keyboard controls
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        window.addEventListener('keydown', e => {
          if (autopilotActive) return;
          if (e.key in keys) {
            keys[e.key] = true;
            e.preventDefault();
          }
        });
        window.addEventListener('keyup', e => {
          if (e.key in keys) keys[e.key] = false;
        });

        // Object pools
        const cometPool = [];
        const projectilePool = [];
        function getCometFromPool() {
          if (cometPool.length > 0) {
            const comet = cometPool.pop();
            comet.visible = true;
            return comet;
          }
          return new THREE.Mesh(sharedGeometries.comet, sharedMaterials.glow);
        }
        function getProjectileFromPool() {
          if (projectilePool.length > 0) {
            const projectile = projectilePool.pop();
            projectile.visible = true;
            return projectile;
          }
          return new THREE.Mesh(sharedGeometries.projectile, sharedMaterials.glow);
        }

        // Simulated data
        const trainingData = {
          comets: Array(100).fill().map(() => ({
            semiMajorAxis: Math.random() * 50 + 20,
            eccentricity: Math.random() * 0.8,
            velocity: Math.random() * 3 + 1
          })),
          systems: Array(50).fill().map(() => ({
            planets: Math.floor(Math.random() * 3) + 1,
            orbitalRadius: Math.random() * 30 + 10
          })),
          galaxies: Array(20).fill().map(() => ({
            radius: Math.random() * 100 + 50,
            type: ['spiral', 'elliptical'][Math.floor(Math.random() * 2)]
          }))
        };

        // Add entities
        function addComet() {
          const params = trainingData.comets[Math.floor(Math.random() * trainingData.comets.length)];
          const comet = getCometFromPool();
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10
          );
          comet.position.copy(camera.position).add(forward.multiplyScalar(100)).add(offset);
          comet.userData = {
            type: 'comet',
            semiMajorAxis: params.semiMajorAxis,
            eccentricity: params.eccentricity,
            velocity: params.velocity,
            angle: Math.random() * Math.PI * 2,
            origin: comet.position.clone(),
            created: Date.now(),
            instanceId: cometCount
          };
          scene.add(comet);
          comets.push(comet);
          cometCount++;
          entityCount++;
          updateCometInstances();
          if (entityCount > 500) showPrompt(6);
          showPrompt(1);
        }

        function updateCometInstances() {
          if (cometInstances) scene.remove(cometInstances);
          cometInstances = new THREE.InstancedMesh(sharedGeometries.comet, sharedMaterials.glow, cometCount);
          const matrix = new THREE.Matrix4();
          comets.forEach((comet, i) => {
            matrix.setPosition(comet.position);
            cometInstances.setMatrixAt(i, matrix);
          });
          scene.add(cometInstances);
        }

        function addPlanetarySystem() {
          const params = trainingData.systems[Math.floor(Math.random() * trainingData.systems.length)];
          const systemGroup = new THREE.Group();
          const star = new THREE.Mesh(sharedGeometries.star, sharedMaterials.star);
          star.userData = { type: 'star' };
          systemGroup.add(star);
          for (let i = 0; i < params.planets; i++) {
            const planet = new THREE.Mesh(sharedGeometries.planet, sharedMaterials.glow);
            const orbitalRadius = (i + 1) * params.orbitalRadius / params.planets;
            planet.position.set(orbitalRadius, 0, 0);
            planet.userData = {
              type: 'planet',
              orbitalRadius,
              velocity: Math.sqrt(1 / orbitalRadius),
              angle: Math.random() * Math.PI * 2
            };
            systemGroup.add(planet);
          }
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10
          );
          systemGroup.position.copy(camera.position).add(forward.multiplyScalar(200)).add(offset);
          systemGroup.userData = { created: Date.now() };
          scene.add(systemGroup);
          systems.push(systemGroup);
          entityCount += 1 + params.planets;
          if (entityCount > 500) showPrompt(6);
          showPrompt(2);
        }

        function addGalaxy() {
          const params = trainingData.galaxies[Math.floor(Math.random() * trainingData.galaxies.length)];
          const galaxyGroup = new THREE.Group();
          const starCount = params.type === 'spiral' ? 10 : 5;
          for (let i = 0; i < starCount; i++) {
            const star = new THREE.Mesh(sharedGeometries.galaxyStar, sharedMaterials.glow);
            const r = Math.random() * params.radius;
            const theta = Math.random() * Math.PI * 2;
            const phi = params.type === 'spiral' ? Math.random() * 0.2 : Math.random() * Math.PI;
            star.position.set(
              r * Math.sin(phi) * Math.cos(theta),
              r * Math.sin(phi) * Math.sin(theta),
              r * Math.cos(phi)
            );
            star.userData = { type: 'star', velocity: Math.sqrt(1 / r), angle: theta };
            galaxyGroup.add(star);
          }
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10
          );
          galaxyGroup.position.copy(camera.position).add(forward.multiplyScalar(500)).add(offset);
          galaxyGroup.userData = { radius: params.radius, created: Date.now() };
          scene.add(galaxyGroup);
          galaxies.push(galaxyGroup);
          entityCount += starCount;
          if (entityCount > 500) showPrompt(6);
          showPrompt(3);
        }

        function shoot() {
          if (autopilotActive) return;
          const projectile = getProjectileFromPool();
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          projectile.position.copy(camera.position).add(forward.multiplyScalar(10));
          projectile.userData = {
            type: 'projectile',
            velocity: forward.multiplyScalar(20),
            remove: false,
            instanceId: projectileCount
          };
          scene.add(projectile);
          projectiles.push(projectile);
          projectileCount++;
          updateProjectileInstances();
          showPrompt(4);
        }

        function updateProjectileInstances() {
          if (projectileInstances) scene.remove(projectileInstances);
          projectileInstances = new THREE.InstancedMesh(sharedGeometries.projectile, sharedMaterials.glow, projectileCount);
          const matrix = new THREE.Matrix4();
          projectiles.forEach((projectile, i) => {
            matrix.setPosition(projectile.position);
            projectileInstances.setMatrixAt(i, matrix);
          });
          scene.add(projectileInstances);
        }

        function reset() {
          comets.forEach(comet => {
            comet.visible = false;
            cometPool.push(comet);
            scene.remove(comet);
          });
          comets = [];
          systems.forEach(system => scene.remove(system));
          systems = [];
          galaxies.forEach(galaxy => scene.remove(galaxy));
          galaxies = [];
          projectiles.forEach(projectile => {
            projectile.visible = false;
            projectilePool.push(projectile);
            scene.remove(projectile);
          });
          projectiles = [];
          if (cometInstances) {
            scene.remove(cometInstances);
            cometInstances = null;
          }
          if (projectileInstances) {
            scene.remove(projectileInstances);
            projectileInstances = null;
          }
          cometCount = 0;
          projectileCount = 0;
          entityCount = 0;
          if (autopilotActive) {
            autopilotActive = false;
            const autopilotBtn = document.getElementById('autopilotBtn');
            autopilotBtn.classList.remove('active');
          }
          autopilotTargets = [];
          autopilotCurrentTarget = null;
          showPrompt(5);
        }

        // Viewing controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function updateRotation(deltaX, deltaY) {
          if (autopilotActive) return;
          rotationVelocity.yaw -= deltaX * 0.01;
          rotationVelocity.pitch -= deltaY * 0.01;
        }

        renderer.domElement.addEventListener('mousedown', e => {
          if (autopilotActive) return;
          isDragging = true;
          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', e => {
          if (isDragging && !autopilotActive) {
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            updateRotation(deltaX, deltaY);
            previousMousePosition = { x: e.clientX, y: e.clientY };
          }
        });

        renderer.domElement.addEventListener('mouseup', () => {
          isDragging = false;
        });

        renderer.domElement.addEventListener('touchstart', e => {
          if (autopilotActive) return;
          e.preventDefault();
          previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        renderer.domElement.addEventListener('touchmove', e => {
          if (autopilotActive) return;
          e.preventDefault();
          const deltaX = e.touches[0].clientX - previousMousePosition.x;
          const deltaY = e.touches[0].clientY - previousMousePosition.y;
          updateRotation(deltaX, deltaY);
          previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        // Autopilot logic
        function initializeAutopilot() {
          autopilotTargets = [];
          systems.forEach(system => {
            autopilotTargets.push({
              position: system.position.clone(),
              type: 'system'
            });
          });
          galaxies.forEach(galaxy => {
            autopilotTargets.push({
              position: galaxy.position.clone(),
              type: 'galaxy'
            });
          });
          if (autopilotTargets.length === 0) {
            autopilotActive = false;
            const autopilotBtn = document.getElementById('autopilotBtn');
            autopilotBtn.classList.remove('active');
            showPrompt(7);
            return false;
          }
          selectNextTarget();
          return true;
        }

        function selectNextTarget() {
          if (autopilotTargets.length === 0) {
            initializeAutopilot();
            return;
          }
          let closestTarget = null;
          let minDistance = Infinity;
          const currentPos = camera.position.clone();
          autopilotTargets.forEach((target, index) => {
            const distance = currentPos.distanceTo(target.position);
            if (distance < minDistance) {
              minDistance = distance;
              closestTarget = { ...target, index };
            }
          });
          if (closestTarget) {
            autopilotCurrentTarget = closestTarget;
            autopilotTargets.splice(closestTarget.index, 1);
          } else {
            autopilotCurrentTarget = null;
          }
        }

        function runAutopilot(deltaTime) {
          if (!autopilotActive) return;

          if (!autopilotCurrentTarget) {
            if (!initializeAutopilot()) return;
            if (!autopilotCurrentTarget) return;
          }

          const targetPos = autopilotCurrentTarget.position;
          const direction = targetPos.clone().sub(camera.position);
          const distance = direction.length();

          // Set throttle
          throttle = Math.min(150, Math.max(50, distance * 0.5));

          // Update throttle indicator
          const throttleIndicator = document.getElementById('throttleIndicator');
          throttleIndicator.textContent = throttle > 0 ? `Thrust: ${throttle}` : '';
          throttleIndicator.classList.toggle('active', throttle > 0);

          // Calculate desired rotation to face target
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          direction.normalize();
          const angleToTarget = forward.angleTo(direction);
          const axis = new THREE.Vector3().crossVectors(forward, direction).normalize();
          const quaternionToTarget = new THREE.Quaternion().setFromAxisAngle(axis, angleToTarget);

          // Smoothly interpolate rotation
          const currentQuat = camera.quaternion.clone();
          currentQuat.slerp(quaternionToTarget, 0.05);
          camera.quaternion.copy(currentQuat);

          // Move toward target
          velocity.copy(direction.multiplyScalar(throttle));
          camera.position.add(velocity.clone().multiplyScalar(deltaTime));

          // Check if passed through target (within 10 units)
          if (distance < 10) {
            selectNextTarget();
          }
        }

        // Animation loop
        function animate() {
          requestAnimationFrame(animate);

          const now = performance.now();
          const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
          lastTime = now;

          // Run autopilot
          runAutopilot(deltaTime);

          // Manual controls
          if (!autopilotActive) {
            // Keyboard rotation
            if (keys.ArrowLeft) rotationVelocity.yaw += 0.05;
            if (keys.ArrowRight) rotationVelocity.yaw -= 0.05;
            if (keys.ArrowUp) rotationVelocity.pitch -= 0.05;
            if (keys.ArrowDown) rotationVelocity.pitch += 0.05;

            // Apply rotation with momentum
            rotation.pitch += rotationVelocity.pitch * deltaTime;
            rotation.yaw += rotationVelocity.yaw * deltaTime;
            rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.pitch));
            rotationVelocity.pitch *= 0.95;
            rotationVelocity.yaw *= 0.95;

            camera.quaternion.setFromEuler(new THREE.Euler(rotation.pitch, rotation.yaw, 0, 'YXZ'));

            // Apply velocity
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            velocity.copy(forward.multiplyScalar(throttle));
            camera.position.add(velocity.clone().multiplyScalar(deltaTime));
          }

          // Update frustum
          cameraMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          frustum.setFromProjectionMatrix(cameraMatrix);

          // Update entities
          const matrix = new THREE.Matrix4();
          comets.forEach((comet, i) => {
            if (!frustum.containsPoint(comet.position)) {
              comet.visible = false;
              return;
            }
            comet.visible = true;
            comet.userData.angle += comet.userData.velocity * 0.01 * deltaTime * 60;
            const r = comet.userData.semiMajorAxis * (1 - comet.userData.eccentricity ** 2) /
                      (1 + comet.userData.eccentricity * Math.cos(comet.userData.angle));
            const relativePos = new THREE.Vector3(
              r * Math.cos(comet.userData.angle),
              r * Math.sin(comet.userData.angle),
              0
            );
            comet.position.copy(comet.userData.origin).add(relativePos);
            comet.userData.origin.copy(comet.position);
            matrix.setPosition(comet.position);
            cometInstances.setMatrixAt(i, matrix);
          });
          if (cometInstances) cometInstances.instanceMatrix.needsUpdate = true;

          systems.forEach(system => {
            if (!frustum.containsPoint(system.position)) return;
            system.children.forEach(child => {
              if (child.userData.orbitalRadius) {
                child.userData.angle += child.userData.velocity * 0.01 * deltaTime * 60;
                child.position.set(
                  child.userData.orbitalRadius * Math.cos(child.userData.angle),
                  child.userData.orbitalRadius * Math.sin(child.userData.angle),
                  0
                );
              }
            });
          });

          galaxies.forEach(galaxy => {
            if (!frustum.containsPoint(galaxy.position)) return;
            galaxy.children.forEach(star => {
              star.userData.angle += star.userData.velocity * 0.001 * deltaTime * 60;
              const r = star.position.length();
              star.position.set(
                r * Math.cos(star.userData.angle),
                r * Math.sin(star.userData.angle),
                star.position.z
              );
            });
          });

          // Process projectiles
          let projectilesToRemove = [];
          projectiles.forEach((projectile, pIndex) => {
            if (projectile.userData.remove) return;

            projectile.position.add(projectile.userData.velocity.clone().multiplyScalar(deltaTime));
            if (projectile.position.length() > 2000) {
              projectile.userData.remove = true;
              projectilesToRemove.push(pIndex);
              return;
            }
            matrix.setPosition(projectile.position);
            projectileInstances.setMatrixAt(pIndex, matrix);

            if (!frustum.containsPoint(projectile.position)) return;

            let hits = [];
            const now = Date.now();
            const relativePos = projectile.position.clone();

            comets.forEach((comet, index) => {
              if (!comet.visible) return;
              const age = (now - comet.userData.created) / 1000;
              const distance = relativePos.distanceTo(comet.position);
              if (distance < 20) {
                hits.push({ type: 'comet', obj: comet, index, age });
              }
            });

            systems.forEach((system, index) => {
              if (!frustum.containsPoint(system.position)) return;
              const age = (now - system.userData.created) / 1000;
              if (relativePos.distanceTo(system.position) < 40) {
                hits.push({ type: 'system', obj: system, index, age });
                return;
              }
              for (let child of system.children) {
                if (child.userData.type === 'star' || child.userData.type === 'planet') {
                  const worldPos = new THREE.Vector3();
                  child.getWorldPosition(worldPos);
                  const distance = relativePos.distanceTo(worldPos);
                  const threshold = child.userData.type === 'star' ? 30 : 25;
                  if (distance < threshold) {
                    hits.push({ type: 'system', obj: system, index, age });
                    break;
                  }
                }
              }
            });

            galaxies.forEach((galaxy, index) => {
              if (!frustum.containsPoint(galaxy.position)) return;
              const age = (now - galaxy.userData.created) / 1000;
              if (relativePos.distanceTo(galaxy.position) < 40) {
                hits.push({ type: 'galaxy', obj: galaxy, index, age });
                return;
              }
              for (let star of galaxy.children) {
                const worldPos = new THREE.Vector3();
                star.getWorldPosition(worldPos);
                const distance = relativePos.distanceTo(worldPos);
                if (distance < 20) {
                  hits.push({ type: 'galaxy', obj: galaxy, index, age });
                  break;
                }
              }
            });

            if (hits.length > 0) {
              hits.sort((a, b) => a.age - b.age);
              for (let hit of hits) {
                scene.remove(hit.obj);
                if (hit.type === 'comet') {
                  comets.splice(hit.index, 1);
                  cometPool.push(hit.obj);
                  cometCount--;
                  entityCount--;
                  updateCometInstances();
                } else if (hit.type === 'system') {
                  systems.splice(hit.index, 1);
                  entityCount -= hit.obj.children.length;
                } else if (hit.type === 'galaxy') {
                  galaxies.splice(hit.index, 1);
                  entityCount -= hit.obj.children.length;
                }
              }
              projectile.userData.remove = true;
              projectilesToRemove.push(pIndex);
            }
          });

          if (projectileInstances) projectileInstances.instanceMatrix.needsUpdate = true;

          projectilesToRemove.sort((a, b) => b - a);
          projectilesToRemove.forEach(idx => {
            const projectile = projectiles[idx];
            projectile.visible = false;
            projectilePool.push(projectile);
            scene.remove(projectile);
            projectiles.splice(idx, 1);
            projectileCount--;
            updateProjectileInstances();
          });

          renderer.render(scene, camera);
        }

        // Controls
        try {
          const throttleBtn = document.getElementById('throttleBtn');
          const addCometBtn = document.getElementById('addComet');
          const addSystemBtn = document.getElementById('addSystem');
          const addGalaxyBtn = document.getElementById('addGalaxy');
          const shootBtn = document.getElementById('shootBtn');
          const resetBtn = document.getElementById('resetBtn');
          const autopilotBtn = document.getElementById('autopilotBtn');
          const throttleIndicator = document.getElementById('throttleIndicator');
          const prompt = document.getElementById('prompt');

          if (!throttleBtn || !addCometBtn || !addSystemBtn || !addGalaxyBtn || !shootBtn || !resetBtn || !autopilotBtn || !prompt || !throttleIndicator) {
            throw new Error('One or more control elements not found');
          }

          throttleBtn.addEventListener('click', () => {
            if (autopilotActive) return;
            throttle = throttle === 0 ? 150 : 0;
            throttleBtn.classList.toggle('active', throttle > 0);
            throttleIndicator.textContent = throttle > 0 ? `Thrust: ${throttle}` : '';
            throttleIndicator.classList.toggle('active', throttle > 0);
            showPrompt(0);
          });

          addCometBtn.addEventListener('click', () => {
            if (autopilotActive) return;
            addComet();
          });

          addSystemBtn.addEventListener('click', () => {
            if (autopilotActive) return;
            addPlanetarySystem();
          });

          addGalaxyBtn.addEventListener('click', () => {
            if (autopilotActive) return;
            addGalaxy();
          });

          shootBtn.addEventListener('click', () => {
            if (autopilotActive) return;
            shoot();
          });

          resetBtn.addEventListener('click', () => {
            reset();
          });

          autopilotBtn.addEventListener('click', () => {
            autopilotActive = !autopilotActive;
            autopilotBtn.classList.toggle('active', autopilotActive);
            if (autopilotActive) {
              if (initializeAutopilot()) {
                throttleBtn.classList.remove('active');
                throttle = 0;
                showPrompt(8);
              }
            } else {
              throttle = 0;
              const throttleIndicator = document.getElementById('throttleIndicator');
              throttleIndicator.textContent = '';
              throttleIndicator.classList.remove('active');
              autopilotTargets = [];
              autopilotCurrentTarget = null;
              rotationVelocity.pitch = 0;
              rotationVelocity.yaw = 0;
              showPrompt(9);
            }
          });

          const prompts = [
            "Full Throttle engaged! Cruise the cosmos!",
            "Comet added to your galaxy.",
            "Planetary system created ahead.",
            "Galaxy spawned with stars.",
            "Projectile fired!",
            "Galaxy reset to blank slate.",
            "Warning: Adding more may slow performance!",
            "No systems or galaxies to visit. Add some first!",
            "Autopilot engaged! Flying to nearest objects...",
            "Autopilot disengaged. Manual control restored."
          ];

          function showPrompt(index) {
            prompt.textContent = prompts[index];
            prompt.classList.add('active');
            setTimeout(() => prompt.classList.remove('active'), 2000);
          }
        } catch (e) {
          console.error('Control setup error:', e);
        }

        // Initialize
        try {
          animate();
        } catch (e) {
          console.error('Initialization error:', e);
        }

        // Resize
        window.addEventListener('resize', () => {
          try {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          } catch (e) {
            console.error('Resize error:', e);
          }
        });
      } catch (e) {
        console.error('Main script error:', e);
      }
    };
  </script>
</body>
</html>
