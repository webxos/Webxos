<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Galaxycraft - WebGPU Enhanced</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    }
    body {
      background: #000;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #cosmicCanvas {
      flex: 1;
      width: 100%;
      touch-action: none;
      position: relative;
    }
    canvas {
      width: 100%;
      height: 100%;
    }
    .controls {
      position: fixed;
      bottom: 0;
      width: 100%;
      background: rgba(20, 20, 50, 0.9);
      padding: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      backdrop-filter: blur(5px);
      z-index: 10;
    }
    .control-item {
      flex: 1;
      min-width: 80px;
      text-align: center;
    }
    button {
      background: #4a90e2;
      border: none;
      padding: 10px 20px;
      color: white;
      border-radius: 20px;
      cursor: pointer;
      font-size: 16px;
      transition: transform 0.2s, background 0.2s;
    }
    button:hover {
      background: #357abd;
    }
    button.active {
      background: #ff4444;
    }
    button:active {
      transform: scale(0.95);
    }
    .prompt {
ï¼—: 0, // Console and UI styles (unchanged from original)
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 10px;
      font-size: 14px;
      max-width: 90%;
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s;
      z-index: 5;
    }
    .prompt.active {
      opacity: 1;
    }
    .hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.4;
      z-index: 1;
    }
    .hud::before {
      content: '';
      position: absolute;
      top: 10%;
      left: 10%;
      right: 10%;
      bottom: 10%;
      border: 2px solid rgba(74, 144, 226, 0);
      border-radius: 20px;
      box-shadow: none;
    }
    .hud::after {
      content: '+';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #4a90e2;
      font-size: 24px;
    }
    .throttle-indicator {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      color: #4a90e2;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 5;
    }
    .throttle-indicator.active {
      opacity: 1;
    }
    .status-overlay {
      position: absolute;
      top: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.3);
      padding: 5px 10px;
      font-size: 12px;
      text-align: left;
      color: #fff;
      text-shadow: 0 0 2px #000;
      z-index: 5;
      pointer-events: none;
    }
    .console {
      position: absolute;
      bottom: 60px;
      width: 100%;
      height: 25%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      z-index: 5;
      padding: 5px;
    }
    .console-log {
      flex: 1;
      overflow-y: auto;
      font-size: 12px;
      color: #fff;
      text-shadow: 0 0 2px #000;
      padding: 5px;
    }
    .console-log p {
      margin: 2px 0;
    }
    .console-input {
      width: 100%;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid #4a90e2;
      color: #fff;
      padding: 5px;
      font-size: 12px;
      outline: none;
    }
    .console-input::placeholder {
      color: #aaa;
    }
    .console::-webkit-scrollbar {
      width: 8px;
    }
    .console::-webkit-scrollbar-thumb {
      background: #4a90e2;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div id="cosmicCanvas">
    <canvas id="renderCanvas"></canvas>
    <div class="hud"></div>
    <div id="statusOverlay" class="status-overlay"></div>
    <div id="throttleIndicator" class="throttle-indicator"></div>
    <div id="console" class="console">
      <div id="consoleLog" class="console-log"></div>
      <input id="consoleInput" class="console-input" type="text" placeholder="Type /help for commands..." autocomplete="off">
    </div>
  </div>
  <div class="controls">
    <div class="control-item"><button id="throttleBtn">Full Throttle</button></div>
    <div class="control-item"><button id="addComet">Add Comet</button></div>
    <div class="control-item"><button id="addSystem">Add System</button></div>
    <div class="control-item"><button id="addGalaxy">Add Galaxy</button></div>
    <div class="control-item"><button id="addNode">Add Node</button></div>
    <div class="control-item"><button id="autopilotBtn">Autopilot</button></div>
    <div class="control-item"><button id="shootBtn">Shoot</button></div>
    <div class="control-item"><button id="resetBtn">Reset</button></div>
  </div>
  <div id="prompt" class="prompt"></div>

  <script>
    window.onload = async () => {
      try {
        // WebGPU setup
        if (!navigator.gpu) throw new Error('WebGPU not supported');
        const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
        if (!adapter) throw new Error('No GPU adapter found');
        const device = await adapter.requestDevice();
        const canvas = document.getElementById('renderCanvas');
        const context = canvas.getContext('webgpu');
        const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
        context.configure({ device, format: presentationFormat, alphaMode: 'premultiplied' });

        // Resize canvas
        function resizeCanvas() {
          canvas.width = window.innerWidth * Math.min(window.devicePixelRatio, 1.5);
          canvas.height = window.innerHeight * Math.min(window.devicePixelRatio, 1.5);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Camera setup
        const camera = {
          position: [0, 0, 0],
          rotation: { pitch: 0, yaw: 0 },
          rotationVelocity: { pitch: 0, yaw: 0 },
          fov: 80,
          aspect: window.innerWidth / window.innerHeight,
          near: 0.1,
          far: 10000,
          updateMatrices() {
            const fovRad = this.fov * Math.PI / 180;
            const tanHalfFov = Math.tan(fovRad / 2);
            const projection = new Float32Array([
              1 / (this.aspect * tanHalfFov), 0, 0, 0,
              0, 1 / tanHalfFov, 0, 0,
              0, 0, -(this.far + this.near) / (this.far - this.near), -1,
              0, 0, -2 * this.far * this.near / (this.far - this.near), 0
            ]);

            const cosPitch = Math.cos(this.rotation.pitch);
            const sinPitch = Math.sin(this.rotation.pitch);
            const cosYaw = Math.cos(this.rotation.yaw);
            const sinYaw = Math.sin(this.rotation.yaw);
            const view = new Float32Array([
              cosYaw, 0, -sinYaw, 0,
              sinYaw * sinPitch, cosPitch, cosYaw * sinPitch, 0,
              sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch, 0,
              -this.position[0], -this.position[1], -this.position[2], 1
            ]);

            return { projection, view };
          }
        };

        // Particle system
        const maxParticles = 10000;
        const particleData = new Float32Array(maxParticles * 8); // pos (3), vel (3), mass (1), type (1)
        const particleBuffer = device.createBuffer({
          size: particleData.byteLength,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
        });
        const instanceData = Array(maxParticles).fill().map(() => ({
          active: false,
          type: 0, // 1=comet, 2=projectile, 3=node
          created: 0
        }));

        // Physics parameters
        const physicsParams = new Float32Array([100, 10, 0.016, 2000]); // G, softening, deltaTime, maxDistance
        const paramsBuffer = device.createBuffer({
          size: physicsParams.byteLength,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });

        // Compute shader for physics
        const computeShaderCode = `
          struct Particle {
            position: vec3<f32>,
            velocity: vec3<f32>,
            mass: f32,
            type: f32
          };
          struct PhysicsParams {
            G: f32,
            softening: f32,
            deltaTime: f32,
            maxDistance: f32
          };
          @group(0) @binding(0) var<storage, read_write> particles: array<Particle>;
          @group(0) @binding(1) var<uniform> params: PhysicsParams;
          @compute @workgroup_size(256)
          fn main(@builtin(global_invocation_id) id: vec3<u32>) {
            let i = id.x;
            if (i >= arrayLength(&particles) || particles[i].type == 0) { return; }
            var acc = vec3<f32>(0.0);
            for (var j = 0u; j < arrayLength(&particles); j++) {
              if (i == j || particles[j].type == 0) { continue; }
              let delta = particles[j].position - particles[i].position;
              let distSq = dot(delta, delta) + params.softening * params.softening;
              let dist = sqrt(distSq);
              if (dist > params.maxDistance) { continue; }
              let forceMag = (params.G * particles[i].mass * particles[j].mass) / distSq;
              acc += normalize(delta) * forceMag / particles[i].mass;
            }
            particles[i].velocity += acc * params.deltaTime;
            particles[i].position += particles[i].velocity * params.deltaTime;
          }
        `;
        const computeModule = device.createShaderModule({ code: computeShaderCode });
        const computePipeline = device.createComputePipeline({
          compute: { module: computeModule, entryPoint: 'main' }
        });
        const computeBindGroup = device.createBindGroup({
          layout: computePipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: particleBuffer } },
            { binding: 1, resource: { buffer: paramsBuffer } }
          ]
        });

        // Vertex and fragment shaders
        const vertexShaderCode = `
          struct VertexInput {
            @location(0) position: vec3<f32>,
            @location(1) instancePos: vec3<f32>
          };
          struct VertexOutput {
            @builtin(position) position: vec4<f32>,
            @location(0) color: vec4<f32>
          };
          struct Uniforms {
            projection: mat4x4<f32>,
            view: mat4x4<f32>
          };
          @group(0) @binding(0) var<uniform> uniforms: Uniforms;
          @vertex
          fn main(input: VertexInput) -> VertexOutput {
            var output: VertexOutput;
            let worldPos = input.position + input.instancePos;
            output.position = uniforms.projection * uniforms.view * vec4<f32>(worldPos, 1.0);
            let type = f32(input.instancePos.w); // Not used, stored in instancePos.w for simplicity
            output.color = select(
              vec4<f32>(1.0, 1.0, 1.0, 1.0), // comet
              select(
                vec4<f32>(1.0, 0.2, 0.8, 1.0), // node
                vec4<f32>(1.0, 1.0, 0.6, 1.0), // projectile
                type == 3.0
              ),
              type == 1.0
            );
            return output;
          }
        `;
        const fragmentShaderCode = `
          @fragment
          fn main(@location(0) color: vec4<f32>) -> @location(0) vec4<f32> {
            return color;
          }
        `;
        const renderModule = device.createShaderModule({ code: vertexShaderCode });
        const fragmentModule = device.createShaderModule({ code: fragmentShaderCode });

        // Sphere geometry (simplified)
        const sphereVertices = new Float32Array([
          // Simple tetrahedron for low-poly sphere
          0, 0, 5,  5, 0, 0,  0, 5, 0,
          0, 0, 5,  0, 5, 0,  -5, 0, 0,
          0, 0, 5,  -5, 0, 0,  0, -5, 0,
          0, -5, 0,  5, 0, 0,  -5, 0, 0
        ]);
        const vertexBuffer = device.createBuffer({
          size: sphereVertices.byteLength,
          usage: GPUBufferUsage.VERTEX,
          mappedAtCreation: true
        });
        new Float32Array(vertexBuffer.getMappedRange()).set(sphereVertices);
        vertexBuffer.unmap();

        // Render pipeline
        const uniformBuffer = device.createBuffer({
          size: 128, // Two 4x4 matrices
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
        const instanceBuffer = device.createBuffer({
          size: maxParticles * 16, // vec4 per instance (x, y, z, type)
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
        });
        const renderPipeline = device.createRenderPipeline({
          layout: device.createPipelineLayout({
            bindGroupLayouts: [device.createBindGroupLayout({
              entries: [{ binding: 0, visibility: GPUShaderStage.VERTEX, buffer: {} }]
            })]
          }),
          vertex: {
            module: renderModule,
            entryPoint: 'main',
            buffers: [
              { arrayStride: 12, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }] },
              { arrayStride: 16, stepMode: 'instance', attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x4' }] }
            ]
          },
          fragment: {
            module: fragmentModule,
            entryPoint: 'main',
            targets: [{ format: presentationFormat }]
          },
          primitive: { topology: 'triangle-list' }
        });
        const renderBindGroup = device.createBindGroup({
          layout: renderPipeline.getBindGroupLayout(0),
          entries: [{ binding: 0, resource: { buffer: uniformBuffer } }]
        });

        // Game state
        let throttle = 0;
        let velocity = [0, 0, 0];
        let autopilotActive = false;
        let currentNodeIndex = 0;
        let entityCount = 0;
        let lastTime = performance.now();

        // Console and status
        const statusOverlay = document.getElementById('statusOverlay');
        const consoleLog = document.getElementById('consoleLog');
        const consoleInput = document.getElementById('consoleInput');
        const maxLogMessages = 50;
        let logMessages = [];

        function addConsoleMessage(message) {
          const timestamp = new Date().toLocaleTimeString();
          logMessages.push(`[${timestamp}] ${message}`);
          if (logMessages.length > maxLogMessages) logMessages.shift();
          consoleLog.innerHTML = logMessages.map(msg => `<p>${msg}</p>`).join('');
          consoleLog.scrollTop = consoleLog.scrollHeight;
        }

        function updateStatusOverlay() {
          statusOverlay.textContent = `Entities: ${entityCount} | Throttle: ${throttle} | Autopilot: ${autopilotActive ? 'On' : 'Off'} | Nodes: ${instanceData.filter(d => d.active && d.type === 3).length}`;
        }

        // Keyboard controls
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        window.addEventListener('keydown', e => {
          if (e.key in keys) { keys[e.key] = true; e.preventDefault(); }
        });
        window.addEventListener('keyup', e => {
          if (e.key in keys) keys[e.key] = false;
        });

        // Console commands
        function handleCommand(input) {
          const cmd = input.trim().toLowerCase();
          if (!cmd.startsWith('/')) {
            addConsoleMessage('Commands must start with "/". Type /help for commands.');
            return;
          }
          const parts = cmd.slice(1).split(' ');
          const command = parts[0];
          const args = parts.slice(1);

          switch (command) {
            case 'help':
              addConsoleMessage('Commands: /add comet, /add system, /add galaxy, /add node, /shoot, /reset, /throttle, /autopilot');
              break;
            case 'add':
              if (args[0] === 'comet') addComet();
              else if (args[0] === 'system') addSystem();
              else if (args[0] === 'galaxy') addGalaxy();
              else if (args[0] === 'node') addNode();
              else addConsoleMessage('Invalid add command. Use: comet, system, galaxy, node');
              break;
            case 'shoot':
              shoot();
              break;
            case 'reset':
              reset();
              break;
            case 'throttle':
              if (autopilotActive) addConsoleMessage('Cannot toggle throttle during autopilot.');
              else toggleThrottle();
              break;
            case 'autopilot':
              toggleAutopilot();
              break;
            default:
              addConsoleMessage('Unknown command. Type /help for commands.');
          }
        }

        consoleInput.addEventListener('keydown', e => {
          if (e.key === 'Enter') {
            const input = consoleInput.value;
            if (input) {
              addConsoleMessage(`> ${input}`);
              handleCommand(input);
              consoleInput.value = '';
            }
          }
        });

        // Simulated data
        const trainingData = {
          comets: Array(100).fill().map(() => ({
            semiMajorAxis: Math.random() * 50 + 20,
            eccentricity: Math.random() * 0.8,
            velocity: Math.random() * 3 + 1
          })),
          systems: Array(50).fill().map(() => ({
            planets: Math.floor(Math.random() * 3) + 1,
            orbitalRadius: Math.random() * 100 + 50
          })),
          galaxies: Array(20).fill().map(() => ({
            radius: Math.random() * 300 + 150,
            type: ['spiral', 'elliptical'][Math.floor(Math.random() * 2)]
          }))
        };

        // Add entities
        function addComet() {
          const params = trainingData.comets[Math.floor(Math.random() * trainingData.comets.length)];
          const forward = getForwardVector();
          const position = [
            camera.position[0] + forward[0] * 500 + (Math.random() - 0.5) * 50,
            camera.position[1] + forward[1] * 500 + (Math.random() - 0.5) * 50,
            camera.position[2] + forward[2] * 500 + (Math.random() - 0.5) * 50
          ];
          addParticle(1, position, [(Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5], 1);
          if (entityCount > 500) showPrompt(8);
          showPrompt(1);
          addConsoleMessage('Comet added to your galaxy.');
          updateStatusOverlay();
        }

        function addSystem() {
          // Simplified: Add a star and planets as particles
          const params = trainingData.systems[Math.floor(Math.random() * trainingData.systems.length)];
          const forward = getForwardVector();
          const basePos = [
            camera.position[0] + forward[0] * 1000 + (Math.random() - 0.5) * 100,
            camera.position[1] + forward[1] * 1000 + (Math.random() - 0.5) * 100,
            camera.position[2] + forward[2] * 1000 + (Math.random() - 0.5) * 100
          ];
          addParticle(1, basePos, [0, 0, 0], 1000); // Star
          for (let i = 0; i < params.planets; i++) {
            const r = (i + 1) * params.orbitalRadius / params.planets;
            const v = Math.sqrt(100 * 1000 / r);
            addParticle(1, [basePos[0] + r, basePos[1], basePos[2]], [0, 0, v], 10); // Planet
          }
          entityCount += 1 + params.planets;
          if (entityCount > 500) showPrompt(8);
          showPrompt(2);
          addConsoleMessage('Planetary system created ahead.');
          updateStatusOverlay();
        }

        function addGalaxy() {
          const params = trainingData.galaxies[Math.floor(Math.random() * trainingData.galaxies.length)];
          const forward = getForwardVector();
          const basePos = [
            camera.position[0] + forward[0] * 2000 + (Math.random() - 0.5) * 200,
            camera.position[1] + forward[1] * 2000 + (Math.random() - 0.5) * 200,
            camera.position[2] + forward[2] * 2000 + (Math.random() - 0.5) * 200
          ];
          const starCount = params.type === 'spiral' ? 10 : 5;
          for (let i = 0; i < starCount; i++) {
            const r = Math.random() * params.radius;
            const theta = Math.random() * Math.PI * 2;
            const phi = params.type === 'spiral' ? Math.random() * 0.2 : Math.random() * Math.PI;
            const pos = [
              basePos[0] + r * Math.sin(phi) * Math.cos(theta),
              basePos[1] + r * Math.sin(phi) * Math.sin(theta),
              basePos[2] + r * Math.cos(phi)
            ];
            const v = Math.sqrt(100 * 50 / r);
            const tangent = [-pos[1] + basePos[1], pos[0] - basePos[0], 0];
            const len = Math.sqrt(tangent[0] ** 2 + tangent[1] ** 2);
            tangent[0] /= len || 1;
            tangent[1] /= len || 1;
            addParticle(1, pos, [tangent[0] * v, tangent[1] * v, 0], 50);
          }
          entityCount += starCount;
          if (entityCount > 500) showPrompt(8);
          showPrompt(3);
          addConsoleMessage('Galaxy spawned with stars.');
          updateStatusOverlay();
        }

        function addNode() {
          const forward = getForwardVector();
          const position = [
            camera.position[0] + forward[0] * 300 + (Math.random() - 0.5) * 100,
            camera.position[1] + forward[1] * 300 + (Math.random() - 0.5) * 100,
            camera.position[2] + forward[2] * 300 + (Math.random() - 0.5) * 100
          ];
          addParticle(3, position, [0, 0, 0], 0);
          if (entityCount > 500) showPrompt(8);
          showPrompt(4);
          addConsoleMessage('Satellite node deployed.');
          updateStatusOverlay();
        }

        function shoot() {
          const forward = getForwardVector();
          const position = [
            camera.position[0] + forward[0] * 10,
            camera.position[1] + forward[1] * 10,
            camera.position[2] + forward[2] * 10
          ];
          addParticle(2, position, [forward[0] * 20, forward[1] * 20, forward[2] * 20], 0);
          showPrompt(5);
          addConsoleMessage('Projectile fired!');
          updateStatusOverlay();
        }

        function addParticle(type, position, velocity, mass) {
          for (let i = 0; i < maxParticles; i++) {
            if (!instanceData[i].active) {
              instanceData[i] = { active: true, type, created: Date.now() };
              const offset = i * 8;
              particleData[offset] = position[0];
              particleData[offset + 1] = position[1];
              particleData[offset + 2] = position[2];
              particleData[offset + 3] = velocity[0];
              particleData[offset + 4] = velocity[1];
              particleData[offset + 5] = velocity[2];
              particleData[offset + 6] = mass;
              particleData[offset + 7] = type;
              entityCount++;
              return;
            }
          }
        }

        function reset() {
          instanceData.forEach(d => d.active = false);
          particleData.fill(0);
          entityCount = 0;
          autopilotActive = false;
          currentNodeIndex = 0;
          throttle = 0;
          document.getElementById('autopilotBtn').classList.remove('active');
          document.getElementById('throttleBtn').classList.remove('active');
          document.getElementById('throttleIndicator').textContent = '';
          document.getElementById('throttleIndicator').classList.remove('active');
          showPrompt(6);
          addConsoleMessage('Galaxy reset to blank slate.');
          updateStatusOverlay();
        }

        function toggleThrottle() {
          throttle = throttle === 0 ? 150 : 0;
          document.getElementById('throttleBtn').classList.toggle('active', throttle > 0);
          document.getElementById('throttleIndicator').textContent = throttle > 0 ? `Thrust: ${throttle}` : '';
          document.getElementById('throttleIndicator').classList.toggle('active', throttle > 0);
          showPrompt(0);
          addConsoleMessage(throttle > 0 ? 'Manual throttle engaged!' : 'Throttle disengaged.');
          updateStatusOverlay();
        }

        function toggleAutopilot() {
          const nodes = instanceData.filter(d => d.active && d.type === 3);
          if (nodes.length < 2) {
            showPrompt(7);
            addConsoleMessage('Need at least 2 nodes for autopilot.');
            return;
          }
          autopilotActive = !autopilotActive;
          document.getElementById('autopilotBtn').classList.toggle('active', autopilotActive);
          if (autopilotActive) {
            throttle = 0;
            document.getElementById('throttleBtn').classList.remove('active');
            document.getElementById('throttleIndicator').textContent = '';
            document.getElementById('throttleIndicator').classList.remove('active');
            currentNodeIndex = 0;
            showPrompt(9);
            addConsoleMessage('Autopilot engaged! Navigating nodes.');
          } else {
            showPrompt(0);
            addConsoleMessage('Autopilot disengaged.');
          }
          updateStatusOverlay();
        }

        function getForwardVector() {
          const cosPitch = Math.cos(camera.rotation.pitch);
          const sinPitch = Math.sin(camera.rotation.pitch);
          const cosYaw = Math.cos(camera.rotation.yaw);
          const sinYaw = Math.sin(camera.rotation.yaw);
          return [-sinYaw * cosPitch, -sinPitch, -cosYaw * cosPitch];
        }

        function updateAutopilot(deltaTime) {
          if (!autopilotActive) return;
          const nodes = instanceData.map((d, i) => d.active && d.type === 3 ? { index: i, pos: particleData.slice(i * 8, i * 8 + 3) } : null).filter(n => n);
          if (nodes.length === 0) return;

          const targetNode = nodes[currentNodeIndex];
          const direction = [
            targetNode.pos[0] - camera.position[0],
            targetNode.pos[1] - camera.position[1],
            targetNode.pos[2] - camera.position[2]
          ];
          const distance = Math.sqrt(direction.reduce((sum, v) => sum + v * v, 0));

          if (distance < 50) {
            currentNodeIndex = (currentNodeIndex + 1) % nodes.length;
            addConsoleMessage(`Reached node ${currentNodeIndex + 1}. Heading to next node.`);
          }

          const len = distance || 1;
          direction[0] /= len;
          direction[1] /= len;
          direction[2] /= len;
          const speed = 150;
          velocity = [direction[0] * speed, direction[1] * speed, direction[2] * speed];
          camera.position[0] += velocity[0] * deltaTime;
          camera.position[1] += velocity[1] * deltaTime;
          camera.position[2] += velocity[2] * deltaTime;

          camera.rotation.yaw = Math.atan2(-direction[0], -direction[2]);
          camera.rotation.pitch = Math.asin(direction[1]);
        }

        // Viewing controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function updateRotation(deltaX, deltaY) {
          if (autopilotActive) return;
          camera.rotationVelocity.yaw -= deltaX * 0.01;
          camera.rotationVelocity.pitch -= deltaY * 0.01;
        }

        canvas.addEventListener('mousedown', e => {
          if (autopilotActive) return;
          isDragging = true;
          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousemove', e => {
          if (isDragging && !autopilotActive) {
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            updateRotation(deltaX, deltaY);
            previousMousePosition = { x: e.clientX, y: e.clientY };
          }
        });

        canvas.addEventListener('mouseup', () => {
          isDragging = false;
        });

        canvas.addEventListener('touchstart', e => {
          if (autopilotActive) return;
          e.preventDefault();
          previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        canvas.addEventListener('touchmove', e => {
          if (autopilotActive) return;
          e.preventDefault();
          const deltaX = e.touches[0].clientX - previousMousePosition.x;
          const deltaY = e.touches[0].clientY - previousMousePosition.y;
          updateRotation(deltaX, deltaY);
          previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        // Animation loop
        async function animate() {
          requestAnimationFrame(animate);

          const now = performance.now();
          const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
          lastTime = now;

          // Update camera
          if (!autopilotActive) {
            if (keys.ArrowLeft) camera.rotationVelocity.yaw += 0.05;
            if (keys.ArrowRight) camera.rotationVelocity.yaw -= 0.05;
            if (keys.ArrowUp) camera.rotationVelocity.pitch -= 0.05;
            if (keys.ArrowDown) camera.rotationVelocity.pitch += 0.05;

            camera.rotation.pitch += camera.rotationVelocity.pitch * deltaTime;
            camera.rotation.yaw += camera.rotationVelocity.yaw * deltaTime;
            camera.rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.pitch));
            camera.rotationVelocity.pitch *= 0.95;
            camera.rotationVelocity.yaw *= 0.95;

            const forward = getForwardVector();
            velocity = [forward[0] * throttle, forward[1] * throttle, forward[2] * throttle];
            camera.position[0] += velocity[0] * deltaTime;
            camera.position[1] += velocity[1] * deltaTime;
            camera.position[2] += velocity[2] * deltaTime;
          } else {
            updateAutopilot(deltaTime);
          }

          // Update physics
          physicsParams[2] = deltaTime;
          device.queue.writeBuffer(paramsBuffer, 0, physicsParams);
          device.queue.writeBuffer(particleBuffer, 0, particleData);
          const computeEncoder = device.createCommandEncoder();
          const computePass = computeEncoder.beginComputePass();
          computePass.setPipeline(computePipeline);
          computePass.setBindGroup(0, computeBindGroup);
          computePass.dispatchWorkgroups(Math.ceil(maxParticles / 256));
          computePass.end();
          device.queue.submit([computeEncoder.finish()]);

          // Read back particle data for collision detection
          const readBuffer = device.createBuffer({
            size: particleData.byteLength,
            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
          });
          const copyEncoder = device.createCommandEncoder();
          copyEncoder.copyBufferToBuffer(particleBuffer, 0, readBuffer, 0, particleData.byteLength);
          device.queue.submit([copyEncoder.finish()]);
          await readBuffer.mapAsync(GPUMapMode.READ);
          const readData = new Float32Array(readBuffer.getMappedRange().slice());
          readBuffer.unmap();

          // Update particle data and handle collisions
          let toRemove = [];
          for (let i = 0; i < maxParticles; i++) {
            if (!instanceData[i].active) continue;
            const offset = i * 8;
            particleData[offset] = readData[offset];
            particleData[offset + 1] = readData[offset + 1];
            particleData[offset + 2] = readData[offset + 2];
            if (instanceData[i].type === 2) { // Projectile
              const pos = [readData[offset], readData[offset + 1], readData[offset + 2]];
              if (Math.sqrt(pos[0] ** 2 + pos[1] ** 2 + pos[2] ** 2) > 2000) {
                instanceData[i].active = false;
                particleData[offset + 7] = 0;
                toRemove.push(i);
                entityCount--;
                continue;
              }
              for (let j = 0; j < maxParticles; j++) {
                if (i === j || !instanceData[j].active || instanceData[j].type === 2) continue;
                const jOffset = j * 8;
                const jPos = [readData[jOffset], readData[jOffset + 1], readData[jOffset + 2]];
                const dist = Math.sqrt(
                  (pos[0] - jPos[0]) ** 2 +
                  (pos[1] - jPos[1]) ** 2 +
                  (pos[2] - jPos[2]) ** 2
                );
                if (dist < 20 && (instanceData[j].type === 1 || instanceData[j].type === 3)) {
                  instanceData[j].active = false;
                  particleData[jOffset + 7] = 0;
                  instanceData[i].active = false;
                  particleData[offset + 7] = 0;
                  toRemove.push(i, j);
                  entityCount -= 2;
                  addConsoleMessage(instanceData[j].type === 1 ? 'Comet destroyed.' : 'Node destroyed.');
                }
              }
            }
          }

          // Update instance buffer
          const instanceDataArray = new Float32Array(maxParticles * 4);
          let instanceCount = 0;
          for (let i = 0; i < maxParticles; i++) {
            if (instanceData[i].active) {
              const offset = i * 8;
              instanceDataArray[instanceCount * 4] = particleData[offset];
              instanceDataArray[instanceCount * 4 + 1] = particleData[offset + 1];
              instanceDataArray[instanceCount * 4 + 2] = particleData[offset + 2];
              instanceDataArray[instanceCount * 4 + 3] = particleData[offset + 7];
              instanceCount++;
            }
          }
          device.queue.writeBuffer(instanceBuffer, 0, instanceDataArray);

          // Render
          const { projection, view } = camera.updateMatrices();
          const uniforms = new Float32Array(32);
          uniforms.set(projection, 0);
          uniforms.set(view, 16);
          device.queue.writeBuffer(uniformBuffer, 0, uniforms);

          const renderEncoder = device.createCommandEncoder();
          const renderPass = renderEncoder.beginRenderPass({
            colorAttachments: [{
              view: context.getCurrentTexture().createView(),
              clearValue: { r: 0, g: 0, b: 0, a: 1 },
              loadOp: 'clear',
              storeOp: 'store'
            }]
          });
          renderPass.setPipeline(renderPipeline);
          renderPass.setBindGroup(0, renderBindGroup);
          renderPass.setVertexBuffer(0, vertexBuffer);
          renderPass.setVertexBuffer(1, instanceBuffer);
          renderPass.draw(sphereVertices.length / 3, instanceCount, 0, 0);
          renderPass.end();
          device.queue.submit([renderEncoder.finish()]);
        }

        // Controls
        try {
          const throttleBtn = document.getElementById('throttleBtn');
          const addCometBtn = document.getElementById('addComet');
          const addSystemBtn = document.getElementById('addSystem');
          const addGalaxyBtn = document.getElementById('addGalaxy');
          const addNodeBtn = document.getElementById('addNode');
          const autopilotBtn = document.getElementById('autopilotBtn');
          const shootBtn = document.getElementById('shootBtn');
          const resetBtn = document.getElementById('resetBtn');
          const prompt = document.getElementById('prompt');

          if (!throttleBtn || !addCometBtn || !addSystemBtn || !addGalaxyBtn || !addNodeBtn || !autopilotBtn || !shootBtn || !resetBtn || !prompt) {
            throw new Error('One or more control elements not found');
          }

          throttleBtn.addEventListener('click', () => {
            if (autopilotActive) return;
            toggleThrottle();
          });
          addCometBtn.addEventListener('click', addComet);
          addSystemBtn.addEventListener('click', addSystem);
          addGalaxyBtn.addEventListener('click', addGalaxy);
          addNodeBtn.addEventListener('click', addNode);
          autopilotBtn.addEventListener('click', toggleAutopilot);
          shootBtn.addEventListener('click', shoot);
          resetBtn.addEventListener('click', reset);

          const prompts = [
            "Manual throttle engaged!",
            "Comet added to your galaxy.",
            "Planetary system created ahead.",
            "Galaxy spawned with stars.",
            "Satellite node deployed.",
            "Projectile fired!",
            "Galaxy reset to blank slate.",
            "Need at least 2 nodes for autopilot!",
            "Warning: Adding more may slow performance!",
            "Autopilot engaged! Navigating nodes."
          ];

          function showPrompt(index) {
            prompt.textContent = prompts[index];
            prompt.classList.add('active');
            setTimeout(() => prompt.classList.remove('active'), 2000);
          }
        } catch (e) {
          console.error('Control setup error:', e);
        }

        // Initialize
        try {
          addConsoleMessage('Galaxycraft WebGPU initialized. Type /help for commands.');
          updateStatusOverlay();
          animate();
        } catch (e) {
          console.error('Initialization error:', e);
        }
      } catch (e) {
        console.error('Main script error:', e);
        document.body.innerHTML = '<h1 style="color: white; text-align: center;">WebGPU initialization failed. Please use a WebGPU-compatible browser.</h1>';
      }
    };
  </script>
</body>
</html>
