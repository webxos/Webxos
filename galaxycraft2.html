<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Galaxycraft v2.0 Cyber Edition</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Orbitron', sans-serif;
    }
    body {
      background: #000;
      color: #00ff00;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
      -webkit-tap-highlight-color: transparent;
    }
    #cosmicCanvas {
      flex: 1;
      width: 100%;
      touch-action: none;
      background: #000;
      position: relative;
    }
    .controls {
      position: fixed;
      bottom: 5px;
      width: 100%;
      background: transparent;
      padding: 5px;
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      justify-content: center;
      z-index: 10;
    }
    .control-item {
      flex: 1;
      min-width: 60px;
      text-align: center;
    }
    button {
      background: transparent;
      border: 2px solid #00ff00;
      padding: 5px 10px;
      color: #00ff00;
      border-radius: 6px;
      cursor: pointer;
      font-size: 8px;
      transition: all 0.2s;
      box-shadow: 0 0 10px #00ff00, inset 0 0 10px #00ff00;
      animation: holo-glow 1.5s ease-in-out infinite alternate;
    }
    @keyframes holo-glow {
      from { box-shadow: 0 0 10px #00ff00, inset 0 0 10px #00ff00; }
      to { box-shadow: 0 0 15px #00ff00, inset 0 0 15px #00ff00; }
    }
    button:hover {
      border-color: #33ff33;
      color: #33ff33;
      box-shadow: 0 0 15px #33ff33, inset 0 0 15px #33ff33;
    }
    button.active {
      border-color: #00ff00;
      color: #00ff00;
      box-shadow: 0 0 15px #00ff00, inset 0 0 15px #00ff00;
      animation: holo-glow-active 1s ease-in-out infinite alternate;
    }
    @keyframes holo-glow-active {
      from { box-shadow: 0 0 15px #00ff00, inset 0 0 15px #00ff00; }
      to { box-shadow: 0 0 20px #00ff00, inset 0 0 20px #00ff00; }
    }
    button:active {
      transform: scale(0.95);
    }
    .prompt {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 10px;
      max-width: 90%;
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s;
      border: 1px solid #00ff00;
      box-shadow: 0 0 10px #00ff00;
      color: #00ff00;
      z-index: 5;
    }
    .prompt.active {
      opacity: 1;
    }
    .hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.5;
      z-index: 1;
    }
    .hud::before {
      content: '';
      position: absolute;
      top: 5%;
      left: 5%;
      right: 5%;
      bottom: 5%;
      border: 1px solid #00ff00;
      border-radius: 8px;
      box-shadow: 0 0 10px #00ff00;
    }
    .hud::after {
      content: '+';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #00ff00;
      font-size: 20px;
      text-shadow: 0 0 8px #00ff00;
    }
    .throttle-indicator {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      color: #00ff00;
      font-size: 10px;
      opacity: 0;
      transition: opacity 0.3s;
      text-shadow: 0 0 8px #00ff00;
      z-index: 5;
    }
    .throttle-indicator.active {
      opacity: 1;
    }
    .status-overlay {
      position: absolute;
      top: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 8px;
      font-size: 8px;
      text-align: left;
      color: #00ff00;
      text-shadow: 0 0 4px #00ff00;
      z-index: 5;
      pointer-events: none;
      border-bottom: 1px solid #00ff00;
    }
    .console {
      position: absolute;
      bottom: 70px;
      width: 100%;
      height: 25%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      flex-direction: column;
      z-index: 5;
      padding: 5px;
      border-top: 1px solid #00ff00;
      box-shadow: 0 0 10px #00ff00;
    }
    .console-header {
      display: flex;
      flex-wrap: nowrap;
      gap: 5px;
      padding: 5px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 6px;
      margin-bottom: 5px;
    }
    .console-log {
      flex: 1;
      overflow-y: auto;
      font-size: 8px;
      color: #00ff00;
      text-shadow: 0 0 4px #00ff00;
      padding: 5px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
    }
    .console-log p {
      margin: 3px 0;
    }
    .console-input, #loadInput {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid #00ff00;
      color: #00ff00;
      padding: 5px;
      font-size: 8px;
      border-radius: 6px;
      outline: none;
      transition: border-color 0.2s;
      box-shadow: 0 0 8px #00ff00;
    }
    .console-input:focus, #loadInput:focus {
      border-color: #33ff33;
      box-shadow: 0 0 10px #33ff33;
    }
    .console-input::placeholder, #loadInput::placeholder {
      color: #00cc00;
    }
    .console::-webkit-scrollbar {
      width: 6px;
    }
    .console::-webkit-scrollbar-thumb {
      background: #00ff00;
      border-radius: 3px;
      box-shadow: 0 0 8px #00ff00;
    }
    select {
      background: transparent;
      color: #00ff00;
      border: 1px solid #00ff00;
      padding: 5px;
      border-radius: 6px;
      font-size: 8px;
      cursor: pointer;
      box-shadow: 0 0 8px #00ff00;
    }
    select:focus {
      outline: none;
      border-color: #33ff33;
    }
    #loadInput {
      flex: 1;
      min-width: 100px;
    }
    .checkpoint-text {
      position: absolute;
      color: #00ff00;
      font-size: 24px;
      font-weight: 700;
      text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
      animation: cyber-pulse 1s infinite alternate;
      pointer-events: none;
      z-index: 4;
      transform: translate(-50%, -50%);
    }
    @keyframes cyber-pulse {
      from { text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00; }
      to { text-shadow: 0 0 15px #00ff00, 0 0 30px #00ff00; }
    }
    @media (max-width: 600px) {
      .console {
        height: 30%;
      }
      .console-header {
        flex-wrap: wrap;
      }
      .control-item {
        min-width: 50px;
      }
      button, select, .console-input, #loadInput {
        font-size: 7px;
        padding: 4px;
      }
      .prompt {
        font-size: 8px;
        padding: 6px 12px;
      }
      .status-overlay {
        font-size: 7px;
        padding: 4px 6px;
      }
      .console-log {
        font-size: 7px;
      }
      .checkpoint-text {
        font-size: 16px;
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <div id="cosmicCanvas">
    <div class="hud"></div>
    <div id="statusOverlay" class="status-overlay"></div>
    <div id="throttleIndicator" class="throttle-indicator"></div>
    <div id="console" class="console">
      <div class="console-header">
        <select id="gameMode">
          <option value="craft">Craft Mode</option>
          <option value="explore">Explore Mode</option>
        </select>
        <button id="saveBtn">Save</button>
        <input id="loadInput" type="text" placeholder="Enter WebXOS code...">
        <button id="loadBtn">Load</button>
      </div>
      <div id="consoleLog" class="console-log"></div>
      <input id="consoleInput" class="console-input" type="text" placeholder="Type /help for commands..." autocomplete="off">
    </div>
  </div>
  <div class="controls" id="controls">
    <div class="control-item">
      <button id="throttleBtn">Full Throttle</button>
    </div>
    <div class="control-item craft-only">
      <button id="addComet">Add Comet</button>
    </div>
    <div class="control-item craft-only">
      <button id="addSystem">Add System</button>
    </div>
    <div class="control-item craft-only">
      <button id="addGalaxy">Add Galaxy</button>
    </div>
    <div class="control-item craft-only">
      <button id="addNode">Add Node</button>
    </div>
    <div class="control-item">
      <button id="autopilotBtn">Autopilot</button>
    </div>
    <div class="control-item craft-only">
      <button id="shootBtn">Shoot</button>
    </div>
    <div class="control-item">
      <button id="resetBtn">Reset</button>
    </div>
  </div>
  <div id="prompt" class="prompt"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    window.onload = () => {
      try {
        // Scene setup
        if (!window.THREE) throw new Error('Three.js not loaded');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
        renderer.setPixelRatio(/Mobi|Android|iPhone/i.test(navigator.userAgent) ? 1.0 : 1.5);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        const canvas = document.getElementById('cosmicCanvas');
        if (!canvas) throw new Error('Canvas element not found');
        canvas.appendChild(renderer.domElement);

        camera.position.set(0, 0, 0);
        const frustum = new THREE.Frustum();
        const cameraMatrix = new THREE.Matrix4();

        // Starship (neon green wireframe)
        const starshipGroup = new THREE.Group();
        const shipMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        const shipGeometry = new THREE.BufferGeometry();
        const vertices = [
          // Cockpit triangle
          0, 0, -20,  // Front
          -10, -5, 0, // Bottom-left
          10, -5, 0,  // Bottom-right
          0, 5, 0,    // Top
          // Web-like connections
          -10, -5, 0, 0, 5, 0,
          10, -5, 0, 0, 5, 0,
          0, 0, -20, 0, 5, 0
        ];
        shipGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        const starship = new THREE.LineSegments(shipGeometry, shipMaterial);
        starship.position.set(0, -2, -10);
        starshipGroup.add(starship);
        camera.add(starshipGroup);
        scene.add(camera);
        let starshipGlow = 0;
        const glowSpeed = 0.5;

        // Shared resources
        const neonGreenMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        const sharedGeometries = {
          comet: new THREE.SphereGeometry(5, 8, 8),
          star: new THREE.SphereGeometry(100, 8, 8),
          planet: new THREE.SphereGeometry(20, 8, 8),
          largePlanet: new THREE.SphereGeometry(50, 8, 8),
          galaxyStar: new THREE.SphereGeometry(10, 8, 8),
          projectile: new THREE.SphereGeometry(5, 8, 8),
          node: new THREE.BoxGeometry(10, 10, 10),
          checkpoint: new THREE.BoxGeometry(50, 50, 50)
        };

        // Entities
        let comets = [];
        let systems = [];
        let galaxies = [];
        let projectiles = [];
        let nodes = [];
        let nodeLines = [];
        let checkpoints = [];
        let checkpointTexts = [];
        let cometInstances = null;
        let projectileInstances = null;
        let cometCount = 0;
        let projectileCount = 0;
        let throttle = 0;
        let rotation = { pitch: 0, yaw: 0 };
        let rotationVelocity = { pitch: 0, yaw: 0 };
        let velocity = new THREE.Vector3(0, 0, 0);
        let lastTime = performance.now();
        let entityCount = 0;
        let autopilotActive = false;
        let currentNodeIndex = 0;
        let gameMode = 'craft';
        let checkpointProgress = 0;

        // Gravity parameters
        const G = 100;
        const softening = 10;
        const maxGravityDistance = 1000;

        // Console and status
        const statusOverlay = document.getElementById('statusOverlay');
        const consoleLog = document.getElementById('consoleLog');
        const consoleInput = document.getElementById('consoleInput');
        const gameModeSelect = document.getElementById('gameMode');
        const saveBtn = document.getElementById('saveBtn');
        const loadBtn = document.getElementById('loadBtn');
        const loadInput = document.getElementById('loadInput');
        const maxLogMessages = 50;
        let logMessages = [];

        function addConsoleMessage(message) {
          const timestamp = new Date().toLocaleTimeString();
          logMessages.push(`[${timestamp}] ${message}`);
          if (logMessages.length > maxLogMessages) logMessages.shift();
          consoleLog.innerHTML = logMessages.map(msg => `<p>${msg}</p>`).join('');
          consoleLog.scrollTop = consoleLog.scrollHeight;
        }

        function updateStatusOverlay() {
          statusOverlay.textContent = `Mode: ${gameMode} | Entities: ${entityCount} | Throttle: ${throttle} | Autopilot: ${autopilotActive ? 'On' : 'Off'} | ${gameMode === 'explore' ? `Checkpoints: ${checkpointProgress}/10` : `Nodes: ${nodes.length}`}`;
        }

        // WebXOS Encoder and Decoder
        function stringToHex(str) {
          let hex = '';
          for (let i = 0; i < str.length; i++) hex += str.charCodeAt(i).toString(16).padStart(2, '0');
          return hex;
        }

        function hexToString(hex) {
          let str = '';
          for (let i = 0; i < hex.length; i += 2) str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
          return str;
        }

        function encodeWebXOS() {
          const state = {
            mode: gameMode,
            cameraPosition: camera.position.toArray(),
            comets: comets.map(comet => ({
              position: comet.position.toArray(),
              velocity: comet.userData.velocity.toArray()
            })),
            systems: systems.map(system => ({
              position: system.position.toArray(),
              planets: system.children.filter(c => c.userData.type === 'planet' || c.userData.type === 'largePlanet').map(p => ({
                position: p.position.toArray(),
                velocity: p.userData.velocity.toArray(),
                orbitalRadius: p.userData.orbitalRadius,
                type: p.userData.type
              }))
            })),
            galaxies: galaxies.map(galaxy => ({
              position: galaxy.position.toArray(),
              stars: galaxy.children.map(s => ({
                position: s.position.toArray(),
                velocity: s.userData.velocity.toArray()
              }))
            })),
            nodes: nodes.map(node => ({
              position: node.position.toArray()
            })),
            checkpoints: gameMode === 'explore' ? checkpoints.map(cp => ({
              position: cp.position.toArray()
            })) : [],
            checkpointProgress: gameMode === 'explore' ? checkpointProgress : 0
          };
          const message = JSON.stringify(state);
          const timestamp = Date.now().toString(36).toUpperCase();
          const encodedMessage = stringToHex(message);
          const random1 = Math.random().toString(36).slice(2, 8).toUpperCase();
          const random2 = Math.random().toString(36).slice(2, 8).toUpperCase();
          const checksum = (message.length * 17).toString(36).toUpperCase().padStart(4, '0');
          return `WEBXOS-${timestamp}-${encodedMessage}-${random1}-${random2}-${checksum}`;
        }

        function decodeWebXOS(code) {
          if (!code || typeof code !== 'string' || !code.startsWith('WEBXOS-')) {
            return { error: "Invalid WebXOS code format. Must start with 'WEBXOS-'" };
          }
          const parts = code.split('-');
          if (parts.length !== 6) return { error: `Invalid code structure. Expected 6 parts, got ${parts.length}` };
          const [prefix, timestamp, encodedMessage, random1, random2, checksum] = parts;
          try {
            const decoded = hexToString(encodedMessage);
            const expectedChecksum = (decoded.length * 17).toString(36).toUpperCase().padStart(4, '0');
            if (checksum !== expectedChecksum) return { error: `Checksum mismatch. Expected ${expectedChecksum}, got ${checksum}` };
            return { data: JSON.parse(decoded) };
          } catch (e) {
            return { error: `Decoding failed: ${e.message}` };
          }
        }

        saveBtn.addEventListener('click', () => {
          const code = encodeWebXOS();
          addConsoleMessage(`WebXOS Code: ${code}`);
          showPrompt(12);
        });

        loadBtn.addEventListener('click', () => {
          const code = loadInput.value.trim();
          if (!code) {
            addConsoleMessage('Please enter a WebXOS code.');
            return;
          }
          const result = decodeWebXOS(code);
          if (result.error) {
            addConsoleMessage(result.error);
            return;
          }
          loadGameState(result.data);
          addConsoleMessage('Game state loaded successfully!');
          showPrompt(13);
          loadInput.value = '';
        });

        function loadGameState(state) {
          reset();
          gameMode = state.mode;
          gameModeSelect.value = gameMode;
          updateControlsVisibility();
          camera.position.fromArray(state.cameraPosition);

          if (gameMode === 'explore') {
            checkpointProgress = state.checkpointProgress;
            state.checkpoints.forEach((cp, i) => {
              const checkpoint = new THREE.Mesh(sharedGeometries.checkpoint, neonGreenMaterial);
              checkpoint.position.fromArray(cp.position);
              checkpoint.userData = { type: 'checkpoint', created: Date.now(), index: i };
              scene.add(checkpoint);
              checkpoints.push(checkpoint);
              entityCount++;
            });
            for (let i = 0; i < checkpoints.length - 1; i++) {
              const geometry = new THREE.BufferGeometry().setFromPoints([
                checkpoints[i].position,
                checkpoints[i + 1].position
              ]);
              const line = new THREE.Line(geometry, lineMaterial);
              scene.add(line);
              nodeLines.push(line);
            }
            initializeExploreModeEntities();
          } else {
            state.comets.forEach(cometData => {
              const comet = getCometFromPool();
              comet.position.fromArray(cometData.position);
              comet.userData = {
                type: 'comet',
                mass: 1,
                velocity: new THREE.Vector3().fromArray(cometData.velocity),
                created: Date.now(),
                instanceId: cometCount
              };
              scene.add(comet);
              comets.push(comet);
              cometCount++;
              entityCount++;
            });
            updateCometInstances();

            state.systems.forEach(systemData => {
              const systemGroup = new THREE.Group();
              const star = new THREE.Mesh(sharedGeometries.star, neonGreenMaterial);
              star.userData = { type: 'star', mass: 1000, velocity: new THREE.Vector3(0, 0, 0) };
              systemGroup.add(star);
              systemData.planets.forEach(planetData => {
                const geometry = planetData.type === 'largePlanet' ? sharedGeometries.largePlanet : sharedGeometries.planet;
                const planet = new THREE.Mesh(geometry, neonGreenMaterial);
                planet.position.fromArray(planetData.position);
                planet.userData = {
                  type: planetData.type || 'planet',
                  mass: planetData.type === 'largePlanet' ? 50 : 10,
                  velocity: new THREE.Vector3().fromArray(planetData.velocity),
                  orbitalRadius: planetData.orbitalRadius
                };
                systemGroup.add(planet);
              });
              systemGroup.position.fromArray(systemData.position);
              systemGroup.userData = { created: Date.now() };
              scene.add(systemGroup);
              systems.push(systemGroup);
              entityCount += 1 + systemData.planets.length;
            });

            state.galaxies.forEach(galaxyData => {
              const galaxyGroup = new THREE.Group();
              galaxyData.stars.forEach(starData => {
                const star = new THREE.Mesh(sharedGeometries.galaxyStar, neonGreenMaterial);
                star.position.fromArray(starData.position);
                star.userData = {
                  type: 'star',
                  mass: 50,
                  velocity: new THREE.Vector3().fromArray(starData.velocity)
                };
                galaxyGroup.add(star);
              });
              galaxyGroup.position.fromArray(galaxyData.position);
              galaxyGroup.userData = { created: Date.now() };
              scene.add(galaxyGroup);
              galaxies.push(galaxyGroup);
              entityCount += galaxyData.stars.length;
            });

            state.nodes.forEach(nodeData => {
              const node = getNodeFromPool();
              node.position.fromArray(nodeData.position);
              node.userData = { type: 'node', created: Date.now() };
              scene.add(node);
              nodes.push(node);
              entityCount++;
            });

            for (let i = 0; i < nodes.length - 1; i++) {
              const geometry = new THREE.BufferGeometry().setFromPoints([
                nodes[i].position,
                nodes[i + 1].position
              ]);
              const line = new THREE.Line(geometry, lineMaterial);
              scene.add(line);
              nodeLines.push(line);
            }
          }
          updateStatusOverlay();
        }

        // Mode handling
        gameModeSelect.addEventListener('change', () => {
          gameMode = gameModeSelect.value;
          reset();
          updateControlsVisibility();
          if (gameMode === 'explore') {
            initializeExploreMode();
            showPrompt(10);
            addConsoleMessage('Explore Mode: Follow the checkpoints to complete the journey!');
          } else {
            showPrompt(11);
            addConsoleMessage('Craft Mode: Build and explore your own galaxy.');
          }
          updateStatusOverlay();
        });

        function updateControlsVisibility() {
          const craftControls = document.querySelectorAll('.craft-only');
          craftControls.forEach(control => {
            control.style.display = gameMode === 'craft' ? 'block' : 'none';
          });
        }

        // Explore Mode Setup
        function initializeExploreMode() {
          checkpointProgress = 0;
          const pathLength = 10000;
          const checkpointCount = 10;
          const spacing = pathLength / (checkpointCount - 1);

          for (let i = 0; i < checkpointCount; i++) {
            const checkpoint = new THREE.Mesh(sharedGeometries.checkpoint, neonGreenMaterial);
            checkpoint.position.set(0, 0, i * spacing);
            checkpoint.userData = { type: 'checkpoint', created: Date.now(), index: i };
            scene.add(checkpoint);
            checkpoints.push(checkpoint);
            entityCount++;
          }

          for (let i = 0; i < checkpoints.length - 1; i++) {
            const geometry = new THREE.BufferGeometry().setFromPoints([
              checkpoints[i].position,
              checkpoints[i + 1].position
            ]);
            const line = new THREE.Line(geometry, lineMaterial);
            scene.add(line);
            nodeLines.push(line);
          }

          initializeExploreModeEntities();
        }

        function initializeExploreModeEntities() {
          for (let i = 0; i < 100; i++) {
            const node = getNodeFromPool();
            node.position.set(
              (Math.random() - 0.5) * 1000,
              (Math.random() - 0.5) * 1000,
              Math.random() * 10000
            );
            node.userData = { type: 'node', created: Date.now() };
            scene.add(node);
            nodes.push(node);
            entityCount++;
          }

          for (let i = 0; i < 50; i++) {
            const planet = new THREE.Mesh(sharedGeometries.largePlanet, neonGreenMaterial);
            planet.position.set(
              (Math.random() - 0.5) * 2000,
              (Math.random() - 0.5) * 2000,
              Math.random() * 10000
            );
            planet.userData = { type: 'largePlanet', mass: 50, velocity: new THREE.Vector3(0, 0, 0), created: Date.now() };
            scene.add(planet);
            systems.push(planet);
            entityCount++;
          }

          for (let i = 0; i < 20; i++) {
            const systemGroup = new THREE.Group();
            const star = new THREE.Mesh(sharedGeometries.star, neonGreenMaterial);
            star.userData = { type: 'star', mass: 1000, velocity: new THREE.Vector3(0, 0, 0) };
            systemGroup.add(star);
            const planetCount = Math.floor(Math.random() * 3) + 1;
            for (let j = 0; j < planetCount; j++) {
              const planet = new THREE.Mesh(sharedGeometries.largePlanet, neonGreenMaterial);
              const orbitalRadius = (j + 1) * 200;
              planet.position.set(orbitalRadius, 0, 0);
              const v = Math.sqrt(G * star.userData.mass / orbitalRadius) * 1.5;
              planet.userData = {
                type: 'largePlanet',
                mass: 50,
                velocity: new THREE.Vector3(0, 0, v),
                orbitalRadius
              };
              systemGroup.add(planet);
            }
            systemGroup.position.set(
              (Math.random() - 0.5) * 2000,
              (Math.random() - 0.5) * 2000,
              Math.random() * 10000
            );
            systemGroup.userData = { created: Date.now() };
            scene.add(systemGroup);
            systems.push(systemGroup);
            entityCount += 1 + planetCount;
          }
        }

        // Object pools
        const cometPool = [];
        const projectilePool = [];
        const nodePool = [];
        function getCometFromPool() {
          if (cometPool.length > 0) {
            const comet = cometPool.pop();
            comet.visible = true;
            return comet;
          }
          return new THREE.Mesh(sharedGeometries.comet, neonGreenMaterial);
        }
        function getProjectileFromPool() {
          if (projectilePool.length > 0) {
            const projectile = projectilePool.pop();
            projectile.visible = true;
            return projectile;
          }
          return new THREE.Mesh(sharedGeometries.projectile, neonGreenMaterial);
        }
        function getNodeFromPool() {
          if (nodePool.length > 0) {
            const node = nodePool.pop();
            node.visible = true;
            return node;
          }
          return new THREE.Mesh(sharedGeometries.node, neonGreenMaterial);
        }

        // Simulated data
        const trainingData = {
          comets: Array(100).fill().map(() => ({
            semiMajorAxis: Math.random() * 50 + 20,
            eccentricity: Math.random() * 0.8,
            velocity: Math.random() * 4.5 + 3
          })),
          systems: Array(50).fill().map(() => ({
            planets: Math.floor(Math.random() * 3) + 1,
            orbitalRadius: Math.random() * 100 + 50
          })),
          galaxies: Array(20).fill().map(() => ({
            radius: Math.random() * 300 + 150,
            type: ['spiral', 'elliptical'][Math.floor(Math.random() * 2)]
          }))
        };

        // Add entities
        function addComet() {
          const params = trainingData.comets[Math.floor(Math.random() * trainingData.comets.length)];
          const comet = getCometFromPool();
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 50
          );
          comet.position.copy(camera.position).add(forward.multiplyScalar(500)).add(offset);
          comet.userData = {
            type: 'comet',
            mass: 1,
            velocity: new THREE.Vector3((Math.random() - 0.5) * 7.5, (Math.random() - 0.5) * 7.5, (Math.random() - 0.5) * 7.5),
            created: Date.now(),
            instanceId: cometCount
          };
          scene.add(comet);
          comets.push(comet);
          cometCount++;
          entityCount++;
          updateCometInstances();
          if (entityCount > 300) showPrompt(8);
          showPrompt(1);
          addConsoleMessage('Comet added to your galaxy.');
          updateStatusOverlay();
        }

        function updateCometInstances() {
          if (cometInstances) scene.remove(cometInstances);
          cometInstances = new THREE.InstancedMesh(sharedGeometries.comet, neonGreenMaterial, cometCount);
          const matrix = new THREE.Matrix4();
          comets.forEach((comet, i) => {
            matrix.setPosition(comet.position);
            cometInstances.setMatrixAt(i, matrix);
          });
          scene.add(cometInstances);
        }

        function addPlanetarySystem() {
          const params = trainingData.systems[Math.floor(Math.random() * trainingData.systems.length)];
          const systemGroup = new THREE.Group();
          const star = new THREE.Mesh(sharedGeometries.star, neonGreenMaterial);
          star.userData = { type: 'star', mass: 1000, velocity: new THREE.Vector3(0, 0, 0) };
          systemGroup.add(star);
          for (let i = 0; i < params.planets; i++) {
            const planet = new THREE.Mesh(sharedGeometries.planet, neonGreenMaterial);
            const orbitalRadius = (i + 1) * params.orbitalRadius / params.planets;
            planet.position.set(orbitalRadius, 0, 0);
            const v = Math.sqrt(G * star.userData.mass / orbitalRadius) * 1.5;
            planet.userData = {
              type: 'planet',
              mass: 10,
              velocity: new THREE.Vector3(0, 0, v),
              orbitalRadius
            };
            systemGroup.add(planet);
          }
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * 100
          );
          systemGroup.position.copy(camera.position).add(forward.multiplyScalar(1000)).add(offset);
          systemGroup.userData = { created: Date.now() };
          scene.add(systemGroup);
          systems.push(systemGroup);
          entityCount += 1 + params.planets;
          if (entityCount > 300) showPrompt(8);
          showPrompt(2);
          addConsoleMessage('Planetary system created ahead.');
          updateStatusOverlay();
        }

        function addGalaxy() {
          const params = trainingData.galaxies[Math.floor(Math.random() * trainingData.galaxies.length)];
          const galaxyGroup = new THREE.Group();
          const starCount = params.type === 'spiral' ? 10 : 5;
          for (let i = 0; i < starCount; i++) {
            const star = new THREE.Mesh(sharedGeometries.galaxyStar, neonGreenMaterial);
            const r = Math.random() * params.radius;
            const theta = Math.random() * Math.PI * 2;
            const phi = params.type === 'spiral' ? Math.random() * 0.2 : Math.random() * Math.PI;
            star.position.set(
              r * Math.sin(phi) * Math.cos(theta),
              r * Math.sin(phi) * Math.sin(theta),
              r * Math.cos(phi)
            );
            const v = Math.sqrt(G * 50 / r) * 1.5;
            const pos = star.position.clone();
            const tangent = new THREE.Vector3(-pos.y, pos.x, 0).normalize();
            star.userData = {
              type: 'star',
              mass: 50,
              velocity: tangent.multiplyScalar(v),
              angle: theta
            };
            galaxyGroup.add(star);
          }
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 200,
            (Math.random() - 0.5) * 200,
            (Math.random() - 0.5) * 200
          );
          galaxyGroup.position.copy(camera.position).add(forward.multiplyScalar(2000)).add(offset);
          galaxyGroup.userData = { radius: params.radius, created: Date.now() };
          scene.add(galaxyGroup);
          galaxies.push(galaxyGroup);
          entityCount += starCount;
          if (entityCount > 300) showPrompt(8);
          showPrompt(3);
          addConsoleMessage('Galaxy spawned with stars.');
          updateStatusOverlay();
        }

        function addNode() {
          const node = getNodeFromPool();
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * 100
          );
          node.position.copy(camera.position).add(forward.multiplyScalar(300)).add(offset);
          node.userData = { type: 'node', created: Date.now() };
          scene.add(node);
          nodes.push(node);
          entityCount++;

          if (nodes.length > 1) {
            const prevNode = nodes[nodes.length - 2];
            const geometry = new THREE.BufferGeometry().setFromPoints([
              prevNode.position,
              node.position
            ]);
            const line = new THREE.Line(geometry, lineMaterial);
            scene.add(line);
            nodeLines.push(line);
          }

          if (entityCount > 300) showPrompt(8);
          showPrompt(4);
          addConsoleMessage('Satellite node deployed.');
          updateStatusOverlay();
        }

        function shoot() {
          const projectile = getProjectileFromPool();
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          projectile.position.copy(camera.position).add(forward.multiplyScalar(10));
          projectile.userData = {
            type: 'projectile',
            velocity: forward.multiplyScalar(30),
            remove: false,
            instanceId: projectileCount
          };
          scene.add(projectile);
          projectiles.push(projectile);
          projectileCount++;
          updateProjectileInstances();
          showPrompt(5);
          addConsoleMessage('Projectile fired!');
          updateStatusOverlay();
        }

        function updateProjectileInstances() {
          if (projectileInstances) scene.remove(projectileInstances);
          projectileInstances = new THREE.InstancedMesh(sharedGeometries.projectile, neonGreenMaterial, projectileCount);
          const matrix = new THREE.Matrix4();
          projectiles.forEach((projectile, i) => {
            matrix.setPosition(projectile.position);
            projectileInstances.setMatrixAt(i, matrix);
          });
          scene.add(projectileInstances);
        }

        function reset() {
          comets.forEach(comet => {
            comet.visible = false;
            cometPool.push(comet);
            scene.remove(comet);
          });
          comets = [];
          systems.forEach(system => scene.remove(system));
          systems = [];
          galaxies.forEach(galaxy => scene.remove(galaxy));
          galaxies = [];
          projectiles.forEach(projectile => {
            projectile.visible = false;
            projectilePool.push(projectile);
            scene.remove(projectile);
          });
          projectiles = [];
          nodes.forEach(node => {
            node.visible = false;
            nodePool.push(node);
            scene.remove(node);
          });
          nodes = [];
          checkpoints.forEach(checkpoint => scene.remove(checkpoint));
          checkpoints = [];
          nodeLines.forEach(line => scene.remove(line));
          nodeLines = [];
          checkpointTexts.forEach(text => document.body.removeChild(text));
          checkpointTexts = [];
          if (cometInstances) {
            scene.remove(cometInstances);
            cometInstances = null;
          }
          if (projectileInstances) {
            scene.remove(projectileInstances);
            projectileInstances = null;
          }
          cometCount = 0;
          projectileCount = 0;
          entityCount = 0;
          autopilotActive = false;
          currentNodeIndex = 0;
          checkpointProgress = 0;
          throttle = 0;
          document.getElementById('autopilotBtn').classList.remove('active');
          document.getElementById('throttleBtn').classList.remove('active');
          document.getElementById('throttleIndicator').textContent = '';
          document.getElementById('throttleIndicator').classList.remove('active');
          showPrompt(6);
          addConsoleMessage('Galaxy reset to blank slate.');
          updateStatusOverlay();
        }

        // Throttle toggle
        function toggleThrottle() {
          throttle = throttle === 0 ? 225 : 0;
          document.getElementById('throttleBtn').classList.toggle('active', throttle > 0);
          const throttleIndicator = document.getElementById('throttleIndicator');
          throttleIndicator.textContent = throttle > 0 ? `Thrust: ${throttle}` : '';
          throttleIndicator.classList.toggle('active', throttle > 0);
          showPrompt(0);
          addConsoleMessage(throttle > 0 ? 'Manual throttle engaged!' : 'Throttle disengaged.');
          updateStatusOverlay();
        }

        // Autopilot
        function toggleAutopilot() {
          if (gameMode === 'explore' && checkpoints.length < 2) {
            showPrompt(7);
            addConsoleMessage('Need at least 2 checkpoints for autopilot.');
            return;
          }
          if (gameMode === 'craft' && nodes.length < 2) {
            showPrompt(7);
            addConsoleMessage('Need at least 2 nodes for autopilot.');
            return;
          }
          autopilotActive = !autopilotActive;
          document.getElementById('autopilotBtn').classList.toggle('active', autopilotActive);
          if (autopilotActive) {
            throttle = 0;
            document.getElementById('throttleBtn').classList.remove('active');
            document.getElementById('throttleIndicator').textContent = '';
            document.getElementById('throttleIndicator').classList.remove('active');
            currentNodeIndex = 0;
            showPrompt(9);
            addConsoleMessage('Autopilot engaged! Navigating nodes.');
          } else {
            showPrompt(0);
            addConsoleMessage('Autopilot disengaged.');
          }
          updateStatusOverlay();
        }

        function updateAutopilot(deltaTime) {
          if (!autopilotActive) return;
          const targets = gameMode === 'explore' ? checkpoints : nodes;
          if (targets.length === 0) return;
          const target = targets[currentNodeIndex];
          const direction = target.position.clone().sub(camera.position);
          const distance = direction.length();

          if (distance < 50 && gameMode === 'explore') {
            checkpointProgress = Math.max(checkpointProgress, currentNodeIndex + 1);
            const code = encodeWebXOS();
            addConsoleMessage(`Checkpoint ${currentNodeIndex + 1} reached! WebXOS Code: ${code}`);
            showPrompt(14);
            const text = document.createElement('div');
            text.className = 'checkpoint-text';
            text.textContent = `CHECKPOINT ${currentNodeIndex + 1}`;
            document.body.appendChild(text);
            checkpointTexts.push(text);
            setTimeout(() => {
              if (document.body.contains(text)) {
                document.body.removeChild(text);
                checkpointTexts = checkpointTexts.filter(t => t !== text);
              }
            }, 3000);
            currentNodeIndex = (currentNodeIndex + 1) % targets.length;
            addConsoleMessage(`Heading to ${gameMode === 'explore' ? 'checkpoint' : 'node'} ${currentNodeIndex + 1}.`);
          } else if (distance < 50) {
            currentNodeIndex = (currentNodeIndex + 1) % targets.length;
            addConsoleMessage(`Heading to ${gameMode === 'explore' ? 'checkpoint' : 'node'} ${currentNodeIndex + 1}.`);
          }

          direction.normalize();
          const speed = 225;
          velocity.copy(direction.multiplyScalar(speed));
          camera.position.add(velocity.clone().multiplyScalar(deltaTime));
          camera.lookAt(target.position);
        }

        // Viewing controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function updateRotation(deltaX, deltaY) {
          if (autopilotActive) return;
          rotationVelocity.yaw -= deltaX * 0.015;
          rotationVelocity.pitch -= deltaY * 0.015;
        }

        renderer.domElement.addEventListener('mousedown', e => {
          if (autopilotActive) return;
          isDragging = true;
          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', e => {
          if (isDragging && !autopilotActive) {
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            updateRotation(deltaX, deltaY);
            previousMousePosition = { x: e.clientX, y: e.clientY };
          }
        });

        renderer.domElement.addEventListener('mouseup', () => {
          isDragging = false;
        });

        renderer.domElement.addEventListener('touchstart', e => {
          if (autopilotActive) return;
          e.preventDefault();
          previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        renderer.domElement.addEventListener('touchmove', e => {
          if (autopilotActive) return;
          e.preventDefault();
          const deltaX = e.touches[0].clientX - previousMousePosition.x;
          const deltaY = e.touches[0].clientY - previousMousePosition.y;
          updateRotation(deltaX, deltaY);
          previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        // Console commands
        function handleCommand(input) {
          const cmd = input.trim().toLowerCase();
          if (!cmd.startsWith('/')) {
            addConsoleMessage('Commands must start with "/". Type /help for commands.');
            return;
          }
          const parts = cmd.slice(1).split(' ');
          const command = parts[0];
          const args = parts.slice(1);

          if (gameMode === 'explore' && ['add', 'shoot'].includes(command)) {
            addConsoleMessage('This command is not available in Explore Mode.');
            return;
          }

          switch (command) {
            case 'help':
              addConsoleMessage(gameMode === 'craft' ? 'Commands: /add comet, /add system, /add galaxy, /add node, /shoot, /reset, /throttle, /autopilot' : 'Commands: /reset, /throttle, /autopilot');
              break;
            case 'add':
              if (args[0] === 'comet') addComet();
              else if (args[0] === 'system') addPlanetarySystem();
              else if (args[0] === 'galaxy') addGalaxy();
              else if (args[0] === 'node') addNode();
              else addConsoleMessage('Invalid add command. Use: comet, system, galaxy, node');
              break;
            case 'shoot':
              shoot();
              break;
            case 'reset':
              reset();
              break;
            case 'throttle':
              if (autopilotActive) addConsoleMessage('Cannot toggle throttle during autopilot.');
              else toggleThrottle();
              break;
            case 'autopilot':
              toggleAutopilot();
              break;
            default:
              addConsoleMessage('Unknown command. Type /help for commands.');
          }
        }

        consoleInput.addEventListener('keydown', e => {
          if (e.key === 'Enter') {
            const input = consoleInput.value;
            if (input) {
              addConsoleMessage(`> ${input}`);
              handleCommand(input);
              consoleInput.value = '';
            }
          }
        });

        // Gravity simulation
        function computeGravity() {
          const allObjects = [];
          comets.forEach(comet => {
            if (comet.position.distanceTo(camera.position) < maxGravityDistance)
              allObjects.push({ obj: comet, pos: comet.position, mass: comet.userData.mass, vel: comet.userData.velocity });
          });
          systems.forEach(system => {
            system.children.forEach(child => {
              if (child.userData.type === 'star' || child.userData.type === 'planet' || child.userData.type === 'largePlanet') {
                const worldPos = new THREE.Vector3();
                child.getWorldPosition(worldPos);
                if (worldPos.distanceTo(camera.position) < maxGravityDistance)
                  allObjects.push({ obj: child, pos: worldPos, mass: child.userData.mass, vel: child.userData.velocity });
              }
            });
          });
          galaxies.forEach(galaxy => {
            galaxy.children.forEach(star => {
              const worldPos = new THREE.Vector3();
              star.getWorldPosition(worldPos);
              if (worldPos.distanceTo(camera.position) < maxGravityDistance)
                allObjects.push({ obj: star, pos: worldPos, mass: star.userData.mass, vel: star.userData.velocity });
            });
          });

          allObjects.forEach((a, i) => {
            let acc = new THREE.Vector3();
            for (let j = i + 1; j < allObjects.length; j++) {
              const b = allObjects[j];
              const delta = b.pos.clone().sub(a.pos);
              const distSq = delta.lengthSq() + softening * softening;
              if (delta.length() > maxGravityDistance) continue;
              const forceMag = (G * a.mass * b.mass) / distSq;
              const force = delta.normalize().multiplyScalar(forceMag);
              acc.add(force.divideScalar(a.mass));
              b.vel.sub(force.divideScalar(b.mass).multiplyScalar(0.5));
            }
            a.vel.add(acc);
          });
        }

        // Animation loop
        function animate() {
          requestAnimationFrame(animate);
          const now = performance.now();
          const deltaTime = Math.min((now - lastTime) / 1000, 0.05);
          lastTime = now;

          // Starship glow
          starshipGlow += deltaTime * glowSpeed;
          starship.material.color.setHSL(0.333, 1, 0.5 + Math.sin(starshipGlow) * 0.1);

          if (!autopilotActive) {
            if (keys.ArrowLeft) rotationVelocity.yaw += 0.075;
            if (keys.ArrowRight) rotationVelocity.yaw -= 0.075;
            if (keys.ArrowUp) rotationVelocity.pitch -= 0.075;
            if (keys.ArrowDown) rotationVelocity.pitch += 0.075;

            rotation.pitch += rotationVelocity.pitch * deltaTime;
            rotation.yaw += rotationVelocity.yaw * deltaTime;
            rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.pitch));
            rotationVelocity.pitch *= 0.95;
            rotationVelocity.yaw *= 0.95;
            camera.quaternion.setFromEuler(new THREE.Euler(rotation.pitch, rotation.yaw, 0, 'YXZ'));
          }

          if (!autopilotActive) {
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            velocity.copy(forward.multiplyScalar(throttle));
            camera.position.add(velocity.clone().multiplyScalar(deltaTime));
          } else {
            updateAutopilot(deltaTime);
          }

          computeGravity();
          cameraMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          frustum.setFromProjectionMatrix(cameraMatrix);

          // Limit to closest 300 entities
          const allEntities = [];
          comets.forEach(comet => allEntities.push({ obj: comet, pos: comet.position }));
          systems.forEach(system => {
            const pos = new THREE.Vector3();
            system.getWorldPosition(pos);
            allEntities.push({ obj: system, pos });
          });
          galaxies.forEach(galaxy => {
            const pos = new THREE.Vector3();
            galaxy.getWorldPosition(pos);
            allEntities.push({ obj: galaxy, pos });
          });
          nodes.forEach(node => allEntities.push({ obj: node, pos: node.position }));
          checkpoints.forEach(checkpoint => allEntities.push({ obj: checkpoint, pos: checkpoint.position }));

          allEntities.sort((a, b) => a.pos.distanceToSquared(camera.position) - b.pos.distanceToSquared(camera.position));
          const visibleEntities = allEntities.slice(0, 300);

          const matrix = new THREE.Matrix4();
          comets.forEach((comet, i) => {
            comet.visible = visibleEntities.some(e => e.obj === comet) && frustum.containsPoint(comet.position);
            if (comet.visible) {
              comet.position.add(comet.userData.velocity.clone().multiplyScalar(deltaTime));
              matrix.setPosition(comet.position);
              cometInstances.setMatrixAt(i, matrix);
            }
          });
          if (cometInstances) cometInstances.instanceMatrix.needsUpdate = true;

          systems.forEach(system => {
            system.visible = visibleEntities.some(e => e.obj === system) && frustum.containsPoint(system.position);
            if (system.visible && system.children.length > 0) {
              system.children.forEach(child => {
                if (child.userData.mass) {
                  const worldPos = new THREE.Vector3();
                  child.getWorldPosition(worldPos);
                  worldPos.add(child.userData.velocity.clone().multiplyScalar(deltaTime));
                  const localPos = worldPos.sub(system.position);
                  child.position.copy(localPos);
                }
              });
            }
          });

          galaxies.forEach(galaxy => {
            galaxy.visible = visibleEntities.some(e => e.obj === galaxy) && frustum.containsPoint(galaxy.position);
            if (galaxy.visible) {
              galaxy.children.forEach(star => {
                const worldPos = new THREE.Vector3();
                star.getWorldPosition(worldPos);
                worldPos.add(star.userData.velocity.clone().multiplyScalar(deltaTime));
                const localPos = worldPos.sub(galaxy.position);
                star.position.copy(localPos);
              });
            }
          });

          nodes.forEach(node => {
            node.visible = visibleEntities.some(e => e.obj === node) && frustum.containsPoint(node.position);
          });

          checkpoints.forEach(checkpoint => {
            checkpoint.visible = visibleEntities.some(e => e.obj === checkpoint) && frustum.containsPoint(checkpoint.position);
          });

          nodeLines.forEach((line, i) => {
            const targets = gameMode === 'explore' ? checkpoints : nodes;
            if (i < targets.length - 1) {
              const geometry = new THREE.BufferGeometry().setFromPoints([
                targets[i].position,
                targets[i + 1].position
              ]);
              line.geometry.dispose();
              line.geometry = geometry;
            }
          });

          let projectilesToRemove = [];
          projectiles.forEach((projectile, pIndex) => {
            if (projectile.userData.remove) return;
            projectile.position.add(projectile.userData.velocity.clone().multiplyScalar(deltaTime));
            if (projectile.position.length() > 2000) {
              projectile.userData.remove = true;
              projectilesToRemove.push(pIndex);
              return;
            }
            matrix.setPosition(projectile.position);
            projectileInstances.setMatrixAt(pIndex, matrix);

            if (!frustum.containsPoint(projectile.position)) return;

            let hits = [];
            const now = Date.now();
            const relativePos = projectile.position.clone();

            comets.forEach((comet, index) => {
              if (!comet.visible) return;
              const age = (now - comet.userData.created) / 1000;
              const distance = relativePos.distanceTo(comet.position);
              if (distance < 20) hits.push({ type: 'comet', obj: comet, index, age });
            });

            systems.forEach((system, index) => {
              if (!system.visible) return;
              const age = (now - system.userData.created) / 1000;
              if (relativePos.distanceTo(system.position) < 100) {
                hits.push({ type: 'system', obj: system, index, age });
                return;
              }
              for (let child of system.children) {
                if (child.userData.type === 'star' || child.userData.type === 'planet' || child.userData.type === 'largePlanet') {
                  const worldPos = new THREE.Vector3();
                  child.getWorldPosition(worldPos);
                  const distance = relativePos.distanceTo(worldPos);
                  const threshold = child.userData.type === 'star' ? 100 : 50;
                  if (distance < threshold) {
                    hits.push({ type: 'system', obj: system, index, age });
                    break;
                  }
                }
              }
            });

            galaxies.forEach((galaxy, index) => {
              if (!galaxy.visible) return;
              const age = (now - galaxy.userData.created) / 1000;
              if (relativePos.distanceTo(galaxy.position) < 200) {
                hits.push({ type: 'galaxy', obj: galaxy, index, age });
                return;
              }
              for (let star of galaxy.children) {
                const worldPos = new THREE.Vector3();
                star.getWorldPosition(worldPos);
                const distance = relativePos.distanceTo(worldPos);
                if (distance < 50) {
                  hits.push({ type: 'galaxy', obj: galaxy, index, age });
                  break;
                }
              }
            });

            nodes.forEach((node, index) => {
              if (!node.visible) return;
              const age = (now - node.userData.created) / 1000;
              const distance = relativePos.distanceTo(node.position);
              if (distance < 20) hits.push({ type: 'node', obj: node, index, age });
            });

            if (hits.length > 0) {
              hits.sort((a, b) => a.age - b.age);
              for (let hit of hits) {
                scene.remove(hit.obj);
                if (hit.type === 'comet') {
                  comets.splice(hit.index, 1);
                  cometPool.push(hit.obj);
                  cometCount--;
                  entityCount--;
                  updateCometInstances();
                  addConsoleMessage('Comet destroyed.');
                } else if (hit.type === 'system') {
                  systems.splice(hit.index, 1);
                  entityCount -= hit.obj.children.length || 1;
                  addConsoleMessage('Planetary system destroyed.');
                } else if (hit.type === 'galaxy') {
                  galaxies.splice(hit.index, 1);
                  entityCount -= hit.obj.children.length;
                  addConsoleMessage('Galaxy destroyed.');
                } else if (hit.type === 'node') {
                  nodes.splice(hit.index, 1);
                  nodePool.push(hit.obj);
                  entityCount--;
                  nodeLines.forEach(line => scene.remove(line));
                  nodeLines = [];
                  for (let i = 0; i < nodes.length - 1; i++) {
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                      nodes[i].position,
                      nodes[i + 1].position
                    ]);
                    const line = new THREE.Line(geometry, lineMaterial);
                    scene.add(line);
                    nodeLines.push(line);
                  }
                  addConsoleMessage('Node destroyed.');
                }
                updateStatusOverlay();
              }
              projectile.userData.remove = true;
              projectilesToRemove.push(pIndex);
            }
          });

          if (projectileInstances) projectileInstances.instanceMatrix.needsUpdate = true;

          projectilesToRemove.sort((a, b) => b - a);
          projectilesToRemove.forEach(idx => {
            const projectile = projectiles[idx];
            projectile.visible = false;
            projectilePool.push(projectile);
            scene.remove(projectile);
            projectiles.splice(idx, 1);
            projectileCount--;
            updateProjectileInstances();
          });

          // Update checkpoint text positions
          checkpointTexts.forEach(text => {
            const checkpoint = checkpoints.find(cp => text.textContent.includes(`CHECKPOINT ${cp.userData.index + 1}`));
            if (checkpoint) {
              const screenPos = checkpoint.position.clone().project(camera);
              text.style.left = `${(screenPos.x * 0.5 + 0.5) * window.innerWidth}px`;
              text.style.top = `${(-screenPos.y * 0.5 + 0.5) * window.innerHeight}px`;
            }
          });

          renderer.render(scene, camera);
        }

        // Controls
        try {
          const throttleBtn = document.getElementById('throttleBtn');
          const addCometBtn = document.getElementById('addComet');
          const addSystemBtn = document.getElementById('addSystem');
          const addGalaxyBtn = document.getElementById('addGalaxy');
          const addNodeBtn = document.getElementById('addNode');
          const autopilotBtn = document.getElementById('autopilotBtn');
          const shootBtn = document.getElementById('shootBtn');
          const resetBtn = document.getElementById('resetBtn');
          const prompt = document.getElementById('prompt');

          if (!throttleBtn || !addCometBtn || !addSystemBtn || !addGalaxyBtn || !addNodeBtn || !autopilotBtn || !shootBtn || !resetBtn || !prompt) {
            throw new Error('One or more control elements not found');
          }

          throttleBtn.addEventListener('click', () => {
            if (autopilotActive) return;
            toggleThrottle();
          });

          addCometBtn.addEventListener('click', addComet);
          addSystemBtn.addEventListener('click', addPlanetarySystem);
          addGalaxyBtn.addEventListener('click', addGalaxy);
          addNodeBtn.addEventListener('click', addNode);
          autopilotBtn.addEventListener('click', toggleAutopilot);
          shootBtn.addEventListener('click', shoot);
          resetBtn.addEventListener('click', reset);

          const prompts = [
            "Manual throttle engaged!",
            "Comet added to your galaxy.",
            "Planetary system created ahead.",
            "Galaxy spawned with stars.",
            "Satellite node deployed.",
            "Projectile fired!",
            "Galaxy reset to blank slate.",
            "Need at least 2 nodes for autopilot!",
            "Warning: Adding more may slow performance!",
            "Autopilot engaged! Navigating nodes.",
            "Explore Mode: Follow the checkpoints!",
            "Craft Mode: Build your galaxy!",
            "Progress saved! Check console for WebXOS code.",
            "Game state loaded successfully!",
            "Checkpoint reached! Code generated."
          ];

          function showPrompt(index) {
            prompt.textContent = prompts[index];
            prompt.classList.add('active');
            setTimeout(() => prompt.classList.remove('active'), 1500);
          }
        } catch (e) {
          console.error('Control setup error:', e);
          addConsoleMessage('Error setting up controls. Please refresh.');
        }

        // Initialize
        try {
          addConsoleMessage('Galaxycraft v2.0 Cyber Edition initialized. Type /help for commands.');
          updateStatusOverlay();
          updateControlsVisibility();
          animate();
        } catch (e) {
          console.error('Initialization error:', e);
          addConsoleMessage('Initialization failed. Please refresh.');
        }

        // Resize
        window.addEventListener('resize', () => {
          try {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          } catch (e) {
            console.error('Resize error:', e);
            addConsoleMessage('Error handling resize. Please refresh.');
          }
        });

        // Keyboard controls
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        window.addEventListener('keydown', e => {
          if (e.key in keys) {
            keys[e.key] = true;
            e.preventDefault();
          }
        });
        window.addEventListener('keyup', e => {
          if (e.key in keys) keys[e.key] = false;
        });
      }...

Something went wrong, please refresh to reconnect or try again.
