<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Galaxycraft - WebGL with Quantum Tile Weave</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, sans-serif; }
    body { background: #000; color: #fff; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
    #cosmicCanvas { flex: 1; width: 100%; touch-action: none; position: relative; }
    canvas { width: 100%; height: 100%; }
    .controls {
      position: fixed; bottom: 0; width: 100%; background: rgba(20, 20, 50, 0.9);
      padding: 10px; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;
      backdrop-filter: blur(5px); z-index: 10;
    }
    button {
      background: #4a90e2; border: none; padding: 10px 20px; color: white;
      border-radius: 20px; cursor: pointer; font-size: 16px; transition: transform 0.2s, background 0.2s;
    }
    button:hover { background: #357abd; }
    button.active { background: #ff4444; }
    .debug-overlay {
      position: absolute; top: 10px; left: 10px; background: rgba(0, 0, 0, 0.5);
      padding: 5px; font-size: 12px; color: #0f0; z-index: 5; pointer-events: none;
    }
    .console {
      position: absolute; bottom: 60px; width: 100%; height: 25%; background: rgba(0, 0, 0, 0.5);
      display: flex; flex-direction: column; z-index: 5; padding: 5px;
    }
    .console-log {
      flex: 1; overflow-y: auto; font-size: 12px; color: #fff; text-shadow: 0 0 2px #000; padding: 5px;
    }
    .console-input {
      width: 100%; background: rgba(255, 255, 255, 0.1); border: 1px solid #4a90e2;
      color: #fff; padding: 5px; font-size: 12px; outline: none;
    }
  </style>
</head>
<body>
  <div id="cosmicCanvas"></div>
  <div class="controls">
    <button id="throttleBtn">Full Throttle</button>
    <button id="matrixBtn">Run Matrix Op</button>
    <button id="addComet">Add Comet</button>
    <button id="autopilotBtn">Autopilot</button>
    <button id="debugWeave">Toggle Weave Debug</button>
  </div>
  <div id="debugOverlay" class="debug-overlay"></div>
  <div id="console" class="console">
    <div id="consoleLog" class="console-log"></div>
    <input id="consoleInput" class="console-input" type="text" placeholder="Type /help for commands...">
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
  <script>
    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 20000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('cosmicCanvas').appendChild(renderer.domElement);
    camera.position.set(0, 0, 100);

    // Particle setup
    const maxParticles = 1000;
    const instanceData = Array(maxParticles).fill().map(() => ({
      active: false,
      type: 0, // 1=comet
      pos: [0, 0, 0],
      vel: [0, 0, 0]
    }));
    let entityCount = 0;

    // Comet instanced mesh
    const cometGeometry = new THREE.SphereGeometry(5, 16, 16);
    const cometMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const cometInstanceMesh = new THREE.InstancedMesh(cometGeometry, cometMaterial, maxParticles);
    scene.add(cometInstanceMesh);

    // Quantum Tile Weave setup
    const noise = new SimplexNoise();
    const tileSize = 16;
    const weaveSize = 32;
    const weaveTexture = new THREE.WebGLRenderTarget(weaveSize, weaveSize, {
      format: THREE.RGBAFormat,
      type: THREE.FloatType
    });
    const matrixTextures = {
      A: new THREE.DataTexture(new Float32Array(tileSize * tileSize * 4), tileSize, tileSize, THREE.RGBAFormat, THREE.FloatType),
      B: new THREE.DataTexture(new Float32Array(tileSize * tileSize * 4), tileSize, tileSize, THREE.RGBAFormat, THREE.FloatType),
      C: new THREE.DataTexture(new Float32Array(tileSize * tileSize * 4), tileSize, tileSize, THREE.RGBAFormat, THREE.FloatType),
      D: new THREE.DataTexture(new Float32Array(tileSize * tileSize * 4), tileSize, tileSize, THREE.RGBAFormat, THREE.FloatType)
    };
    Object.values(matrixTextures).forEach(tex => tex.needsUpdate = true);

    // QTW shader
    const qtwShader = {
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D weaveTex;
        uniform sampler2D matrixA;
        uniform sampler2D matrixB;
        uniform sampler2D matrixC;
        uniform float time;
        uniform vec2 resolution;
        varying vec2 vUv;
        float simplex(vec3 p) { return 0.0; } // Placeholder for Simplex noise
        void main() {
          vec2 weaveUv = vUv * ${weaveSize}.0 / ${tileSize}.0;
          vec4 weaveData = texture2D(weaveTex, weaveUv);
          float noiseVal = simplex(vec3(vUv * 10.0, time));
          vec4 a = texture2D(matrixA, vUv);
          vec4 b = texture2D(matrixB, vUv);
          vec4 c = texture2D(matrixC, vUv);
          vec4 d = vec4(0.0);
          for (int k = 0; k < ${tileSize}; k++) {
            vec4 aTile = texture2D(matrixA, vec2(float(k) / ${tileSize}.0, vUv.y));
            vec4 bTile = texture2D(matrixB, vec2(vUv.x, float(k) / ${tileSize}.0));
            d += aTile * bTile * (1.0 + noiseVal * 0.1);
          }
          d += c;
          gl_FragColor = d * weaveData;
        }
      `,
      uniforms: {
        weaveTex: { value: weaveTexture.texture },
        matrixA: { value: matrixTextures.A },
        matrixB: { value: matrixTextures.B },
        matrixC: { value: matrixTextures.C },
        time: { value: 0 },
        resolution: { value: new THREE.Vector2(weaveSize, weaveSize) }
      }
    };
    const qtwMaterial = new THREE.ShaderMaterial(qtwShader);
    const qtwPlane = new THREE.Mesh(new THREE.PlaneGeometry(weaveSize, weaveSize), qtwMaterial);
    qtwPlane.visible = false;
    scene.add(qtwPlane);

    // Debug weave visualization
    const debugWeaveMaterial = new THREE.ShaderMaterial({
      vertexShader: qtwShader.vertexShader,
      fragmentShader: `
        uniform sampler2D weaveTex;
        varying vec2 vUv;
        void main() {
          vec4 weaveData = texture2D(weaveTex, vUv);
          gl_FragColor = vec4(weaveData.rgb * 0.5 + 0.5, 1.0);
        }
      `,
      uniforms: { weaveTex: { value: weaveTexture.texture } }
    });
    const debugWeavePlane = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), debugWeaveMaterial);
    debugWeavePlane.position.set(0, 0, -50);
    debugWeavePlane.visible = false;
    scene.add(debugWeavePlane);

    // Game state
    let throttle = 0;
    let autopilot = false;
    let debugWeave = false;
    let time = 0;

    // Controls
    document.getElementById('throttleBtn').addEventListener('click', () => {
      throttle = throttle === 0 ? 150 : 0;
      logConsole(`Throttle: ${throttle}`);
    });
    document.getElementById('matrixBtn').addEventListener('click', () => {
      runMatrixOp();
      logConsole('Matrix operation executed');
    });
    document.getElementById('addComet').addEventListener('click', () => addEntity(1));
    document.getElementById('autopilotBtn').addEventListener('click', () => {
      autopilot = !autopilot;
      logConsole(`Autopilot: ${autopilot}`);
    });
    document.getElementById('debugWeave').addEventListener('click', () => {
      debugWeave = !debugWeave;
      debugWeavePlane.visible = debugWeave;
      logConsole(`Debug Weave: ${debugWeave}`);
    });

    // Console
    const consoleLog = document.getElementById('consoleLog');
    const consoleInput = document.getElementById('consoleInput');
    consoleInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && consoleInput.value) {
        processCommand(consoleInput.value);
        consoleInput.value = '';
      }
    });

    function logConsole(message) {
      const p = document.createElement('p');
      p.textContent = message;
      consoleLog.appendChild(p);
      consoleLog.scrollTop = consoleLog.scrollHeight;
    }

    function processCommand(cmd) {
      logConsole(`> ${cmd}`);
      if (cmd === '/help') {
        logConsole('Commands: /throttle, /matrix, /comet, /autopilot, /debug');
      } else if (cmd === '/throttle') {
        throttle = throttle === 0 ? 150 : 0;
        logConsole(`Throttle: ${throttle}`);
      } else if (cmd === '/matrix') {
        runMatrixOp();
        logConsole('Matrix operation executed');
      } else if (cmd === '/comet') {
        addEntity(1);
      } else if (cmd === '/autopilot') {
        autopilot = !autopilot;
        logConsole(`Autopilot: ${autopilot}`);
      } else if (cmd === '/debug') {
        debugWeave = !debugWeave;
        debugWeavePlane.visible = debugWeave;
        logConsole(`Debug Weave: ${debugWeave}`);
      } else {
        logConsole('Unknown command');
      }
    }

    function addEntity(type) {
      if (entityCount < maxParticles) {
        const idx = instanceData.findIndex(d => !d.active);
        instanceData[idx] = {
          active: true,
          type,
          pos: [Math.random() * 200 - 100, Math.random() * 200 - 100, -50],
          vel: [Math.random() * 2 - 1, Math.random() * 2 - 1, 0]
        };
        entityCount++;
        logConsole(`Added ${type === 1 ? 'comet' : 'unknown'} at index ${idx}`);
      }
    }

    function runMatrixOp() {
      // Initialize matrices with random data
      for (let i = 0; i < tileSize * tileSize; i++) {
        matrixTextures.A.image.data[i * 4] = Math.random();
        matrixTextures.B.image.data[i * 4] = Math.random();
        matrixTextures.C.image.data[i * 4] = Math.random();
      }
      matrixTextures.A.needsUpdate = true;
      matrixTextures.B.needsUpdate = true;
      matrixTextures.C.needsUpdate = true;

      // Render QTW pass
      renderer.setRenderTarget(weaveTexture);
      qtwPlane.visible = true;
      renderer.render(scene, camera);
      qtwPlane.visible = false;
      renderer.setRenderTarget(null);

      // Apply result to comet positions (example)
      const resultData = new Float32Array(tileSize * tileSize * 4);
      renderer.readRenderTargetPixels(weaveTexture, 0, 0, weaveSize, weaveSize, resultData);
      instanceData.forEach((data, idx) => {
        if (data.active && data.type === 1) {
          const val = resultData[idx % (tileSize * tileSize) * 4];
          data.pos[0] += val * 0.1;
          data.pos[1] += val * 0.1;
        }
      });
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;

      // Update particles
      const matrix = new THREE.Matrix4();
      let cometCount = 0;
      instanceData.forEach((data, idx) => {
        if (data.active) {
          data.pos[0] += data.vel[0] * throttle * 0.016;
          data.pos[1] += data.vel[1] * throttle * 0.016;
          matrix.setPosition(data.pos[0], data.pos[1], data.pos[2]);
          cometInstanceMesh.setMatrixAt(idx, matrix);
          if (data.type === 1) cometCount++;
        } else {
          matrix.setPosition(0, 0, 10000);
          cometInstanceMesh.setMatrixAt(idx, matrix);
        }
      });
      cometInstanceMesh.instanceMatrix.needsUpdate = true;

      // Update camera
      camera.position.z -= throttle * 0.016;
      if (autopilot) {
        const target = instanceData.find(d => d.active && d.type === 1);
        if (target) {
          camera.position.x += (target.pos[0] - camera.position.x) * 0.01;
          camera.position.y += (target.pos[1] - camera.position.y) * 0.01;
        }
      }

      // Update debug overlay
      document.getElementById('debugOverlay').textContent = `
        Entities: ${entityCount}
        Comets: ${cometCount}
        Throttle: ${throttle}
        Autopilot: ${autopilot}
        Weave Debug: ${debugWeave}
      `;

      // Render
      renderer.render(scene, camera);
    }
    animate();

    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
