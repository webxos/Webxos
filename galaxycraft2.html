<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Galaxycraft - WebGL with Quantum Tile Weave</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, sans-serif; }
    body { background: #000; color: #fff; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
    #cosmicCanvas { flex: 1; width: 100%; touch-action: none; position: relative; }
    canvas { width: 100%; height: 100%; }
    .controls {
      position: fixed; bottom: 0; width: 100%; background: rgba(20, 20, 50, 0.9);
      padding: 10px; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;
      backdrop-filter: blur(5px); z-index: 10;
    }
    .control-item { flex: 1; min-width: 80px; text-align: center; }
    button {
      background: #4a90e2; border: none; padding: 10px 20px; color: white;
      border-radius: 20px; cursor: pointer; font-size: 16px; transition: transform 0.2s, background 0.2s;
    }
    button:hover { background: #357abd; }
    button.active { background: #ff4444; }
    button:active { transform: scale(0.95); }
    .prompt {
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8); padding: 10px; border-radius: 10px; font-size: 14px;
      max-width: 90%; text-align: center; opacity: 0; transition: opacity 0.5s; z-index: 5;
    }
    .prompt.active { opacity: 1; }
    .hud {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
      opacity: 0.4; z-index: 1;
    }
    .hud::before {
      content: ''; position: absolute; top: 10%; left: 10%; right: 10%; bottom: 10%;
      border: 2px solid rgba(74, 144, 226, 0); border-radius: 20px; box-shadow: none;
    }
    .hud::after {
      content: '+'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: #4a90e2; font-size: 24px;
    }
    .throttle-indicator {
      position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
      color: #4a90e2; font-size: 12px; opacity: 0; transition: opacity 0.3s; z-index: 5;
    }
    .throttle-indicator.active { opacity: 1; }
    .status-overlay {
      position: absolute; top: 0; width: 100%; background: rgba(0, 0, 0, 0.3);
      padding: 5px 10px; font-size: 12px; text-align: left; color: #fff;
      text-shadow: 0 0 2px #000; z-index: 5; pointer-events: none;
    }
    .debug-overlay {
      position: absolute; top: 30px; left: 10px; background: rgba(0, 0, 0, 0.5);
      padding: 5px; font-size: 12px; color: #0f0; z-index: 5; pointer-events: none;
    }
    .console {
      position: absolute; bottom: 60px; width: 100%; height: 25%; background: rgba(0, 0, 0, 0.5);
      display: flex; flex-direction: column; z-index: 5; padding: 5px;
    }
    .console-log {
      flex: 1; overflow-y: auto; font-size: 12px; color: #fff; text-shadow: 0 0 2px #000; padding: 5px;
    }
    .console-log p { margin: 2px 0; }
    .console-input {
      width: 100%; background: rgba(255, 255, 255, 0.1); border: 1px solid #4a90e2;
      color: #fff; padding: 5px; font-size: 12px; outline: none;
    }
    .console::-webkit-scrollbar { width: 8px; }
    .console::-webkit-scrollbar-thumb { background: #4a90e2; border-radius: 4px; }
    .error-message {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(255, 50, 50, 0.9); padding: 20px; border-radius: 10px;
      color: white; text-align: center; z-index: 100;
    }
  </style>
</head>
<body>
  <div id="cosmicCanvas">
    <div class="hud"></div>
    <div id="statusOverlay" class="status-overlay"></div>
    <div id="debugOverlay" class="debug-overlay"></div>
    <div id="throttleIndicator" class="throttle-indicator"></div>
    <div id="console" class="console">
      <div id="consoleLog" class="console-log"></div>
      <input id="consoleInput" class="console-input" type="text" placeholder="Type /help for commands...">
    </div>
  </div>
  <div class="controls">
    <div class="control-item"><button id="throttleBtn">Full Throttle</button></div>
    <div class="control-item"><button id="addComet">Add Comet</button></div>
    <div class="control-item"><button id="addSystem">Add System</button></div>
    <div class="control-item"><button id="addGalaxy">Add Galaxy</button></div>
    <div class="control-item"><button id="addNode">Add Node</button></div>
    <div class="control-item"><button id="autopilotBtn">Autopilot</button></div>
    <div class="control-item"><button id="shootBtn">Shoot</button></div>
    <div class="control-item"><button id="resetBtn">Reset</button></div>
    <div class="control-item"><button id="matrixBtn">Matrix Op</button></div>
  </div>
  <div id="prompt" class="prompt"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    window.onload = () => {
      try {
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        document.getElementById('cosmicCanvas').appendChild(renderer.domElement);
        camera.position.set(0, 0, 100);
        camera.lookAt(0, 0, 0);

        // Reference objects
        const refSphere = new THREE.Mesh(
          new THREE.SphereGeometry(5, 16, 16),
          new THREE.MeshBasicMaterial({ color: 0xff0000 })
        );
        refSphere.position.set(0, 0, 0);
        scene.add(refSphere);

        const gridHelper = new THREE.GridHelper(100, 10, 0x00ff00, 0x00ff00);
        scene.add(gridHelper);

        // Particle setup
        const maxParticles = 200;
        const instanceData = Array(maxParticles).fill().map(() => ({
          active: false,
          type: 0, // 1=comet, 2=projectile, 3=node
          created: 0,
          pos: [0, 0, 0],
          vel: [0, 0, 0],
          mass: 0
        }));
        let entityCount = 0;

        // Geometries and materials
        const sharedGeometries = {
          comet: new THREE.SphereGeometry(15, 32, 32),
          projectile: new THREE.SphereGeometry(10, 32, 32),
          node: new THREE.BoxGeometry(30, 30, 30)
        };
        const sharedMaterials = {
          comet: new THREE.MeshBasicMaterial({ color: 0xffffff }),
          projectile: new THREE.MeshBasicMaterial({ color: 0xffff00 }),
          node: new THREE.MeshBasicMaterial({ color: 0xff00ff })
        };

        // Instanced meshes
        const cometInstanceMesh = new THREE.InstancedMesh(sharedGeometries.comet, sharedMaterials.comet, maxParticles);
        const projectileInstanceMesh = new THREE.InstancedMesh(sharedGeometries.projectile, sharedMaterials.projectile, maxParticles);
        const nodeInstanceMesh = new THREE.InstancedMesh(sharedGeometries.node, sharedMaterials.node, maxParticles);
        scene.add(cometInstanceMesh, projectileInstanceMesh, nodeInstanceMesh);

        // Game state
        let throttle = 0;
        let velocity = [0, 0, 0];
        let autopilotActive = false;
        let currentNodeIndex = 0;
        let lastTime = performance.now();
        let time = 0;

        // Simulated data
        const trainingData = {
          comets: Array(100).fill().map(() => ({
            semiMajorAxis: Math.random() * 50 + 20,
            eccentricity: Math.random() * 0.8,
            velocity: Math.random() * 3 + 1
          })),
          systems: Array(50).fill().map(() => ({
            planets: Math.floor(Math.random() * 3) + 1,
            orbitalRadius: Math.random() * 100 + 50
          })),
          galaxies: Array(20).fill().map(() => ({
            radius: Math.random() * 300 + 150,
            type: ['spiral', 'elliptical'][Math.floor(Math.random() * 2)]
          }))
        };

        // UI elements
        const statusOverlay = document.getElementById('statusOverlay');
        const debugOverlay = document.getElementById('debugOverlay');
        const consoleLog = document.getElementById('consoleLog');
        const consoleInput = document.getElementById('consoleInput');
        const throttleIndicator = document.getElementById('throttleIndicator');
        const prompt = document.getElementById('prompt');
        const maxLogMessages = 50;
        let logMessages = [];

        function addConsoleMessage(message) {
          const timestamp = new Date().toLocaleTimeString();
          logMessages.push(`[${timestamp}] ${message}`);
          if (logMessages.length > maxLogMessages) logMessages.shift();
          consoleLog.innerHTML = logMessages.map(msg => `<p>${msg}</p>`).join('');
          consoleLog.scrollTop = consoleLog.scrollHeight;
        }

        function updateStatusOverlay(cometCount, projectileCount, nodeCount) {
          statusOverlay.textContent = `Entities: ${entityCount} | Comets: ${cometCount} | Projectiles: ${projectileCount} | Nodes: ${nodeCount} | Throttle: ${throttle} | Autopilot: ${autopilotActive ? 'On' : 'Off'} | Camera: [${camera.position.toArray().map(v => v.toFixed(2)).join(', ')}]`;
        }

        // Input handling
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        window.addEventListener('keydown', e => {
          if (e.key in keys) { keys[e.key] = true; e.preventDefault(); }
        });
        window.addEventListener('keyup', e => {
          if (e.key in keys) keys[e.key] = false;
        });

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        renderer.domElement.addEventListener('mousedown', e => {
          if (autopilotActive) return;
          isDragging = true;
          previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        renderer.domElement.addEventListener('mousemove', e => {
          if (isDragging && !autopilotActive) {
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            camera.rotationVelocity = camera.rotationVelocity || { pitch: 0, yaw: 0 };
            camera.rotationVelocity.yaw -= deltaX * 0.01;
            camera.rotationVelocity.pitch -= deltaY * 0.01;
            previousMousePosition = { x: e.clientX, y: e.clientY };
          }
        });
        renderer.domElement.addEventListener('mouseup', () => isDragging = false);
        renderer.domElement.addEventListener('touchstart', e => {
          if (autopilotActive) return;
          e.preventDefault();
          previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });
        renderer.domElement.addEventListener('touchmove', e => {
          if (autopilotActive) return;
          e.preventDefault();
          const deltaX = e.touches[0].clientX - previousMousePosition.x;
          const deltaY = e.touches[0].clientY - previousMousePosition.y;
          camera.rotationVelocity = camera.rotationVelocity || { pitch: 0, yaw: 0 };
          camera.rotationVelocity.yaw -= deltaX * 0.01;
          camera.rotationVelocity.pitch -= deltaY * 0.01;
          previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        // Console commands
        consoleInput.addEventListener('keydown', e => {
          if (e.key === 'Enter' && consoleInput.value) {
            addConsoleMessage(`> ${consoleInput.value}`);
            handleCommand(consoleInput.value);
            consoleInput.value = '';
          }
        });

        function handleCommand(input) {
          const cmd = input.trim().toLowerCase();
          if (!cmd.startsWith('/')) {
            addConsoleMessage('Commands must start with "/". Type /help for commands.');
            return;
          }
          const parts = cmd.slice(1).split(' ');
          const command = parts[0];
          const args = parts.slice(1);

          switch (command) {
            case 'help':
              addConsoleMessage('Commands: /add comet, /add system, /add galaxy, /add node, /shoot, /reset, /throttle, /autopilot, /matrix');
              break;
            case 'add':
              if (args[0] === 'comet') addComet();
              else if (args[0] === 'system') addSystem();
              else if (args[0] === 'galaxy') addGalaxy();
              else if (args[0] === 'node') addNode();
              else addConsoleMessage('Invalid add command. Use: comet, system, galaxy, node');
              break;
            case 'shoot':
              shoot();
              break;
            case 'reset':
              reset();
              break;
            case 'throttle':
              toggleThrottle();
              break;
            case 'autopilot':
              toggleAutopilot();
              break;
            case 'matrix':
              addConsoleMessage('Matrix operation disabled for debugging.');
              break;
            default:
              addConsoleMessage('Unknown command. Type /help for commands.');
          }
        }

        // Entity management
        function addComet() {
          const params = trainingData.comets[Math.floor(Math.random() * trainingData.comets.length)];
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const position = camera.position.clone().add(forward.multiplyScalar(50));
          addParticle(1, position, [(Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5], 1);
          showPrompt(1);
          addConsoleMessage(`Comet added at [${position.toArray().map(v => v.toFixed(2)).join(', ')}]`);
        }

        function addSystem() {
          const params = trainingData.systems[Math.floor(Math.random() * trainingData.systems.length)];
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const basePos = camera.position.clone().add(forward.multiplyScalar(100));
          addParticle(1, basePos, [0, 0, 0], 1000);
          for (let i = 0; i < params.planets; i++) {
            const r = (i + 1) * params.orbitalRadius / params.planets;
            const v = Math.sqrt(100 * 1000 / r);
            addParticle(1, [basePos.x + r, basePos.y, basePos.z], [0, 0, v], 10);
          }
          entityCount += 1 + params.planets;
          showPrompt(2);
          addConsoleMessage(`System added at [${basePos.toArray().map(v => v.toFixed(2)).join(', ')}]`);
        }

        function addGalaxy() {
          const params = trainingData.galaxies[Math.floor(Math.random() * trainingData.galaxies.length)];
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const basePos = camera.position.clone().add(forward.multiplyScalar(100));
          const starCount = params.type === 'spiral' ? 10 : 5;
          for (let i = 0; i < starCount; i++) {
            const r = Math.random() * params.radius;
            const theta = Math.random() * Math.PI * 2;
            const phi = params.type === 'spiral' ? Math.random() * 0.2 : Math.random() * Math.PI;
            const pos = [
              basePos.x + r * Math.sin(phi) * Math.cos(theta),
              basePos.y + r * Math.sin(phi) * Math.sin(theta),
              basePos.z + r * Math.cos(phi)
            ];
            const v = Math.sqrt(100 * 50 / r);
            const tangent = [-pos[1] + basePos.y, pos[0] - basePos.x, 0];
            const len = Math.sqrt(tangent[0] ** 2 + tangent[1] ** 2);
            tangent[0] /= len || 1;
            tangent[1] /= len || 1;
            addParticle(1, pos, [tangent[0] * v, tangent[1] * v, 0], 50);
          }
          entityCount += starCount;
          showPrompt(3);
          addConsoleMessage(`Galaxy added at [${basePos.toArray().map(v => v.toFixed(2)).join(', ')}]`);
        }

        function addNode() {
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const position = camera.position.clone().add(forward.multiplyScalar(50));
          addParticle(3, position, [0, 0, 0], 0);
          showPrompt(4);
          addConsoleMessage(`Node added at [${position.toArray().map(v => v.toFixed(2)).join(', ')}]`);
        }

        function shoot() {
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const position = camera.position.clone().add(forward.multiplyScalar(10));
          const velocity = forward.multiplyScalar(50).toArray();
          addParticle(2, position, velocity, 0);
          showPrompt(5);
          addConsoleMessage(`Projectile fired from [${position.toArray().map(v => v.toFixed(2)).join(', ')}]`);
        }

        function addParticle(type, position, velocity, mass) {
          // Validate inputs
          const pos = Array.isArray(position) ? position : [position.x, position.y, position.z];
          const vel = Array.isArray(velocity) ? velocity : [velocity.x, velocity.y, velocity.z];
          if (pos.some(v => isNaN(v) || !isFinite(v)) || vel.some(v => isNaN(v) || !isFinite(v))) {
            addConsoleMessage(`Invalid particle data: pos=[${pos}], vel=[${vel}]`);
            return;
          }
          for (let i = 0; i < maxParticles; i++) {
            if (!instanceData[i].active) {
              instanceData[i] = {
                active: true,
                type,
                created: Date.now(),
                pos: pos.slice(),
                vel: vel.slice(),
                mass
              };
              entityCount++;
              console.log(`Spawned particle ${i}: pos=[${pos.map(v => v.toFixed(2)).join(', ')}], type=${type}`);
              return;
            }
          }
          addConsoleMessage('Max particle limit reached!');
        }

        function reset() {
          instanceData.forEach(d => d.active = false);
          entityCount = 0;
          autopilotActive = false;
          currentNodeIndex = 0;
          throttle = 0;
          camera.position.set(0, 0, 100);
          camera.lookAt(0, 0, 0);
          document.getElementById('autopilotBtn').classList.remove('active');
          document.getElementById('throttleBtn').classList.remove('active');
          throttleIndicator.textContent = '';
          throttleIndicator.classList.remove('active');
          showPrompt(6);
          addConsoleMessage('Galaxy reset to blank slate.');
        }

        function toggleThrottle() {
          if (autopilotActive) {
            addConsoleMessage('Cannot toggle throttle during autopilot.');
            return;
          }
          throttle = throttle === 0 ? 150 : 0;
          document.getElementById('throttleBtn').classList.toggle('active', throttle > 0);
          throttleIndicator.textContent = throttle > 0 ? `Thrust: ${throttle}` : '';
          throttleIndicator.classList.toggle('active', throttle > 0);
          showPrompt(0);
          addConsoleMessage(throttle > 0 ? 'Manual throttle engaged!' : 'Throttle disengaged.');
        }

        function toggleAutopilot() {
          const nodes = instanceData.filter(d => d.active && d.type === 3);
          if (nodes.length < 2) {
            showPrompt(7);
            addConsoleMessage('Need at least 2 nodes for autopilot.');
            return;
          }
          autopilotActive = !autopilotActive;
          document.getElementById('autopilotBtn').classList.toggle('active', autopilotActive);
          if (autopilotActive) {
            throttle = 0;
            document.getElementById('throttleBtn').classList.remove('active');
            throttleIndicator.textContent = '';
            throttleIndicator.classList.remove('active');
            currentNodeIndex = 0;
            showPrompt(9);
            addConsoleMessage('Autopilot engaged! Navigating nodes.');
          } else {
            showPrompt(0);
            addConsoleMessage('Autopilot disengaged.');
          }
        }

        // Autopilot
        function updateAutopilot(deltaTime) {
          if (!autopilotActive) return;
          const nodes = instanceData.filter(d => d.active && d.type === 3);
          if (nodes.length === 0) return;

          const targetNode = nodes[currentNodeIndex];
          const direction = targetNode.pos.map((v, i) => v - camera.position.toArray()[i]);
          const distance = Math.sqrt(direction.reduce((sum, v) => sum + v * v, 0));

          if (distance < 50) {
            currentNodeIndex = (currentNodeIndex + 1) % nodes.length;
            addConsoleMessage(`Reached node ${currentNodeIndex + 1}. Heading to next node.`);
          }

          const len = distance || 1;
          direction[0] /= len;
          direction[1] /= len;
          direction[2] /= len;
          const speed = 150;
          velocity = [direction[0] * speed, direction[1] * speed, direction[2] * speed];
          camera.position.add(new THREE.Vector3(...velocity).multiplyScalar(deltaTime));
          camera.lookAt(new THREE.Vector3(...targetNode.pos));
        }

        // Prompt handling
        const prompts = [
          "Manual throttle engaged!",
          "Comet added to your galaxy.",
          "Planetary system created ahead.",
          "Galaxy spawned with stars.",
          "Satellite node deployed.",
          "Projectile fired!",
          "Galaxy reset to blank slate.",
          "Need at least 2 nodes for autopilot!",
          "Warning: Adding more may slow performance!",
          "Autopilot engaged! Navigating nodes."
        ];

        function showPrompt(index) {
          prompt.textContent = prompts[index];
          prompt.classList.add('active');
          setTimeout(() => prompt.classList.remove('active'), 2000);
        }

        // Animation loop
        function animate() {
          requestAnimationFrame(animate);
          const now = performance.now();
          const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
          lastTime = now;
          time += deltaTime;

          // Update camera
          if (!autopilotActive) {
            camera.rotationVelocity = camera.rotationVelocity || { pitch: 0, yaw: 0 };
            if (keys.ArrowLeft) camera.rotationVelocity.yaw += 0.05;
            if (keys.ArrowRight) camera.rotationVelocity.yaw -= 0.05;
            if (keys.ArrowUp) camera.rotationVelocity.pitch -= 0.05;
            if (keys.ArrowDown) camera.rotationVelocity.pitch += 0.05;

            camera.rotation = camera.rotation || { pitch: 0, yaw: 0 };
            camera.rotation.pitch += camera.rotationVelocity.pitch * deltaTime;
            camera.rotation.yaw += camera.rotationVelocity.yaw * deltaTime;
            camera.rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.pitch));
            camera.rotationVelocity.pitch *= 0.95;
            camera.rotationVelocity.yaw *= 0.95;

            camera.quaternion.setFromEuler(new THREE.Euler(camera.rotation.pitch, camera.rotation.yaw, 0, 'YXZ'));
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            velocity = forward.multiplyScalar(throttle).toArray();
            camera.position.add(new THREE.Vector3(...velocity).multiplyScalar(deltaTime));
          } else {
            updateAutopilot(deltaTime);
          }

          // Update particles
          const cometMatrix = new THREE.Matrix4();
          const projectileMatrix = new THREE.Matrix4();
          const nodeMatrix = new THREE.Matrix4();
          let cometCount = 0, projectileCount = 0, nodeCount = 0;
          let toRemove = [];

          instanceData.forEach((data, i) => {
            if (!data.active) return;
            // Validate position before update
            if (data.pos.some(v => isNaN(v) || !isFinite(v))) {
              addConsoleMessage(`Invalid position before update: particle ${i}, pos=[${data.pos}]`);
              data.active = false;
              toRemove.push(i);
              entityCount--;
              return;
            }
            data.pos[0] += data.vel[0] * deltaTime;
            data.pos[1] += data.vel[1] * deltaTime;
            data.pos[2] += data.vel[2] * deltaTime;
            // Validate position after update
            if (data.pos.some(v => isNaN(v) || !isFinite(v) || Math.abs(v) > 1000)) {
              addConsoleMessage(`Invalid position after update: particle ${i}, pos=[${data.pos}]`);
              data.active = false;
              toRemove.push(i);
              entityCount--;
              return;
            }
            const posVec = new THREE.Vector3(...data.pos);
            if (data.type === 1 && cometCount < maxParticles) {
              cometMatrix.setPosition(posVec);
              cometInstanceMesh.setMatrixAt(cometCount++, cometMatrix);
            } else if (data.type === 2 && projectileCount < maxParticles) {
              projectileMatrix.setPosition(posVec);
              projectileInstanceMesh.setMatrixAt(projectileCount++, projectileMatrix);
            } else if (data.type === 3 && nodeCount < maxParticles) {
              nodeMatrix.setPosition(posVec);
              nodeInstanceMesh.setMatrixAt(nodeCount++, nodeMatrix);
            }
            if (data.type === 2) {
              if (posVec.length() > 1000) {
                data.active = false;
                toRemove.push(i);
                entityCount--;
              } else {
                for (let j = 0; j < maxParticles; j++) {
                  if (i === j || !instanceData[j].active || instanceData[j].type === 2) continue;
                  const dist = posVec.distanceTo(new THREE.Vector3(...instanceData[j].pos));
                  if (dist < 20 && (instanceData[j].type === 1 || instanceData[j].type === 3)) {
                    instanceData[j].active = false;
                    data.active = false;
                    toRemove.push(i, j);
                    entityCount -= 2;
                    addConsoleMessage(instanceData[j].type === 1 ? 'Comet destroyed.' : 'Node destroyed.');
                  }
                }
              }
            }
            if (i < 5 && data.active) {
              console.log(`Particle ${i}: pos=[${data.pos.map(v => v.toFixed(2)).join(', ')}], type=${data.type}`);
            }
          });

          cometInstanceMesh.count = cometCount;
          projectileInstanceMesh.count = projectileCount;
          nodeInstanceMesh.count = nodeCount;
          cometInstanceMesh.instanceMatrix.needsUpdate = true;
          projectileInstanceMesh.instanceMatrix.needsUpdate = true;
          nodeInstanceMesh.instanceMatrix.needsUpdate = true;

          // Render
          renderer.render(scene, camera);
          const gl = renderer.getContext();
          const error = gl.getError();
          if (error !== gl.NO_ERROR) {
            console.error(`WebGL Error: ${error}`);
          }
          updateStatusOverlay(cometCount, projectileCount, nodeCount);
          debugOverlay.textContent = `Spawned: ${entityCount} | Rendered: Comets=${cometCount}, Projectiles=${projectileCount}, Nodes=${nodeCount}\nCamera: [${camera.position.toArray().map(v => v.toFixed(2)).join(', ')}]`;
        }

        // Button bindings
        document.getElementById('throttleBtn').addEventListener('click', toggleThrottle);
        document.getElementById('addComet').addEventListener('click', addComet);
        document.getElementById('addSystem').addEventListener('click', addSystem);
        document.getElementById('addGalaxy').addEventListener('click', addGalaxy);
        document.getElementById('addNode').addEventListener('click', addNode);
        document.getElementById('autopilotBtn').addEventListener('click', toggleAutopilot);
        document.getElementById('shootBtn').addEventListener('click', shoot);
        document.getElementById('resetBtn').addEventListener('click', reset);
        document.getElementById('matrixBtn').addEventListener('click', () => {
          addConsoleMessage('Matrix operation disabled for debugging.');
        });

        // Resize handler
        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // WebGL error handling
        const gl = renderer.getContext();
        if (!gl) {
          const errorDiv = document.createElement('div');
          errorDiv.className = 'error-message';
          errorDiv.textContent = 'WebGL not supported or disabled. Please enable WebGL or try another browser.';
          document.body.appendChild(errorDiv);
          return;
        }

        // Initialize
        addConsoleMessage('Galaxycraft initialized with WebGL. Type /help for commands.');
        animate();
      } catch (e) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.textContent = `Initialization failed: ${e.message}`;
        document.body.appendChild(errorDiv);
        console.error(e);
      }
    };
  </script>
</body>
</html>
