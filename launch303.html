<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Launch Sequence</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Orbitron', -apple-system, BlinkMacSystemFont, sans-serif;
    }
    body {
      background: #000;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #cosmicCanvas {
      flex: 1;
      width: 100%;
      touch-action: none;
      position: relative;
    }
    .controls {
      position: fixed;
      bottom: 0;
      width: 100%;
      background: rgba(20, 20, 50, 0.9);
      padding: 0.5vw;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5vw;
      justify-content: center;
      backdrop-filter: blur(5px);
      z-index: 10;
    }
    .control-item {
      flex: 1;
      min-width: 80px;
      text-align: center;
    }
    button {
      background: #4a90e2;
      border: none;
      padding: 0.5vw 1vw;
      color: white;
      border-radius: 1vw;
      cursor: pointer;
      font-size: 1vw;
      transition: transform 0.2s, background 0.2s, opacity 0.2s;
    }
    button:hover {
      background: #357abd;
    }
    button.active {
      background: #ff4444;
    }
    button:active {
      transform: scale(0.95);
    }
    .prompt {
      position: absolute;
      top: 1vw;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 0.75vw;
      border-radius: 0.5vw;
      font-size: 0.9vw;
      max-width: 90%;
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
      z-index: 5;
      border: 1px solid #00ff00;
      box-shadow: 0 0 0.5vw #00ff00;
    }
    .prompt.active {
      opacity: 1;
    }
    .agent-popup {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      padding: 1vw;
      border-radius: 0.5vw;
      z-index: 20;
      display: none;
      color: #fff;
      width: 15vw;
      max-width: 90%;
      transition: opacity 0.3s ease-in-out;
    }
    .agent-popup.active {
      display: block;
      opacity: 1;
    }
    .agent-popup h3 {
      margin-bottom: 0.5vw;
      font-size: 1.2vw;
    }
    .agent-popup label {
      display: block;
      margin: 0.5vw 0 0.25vw;
      font-size: 0.8vw;
    }
    .agent-popup input, .agent-popup select {
      width: 100%;
      background: #333;
      color: #fff;
      border: 1px solid #00ff00;
      padding: 0.25vw;
      border-radius: 0.25vw;
      font-size: 0.8vw;
    }
    .agent-popup button {
      margin-top: 0.5vw;
      width: 100%;
      font-size: 0.9vw;
    }
    .hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.4;
      z-index: 1;
    }
    .hud::before {
      content: '';
      position: absolute;
      top: 10%;
      left: 10%;
      right: 10%;
      bottom: 10%;
      border: 2px solid rgba(74, 144, 226, 0);
      border-radius: 1vw;
    }
    .hud::after {
      content: '+';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #4a90e2;
      font-size: 1.5vw;
    }
    .throttle-indicator {
      position: absolute;
      bottom: 4vw;
      left: 50%;
      transform: translateX(-50%);
      color: #4a90e2;
      font-size: 0.75vw;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
      z-index: 5;
    }
    .throttle-indicator.active {
      opacity: 1;
    }
    .status-overlay {
      position: absolute;
      top: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.3);
      padding: 0.25vw 0.5vw;
      font-size: 0.75vw;
      text-align: left;
      color: #fff;
      text-shadow: 0 0 2px #000;
      z-index: 5;
      pointer-events: none;
    }
    .console {
      position: absolute;
      bottom: 3vw;
      width: 100%;
      height: 25%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      z-index: 5;
      padding: 0.25vw;
    }
    .console-log {
      flex: 1;
      overflow-y: auto;
      font-size: 0.75vw;
      color: #fff;
      text-shadow: 0 0 2px #000;
      padding: 0.25vw;
    }
    .console-log p {
      margin: 0.1vw 0;
    }
    .console-input {
      width: 100%;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid #4a90e2;
      color: #fff;
      padding: 0.25vw;
      font-size: 0.75vw;
      outline: none;
    }
    .console-input::placeholder {
      color: #aaa;
    }
    .console::-webkit-scrollbar {
      width: 0.4vw;
    }
    .console::-webkit-scrollbar-thumb {
      background: #4a90e2;
      border-radius: 0.2vw;
    }
    .joystick {
      position: absolute;
      bottom: 6vw;
      left: 1vw;
      width: 4vw;
      height: 4vw;
      background: rgba(74, 144, 226, 0.3);
      border-radius: 50%;
      display: none;
      touch-action: none;
      z-index: 10;
    }
    .joystick.active {
      display: block;
    }
    .joystick-knob {
      width: 2vw;
      height: 2vw;
      background: #4a90e2;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .rotation-zone {
      position: absolute;
      bottom: 6vw;
      right: 1vw;
      width: 4vw;
      height: 4vw;
      background: rgba(74, 144, 226, 0.3);
      border-radius: 50%;
      display: none;
      touch-action: none;
      z-index: 10;
    }
    .rotation-zone.active {
      display: block;
    }
    .rotation-knob {
      width: 2vw;
      height: 2vw;
      background: #4a90e2;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .fpc-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      color: #00ff00;
      font-size: 0.75vw;
      padding: 0.5vw;
      display: none;
      z-index: 5;
      pointer-events: none;
      transition: opacity 0.3s ease-in-out;
    }
    .fpc-overlay.active {
      display: block;
      opacity: 1;
    }
    .agent-coordinates {
      position: absolute;
      bottom: 5vw;
      left: 0.5vw;
      background: rgba(0, 0, 0, 0.7);
      padding: 0.5vw;
      border-radius: 0.25vw;
      font-size: 0.75vw;
      z-index: 5;
      max-width: 15vw;
    }
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1vw;
      color: #00ff00;
      z-index: 20;
      display: none;
    }
    .loading.active {
      display: block;
    }
    @media (max-width: 768px) {
      button {
        padding: 2vw 4vw;
        font-size: 3vw;
      }
      .prompt, .agent-popup {
        font-size: 2.5vw;
        padding: 2vw;
      }
      .agent-popup input, .agent-popup select {
        font-size: 2vw;
        padding: 1vw;
      }
      .agent-popup h3 {
        font-size: 3vw;
      }
      .agent-popup label {
        font-size: 2vw;
      }
      .console {
        height: 30%;
      }
      .console-log, .console-input, .status-overlay, .fpc-overlay, .agent-coordinates {
        font-size: 2vw;
      }
      .joystick, .rotation-zone {
        width: 10vw;
        height: 10vw;
      }
      .joystick-knob, .rotation-knob {
        width: 5vw;
        height: 5vw;
      }
    }
    @media (min-width: 769px) {
      button {
        padding: 0.5vw 1vw;
        font-size: 1vw;
      }
      .prompt, .agent-popup {
        font-size: 0.9vw;
      }
      .agent-popup input, .agent-popup select {
        font-size: 0.8vw;
      }
      .agent-popup h3 {
        font-size: 1.2vw;
      }
      .agent-popup label {
        font-size: 0.8vw;
      }
    }
  </style>
</head>
<body>
  <div id="cosmicCanvas">
    <div class="hud"></div>
    <div id="statusOverlay" class="status-overlay"></div>
    <div id="throttleIndicator" class="throttle-indicator"></div>
    <div id="console" class="console">
      <div id="consoleLog" class="console-log"></div>
      <input id="consoleInput" class="console-input" type="text" placeholder="Type /help for commands..." autocomplete="off">
    </div>
    <div id="joystick" class="joystick">
      <div class="joystick-knob"></div>
    </div>
    <div id="rotationZone" class="rotation-zone">
      <div class="rotation-knob"></div>
    </div>
    <div id="fpcOverlay" class="fpc-overlay"></div>
    <div id="agentCoordinates" class="agent-coordinates"></div>
    <div id="loading" class="loading">Initializing...</div>
  </div>
  <div class="controls">
    <div class="control-item">
      <button id="throttleBtn">Full Throttle</button>
    </div>
    <div class="control-item">
      <button id="addAgentBtn">Add Agent</button>
    </div>
    <div class="control-item">
      <button id="showAllBtn">Show All</button>
    </div>
    <div class="control-item">
      <button id="autopilotBtn">Autopilot</button>
    </div>
    <div class="control-item">
      <button id="shootBtn">Toggle FPC</button>
    </div>
    <div class="control-item">
      <button id="resetBtn">Reset</button>
    </div>
  </div>
  <div id="prompt" class="prompt"></div>
  <div id="agentPopup" class="agent-popup">
    <h3>Add New Agent</h3>
    <label for="agentType">Agent Type</label>
    <select id="agentType">
      <option value="drone">Drone</option>
      <option value="rocket">Rocket</option>
      <option value="satellite">Satellite</option>
    </select>
    <label for="agentId">Agent ID</label>
    <input id="agentId" type="text" placeholder="e.g., drone_1">
    <label for="apiKey">API Key</label>
    <input id="apiKey" type="text" placeholder="API Key for live data">
    <label for="iotEndpoint">IoT Endpoint</label>
    <input id="iotEndpoint" type="text" placeholder="IoT Endpoint URL">
    <label for="maxSpeed">Max Speed (m/s)</label>
    <input id="maxSpeed" type="number" placeholder="e.g., 100" value="100">
    <label for="altitude">Altitude (m)</label>
    <input id="altitude" type="number" placeholder="e.g., 100" value="100">
    <button id="saveAgentBtn">Save Agent</button>
    <button id="cancelAgentBtn">Cancel</button>
  </div>
  <div id="agentControlPopup" class="agent-popup">
    <h3 id="agentControlTitle">Agent Controls</h3>
    <label for="controlMaxSpeed">Max Speed (m/s)</label>
    <input id="controlMaxSpeed" type="number" placeholder="e.g., 100">
    <label for="controlAltitude">Altitude (m)</label>
    <input id="controlAltitude" type="number" placeholder="e.g., 100">
    <label for="controlMode">Mode</label>
    <select id="controlMode">
      <option value="manual">Manual</option>
      <option value="autonomous">Autonomous</option>
    </select>
    <button id="firstPersonBtn">First Person Mode</button>
    <button id="saveControlBtn">Save Settings</button>
    <button id="closeControlBtn">Close</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    window.onload = () => {
      try {
        // Show loading indicator
        const loading = document.getElementById('loading');
        loading.classList.add('active');

        // Scene setup
        if (!window.THREE) throw new Error('Three.js not loaded');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        const canvas = document.getElementById('cosmicCanvas');
        if (!canvas) throw new Error('Canvas element not found');
        canvas.appendChild(renderer.domElement);

        // Globe setup
        const globeGeometry = new THREE.SphereGeometry(200, 16, 16);
        const globeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
        const globe = new THREE.Mesh(globeGeometry, globeMaterial);
        scene.add(globe);

        // Camera setup
        camera.position.set(0, 0, 400);
        const frustum = new THREE.Frustum();
        const cameraMatrix = new THREE.Matrix4();
        let targetZoom = 400;
        let currentZoom = 400;

        // Shared resources
        const sharedMaterials = {
          glow: new THREE.MeshBasicMaterial({ color: 0xffffff }),
          drone: new THREE.MeshBasicMaterial({ color: 0xffff99 }),
          rocket: new THREE.MeshBasicMaterial({ color: 0x3399ff }),
          satellite: new THREE.MeshBasicMaterial({ color: 0xff33cc }),
          node: new THREE.MeshBasicMaterial({ color: 0x00ff00 }),
          line: new THREE.LineBasicMaterial({ color: 0x00ff00 })
        };
        const sharedGeometries = {
          drone: new THREE.SphereGeometry(2, 8, 8),
          rocket: new THREE.SphereGeometry(2, 8, 8),
          satellite: new THREE.SphereGeometry(2, 8, 8),
          node: new THREE.BoxGeometry(5, 5, 5)
        };

        // Entities
        let agents = [];
        let nodes = [];
        let nodeLines = [];
        let agentInstances = null;
        let agentCount = 0;
        let throttle = 0;
        let rotation = { pitch: 0, yaw: 0 };
        let rotationVelocity = { pitch: 0, yaw: 0 };
        let velocity = new THREE.Vector3(0, 0, 0);
        let lastTime = performance.now();
        let entityCount = 0;
        let autopilotActive = false;
        let fpcMode = false;
        let selectedAgent = null;
        let mode = 'simulation';
        let lastFrameTime = performance.now();
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);
        const targetFrameTime = isMobile ? 1000 / 30 : 1000 / 60; // 30 FPS mobile, 60 FPS desktop

        // Joystick and rotation controls
        let joystickActive = false;
        let rotationActive = false;
        let joystickOrigin = { x: 0, y: 0 };
        let rotationOrigin = { x: 0, y: 0 };
        let joystickDelta = { x: 0, y: 0 };
        let rotationDelta = { x: 0, y: 0 };
        const keyboardState = { up: false, down: false, left: false, right: false, yawLeft: false, yawRight: false, pitchUp: false, pitchDown: false };
        let fpcYaw = 0;
        let fpcPitch = 0;

        // UI elements
        const statusOverlay = document.getElementById('statusOverlay');
        const consoleLog = document.getElementById('consoleLog');
        const consoleInput = document.getElementById('consoleInput');
        const prompt = document.getElementById('prompt');
        const agentPopup = document.getElementById('agentPopup');
        const agentControlPopup = document.getElementById('agentControlPopup');
        const agentCoordinates = document.getElementById('agentCoordinates');
        const joystick = document.getElementById('joystick');
        const joystickKnob = document.querySelector('.joystick-knob');
        const rotationZone = document.getElementById('rotationZone');
        const rotationKnob = document.querySelector('.rotation-knob');
        const fpcOverlay = document.getElementById('fpcOverlay');
        const maxLogMessages = 50;
        let logMessages = [];

        function addConsoleMessage(message) {
          const timestamp = new Date().toLocaleTimeString();
          logMessages.push(`[${timestamp}] ${message}`);
          if (logMessages.length > maxLogMessages) {
            logMessages.shift();
          }
          consoleLog.innerHTML = logMessages.map(msg => `<p>${msg}</p>`).join('');
          consoleLog.scrollTop = consoleLog.scrollHeight;
        }

        function updateStatusOverlay() {
          statusOverlay.textContent = `Agents: ${entityCount} | Throttle: ${throttle} | Autopilot: ${autopilotActive ? 'On' : 'Off'} | Mode: ${fpcMode ? 'FPC' : 'Global'} | FPS: ${Math.round(1000 / (performance.now() - lastTime))} | System: ${mode}`;
        }

        function updateAgentCoordinates() {
          agentCoordinates.innerHTML = agents.map(agent => {
            const { lat, lon, alt } = cartesianToLatLonAlt(agent.position);
            return `Agent ${agent.userData.id}: Lat ${lat.toFixed(2)}°, Lon ${lon.toFixed(2)}°, Alt ${alt.toFixed(0)}m`;
          }).join('<br>');
        }

        function cartesianToLatLonAlt(position) {
          const radius = position.length();
          if (isNaN(radius) || radius < 1) return { lat: 0, lon: 0, alt: 0 };
          const alt = (radius - 200) * 100;
          const phi = Math.acos(position.y / radius);
          const theta = Math.atan2(position.z, position.x);
          const lat = 90 - (phi * 180 / Math.PI);
          const lon = (theta * 180 / Math.PI);
          return { lat, lon, alt };
        }

        // Mock WebSocket for live data
        class MockWebSocket {
          constructor() {
            this.onmessage = null;
            setInterval(() => {
              if (this.onmessage) {
                this.onmessage({
                  data: JSON.stringify({
                    type: 'agent_update',
                    agents: agents.map(agent => ({
                      id: agent.userData.id,
                      position: agent.position,
                      velocity: agent.userData.velocity,
                      role: agent.userData.role,
                      lat: cartesianToLatLonAlt(agent.position).lat,
                      lon: cartesianToLatLonAlt(agent.position).lon,
                      alt: cartesianToLatLonAlt(agent.position).alt
                    }))
                  })
                });
              }
            }, 1000); // 1Hz
          }
          send(data) {
            addConsoleMessage(`WebSocket sent: ${data}`);
          }
        }
        let ws = new MockWebSocket();

        // Object pools
        const agentPool = [];
        const nodePool = [];
        function getAgentFromPool(role) {
          const pool = agentPool.filter(a => a.userData.role === role);
          if (pool.length > 0) {
            const agent = pool.pop();
            agent.visible = true;
            return agent;
          }
          const mesh = new THREE.Mesh(sharedGeometries[role], sharedMaterials[role]);
          mesh.userData = {};
          return mesh;
        }
        function getNodeFromPool() {
          if (nodePool.length > 0) {
            const node = nodePool.pop();
            node.visible = true;
            return node;
          }
          const mesh = new THREE.Mesh(sharedGeometries.node, sharedMaterials.node);
          mesh.userData = {};
          return mesh;
        }

        // Add agents
        function addAgent(role, id, apiKey, iotEndpoint, maxSpeed, altitude) {
          if (agents.length >= 4) {
            showPrompt(8);
            addConsoleMessage('Maximum of 4 agents reached.');
            return;
          }
          const agent = getAgentFromPool(role);
          const phi = (90 - 0) * Math.PI / 180;
          const theta = 0 * Math.PI / 180;
          const radius = 200 + (parseFloat(altitude) || 100) / 100;
          agent.position.set(
            radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.cos(phi),
            radius * Math.sin(phi) * Math.sin(theta)
          );
          agent.userData = {
            type: 'agent',
            role,
            id,
            velocity: new THREE.Vector3(0, 0, 0.1),
            created: Date.now(),
            instanceId: agentCount,
            apiKey: apiKey || '',
            iotEndpoint: iotEndpoint || '',
            maxSpeed: parseFloat(maxSpeed) || 100,
            altitude: parseFloat(altitude) || 100,
            mode: 'manual'
          };
          scene.add(agent);
          agents.push(agent);
          agentCount++;
          entityCount++;
          updateAgentInstances();
          showPrompt(1);
          addConsoleMessage(`${role.charAt(0).toUpperCase() + role.slice(1)} ${id} added.`);
          updateStatusOverlay();
          updateAgentCoordinates();
          createAgentControlButton(id);
        }

        function createAgentControlButton(id) {
          const controlItem = document.createElement('div');
          controlItem.className = 'control-item';
          const button = document.createElement('button');
          button.textContent = `Control ${id}`;
          button.dataset.agentId = id;
          button.addEventListener('click', () => openAgentControlPopup(id));
          controlItem.appendChild(button);
          document.querySelector('.controls').appendChild(controlItem);
        }

        function updateAgentInstances() {
          if (agentInstances) {
            scene.remove(agentInstances);
            agentInstances.geometry.dispose();
            agentInstances.material.dispose();
            agentInstances = null;
          }
          if (agentCount === 0) return;
          agentInstances = new THREE.InstancedMesh(sharedGeometries.drone, sharedMaterials.glow, agentCount);
          const matrix = new THREE.Matrix4();
          agents.forEach((agent, i) => {
            matrix.setPosition(agent.position);
            agentInstances.setMatrixAt(i, matrix);
          });
          scene.add(agentInstances);
        }

        function addNode() {
          const node = getNodeFromPool();
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * 100
          );
          node.position.copy(camera.position).add(forward.multiplyScalar(300)).add(offset);
          node.userData = { type: 'node', created: Date.now() };
          scene.add(node);
          nodes.push(node);
          entityCount++;

          if (nodes.length > 1) {
            const prevNode = nodes[nodes.length - 2];
            const geometry = new THREE.BufferGeometry().setFromPoints([
              prevNode.position,
              node.position
            ]);
            const line = new THREE.Line(geometry, sharedMaterials.line);
            scene.add(line);
            nodeLines.push(line);
          }

          showPrompt(4);
          addConsoleMessage('Node deployed.');
          updateStatusOverlay();
        }

        function reset() {
          agents.forEach(agent => {
            agent.visible = false;
            agentPool.push(agent);
            scene.remove(agent);
          });
          agents = [];
          nodes.forEach(node => {
            node.visible = false;
            nodePool.push(node);
            scene.remove(node);
          });
          nodes = [];
          nodeLines.forEach(line => {
            scene.remove(line);
            line.geometry.dispose();
          });
          nodeLines = [];
          if (agentInstances) {
            scene.remove(agentInstances);
            agentInstances.geometry.dispose();
            agentInstances.material.dispose();
            agentInstances = null;
          }
          agentCount = 0;
          entityCount = 0;
          autopilotActive = false;
          fpcMode = false;
          selectedAgent = null;
          throttle = 0;
          joystickDelta = { x: 0, y: 0 };
          rotationDelta = { x: 0, y: 0 };
          fpcYaw = 0;
          fpcPitch = 0;
          keyboardState.up = false;
          keyboardState.down = false;
          keyboardState.left = false;
          keyboardState.right = false;
          keyboardState.yawLeft = false;
          keyboardState.yawRight = false;
          keyboardState.pitchUp = false;
          keyboardState.pitchDown = false;
          const autopilotBtn = document.getElementById('autopilotBtn');
          if (autopilotBtn) autopilotBtn.classList.remove('active');
          const throttleBtn = document.getElementById('throttleBtn');
          if (throttleBtn) throttleBtn.classList.remove('active');
          const shootBtn = document.getElementById('shootBtn');
          if (shootBtn) shootBtn.classList.remove('active');
          const throttleIndicator = document.getElementById('throttleIndicator');
          if (throttleIndicator) {
            throttleIndicator.textContent = '';
            throttleIndicator.classList.remove('active');
          }
          joystick.classList.remove('active');
          rotationZone.classList.remove('active');
          joystickKnob.style.transform = 'translate(-50%, -50%)';
          rotationKnob.style.transform = 'translate(-50%, -50%)';
          fpcOverlay.classList.remove('active');
          agentCoordinates.innerHTML = '';
          const controls = document.querySelector('.controls');
          while (controls.children.length > 6) {
            controls.removeChild(controls.lastChild);
          }
          showPrompt(6);
          addConsoleMessage('System reset.');
          updateStatusOverlay();
        }

        function toggleThrottle() {
          if (autopilotActive || fpcMode) return;
          throttle = throttle === 0 ? 150 : 0;
          const throttleBtn = document.getElementById('throttleBtn');
          if (throttleBtn) throttleBtn.classList.toggle('active', throttle > 0);
          const throttleIndicator = document.getElementById('throttleIndicator');
          if (throttleIndicator) {
            throttleIndicator.textContent = throttle > 0 ? `Thrust: ${throttle}` : '';
            throttleIndicator.classList.toggle('active', throttle > 0);
          }
          showPrompt(0);
          addConsoleMessage(throttle > 0 ? 'Throttle engaged!' : 'Throttle disengaged.');
          updateStatusOverlay();
        }

        function toggleAutopilot() {
          if (nodes.length < 2) {
            showPrompt(7);
            addConsoleMessage('Need at least 2 nodes for autopilot.');
            return;
          }
          autopilotActive = !autopilotActive;
          fpcMode = false;
          selectedAgent = null;
          const autopilotBtn = document.getElementById('autopilotBtn');
          if (autopilotBtn) autopilotBtn.classList.toggle('active', autopilotActive);
          const shootBtn = document.getElementById('shootBtn');
          if (shootBtn) shootBtn.classList.remove('active');
          if (autopilotActive) {
            throttle = 0;
            const throttleBtn = document.getElementById('throttleBtn');
            if (throttleBtn) throttleBtn.classList.remove('active');
            const throttleIndicator = document.getElementById('throttleIndicator');
            if (throttleIndicator) {
              throttleIndicator.textContent = '';
              throttleIndicator.classList.remove('active');
            }
            joystick.classList.remove('active');
            rotationZone.classList.remove('active');
            joystickKnob.style.transform = 'translate(-50%, -50%)';
            rotationKnob.style.transform = 'translate(-50%, -50%)';
            fpcOverlay.classList.remove('active');
            currentNodeIndex = 0;
            showPrompt(9);
            addConsoleMessage('Autopilot engaged! Navigating nodes.');
          } else {
            showPrompt(0);
            addConsoleMessage('Autopilot disengaged.');
          }
          updateStatusOverlay();
        }

        function toggleFPC() {
          if (autopilotActive) return;
          fpcMode = !fpcMode;
          const shootBtn = document.getElementById('shootBtn');
          if (shootBtn) shootBtn.classList.toggle('active', fpcMode);
          if (fpcMode) {
            if (!selectedAgent) {
              fpcMode = false;
              shootBtn.classList.remove('active');
              showPrompt(7);
              addConsoleMessage('Select an agent to enter FPC mode.');
              return;
            }
            throttle = 0;
            const throttleBtn = document.getElementById('throttleBtn');
            if (throttleBtn) throttleBtn.classList.remove('active');
            const throttleIndicator = document.getElementById('throttleIndicator');
            if (throttleIndicator) {
              throttleIndicator.textContent = '';
              throttleIndicator.classList.remove('active');
            }
            joystick.classList.add('active');
            if (isMobile) rotationZone.classList.add('active');
            camera.position.copy(selectedAgent.position);
            fpcYaw = 0;
            fpcPitch = 0;
            fpcOverlay.classList.add('active');
            addConsoleMessage('FPC mode enabled.');
          } else {
            joystick.classList.remove('active');
            rotationZone.classList.remove('active');
            joystickKnob.style.transform = 'translate(-50%, -50%)';
            rotationKnob.style.transform = 'translate(-50%, -50%)';
            fpcOverlay.classList.remove('active');
            camera.position.set(0, 0, 400);
            joystickDelta = { x: 0, y: 0 };
            rotationDelta = { x: 0, y: 0 };
            fpcYaw = 0;
            fpcPitch = 0;
            keyboardState.up = false;
            keyboardState.down = false;
            keyboardState.left = false;
            keyboardState.right = false;
            keyboardState.yawLeft = false;
            keyboardState.yawRight = false;
            keyboardState.pitchUp = false;
            keyboardState.pitchDown = false;
            addConsoleMessage('FPC mode disabled.');
          }
          updateStatusOverlay();
        }

        function openAgentPopup() {
          agentPopup.classList.add('active');
        }

        function closeAgentPopup() {
          agentPopup.classList.remove('active');
          document.getElementById('agentType').value = 'drone';
          document.getElementById('agentId').value = '';
          document.getElementById('apiKey').value = '';
          document.getElementById('iotEndpoint').value = '';
          document.getElementById('maxSpeed').value = '100';
          document.getElementById('altitude').value = '100';
        }

        function openAgentControlPopup(id) {
          const agent = agents.find(a => a.userData.id === id);
          if (!agent) return;
          selectedAgent = agent;
          document.getElementById('agentControlTitle').textContent = `Control ${id}`;
          document.getElementById('controlMaxSpeed').value = agent.userData.maxSpeed;
          document.getElementById('controlAltitude').value = agent.userData.altitude;
          document.getElementById('controlMode').value = agent.userData.mode;
          agentControlPopup.classList.add('active');
        }

        function closeAgentControlPopup() {
          agentControlPopup.classList.remove('active');
        }

        function showAllAgents() {
          selectedAgent = null;
          targetZoom = 400;
          camera.position.set(0, 0, 400);
          fpcMode = false;
          joystick.classList.remove('active');
          rotationZone.classList.remove('active');
          joystickKnob.style.transform = 'translate(-50%, -50%)';
          rotationKnob.style.transform = 'translate(-50%, -50%)';
          fpcOverlay.classList.remove('active');
          const shootBtn = document.getElementById('shootBtn');
          if (shootBtn) shootBtn.classList.remove('active');
          joystickDelta = { x: 0, y: 0 };
          rotationDelta = { x: 0, y: 0 };
          fpcYaw = 0;
          fpcPitch = 0;
          keyboardState.up = false;
          keyboardState.down = false;
          keyboardState.left = false;
          keyboardState.right = false;
          keyboardState.yawLeft = false;
          keyboardState.yawRight = false;
          keyboardState.pitchUp = false;
          keyboardState.pitchDown = false;
          addConsoleMessage('Zoomed out to show all agents.');
          updateStatusOverlay();
        }

        // Viewing controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let pinchDistance = 0;

        function updateRotation(deltaX, deltaY) {
          if (autopilotActive || fpcMode) return;
          rotationVelocity.yaw -= deltaX * 0.01;
          rotationVelocity.pitch -= deltaY * 0.01;
        }

        renderer.domElement.addEventListener('mousedown', e => {
          if (autopilotActive || fpcMode) return;
          isDragging = true;
          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', e => {
          if (isDragging && !autopilotActive && !fpcMode) {
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            updateRotation(deltaX, deltaY);
            previousMousePosition = { x: e.clientX, y: e.clientY };
          }
        });

        renderer.domElement.addEventListener('mouseup', () => {
          isDragging = false;
        });

        renderer.domElement.addEventListener('touchstart', e => {
          if (autopilotActive || fpcMode) return;
          e.preventDefault();
          if (e.touches.length === 1) {
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            pinchDistance = Math.sqrt(dx * dx + dy * dy);
          }
        });

        renderer.domElement.addEventListener('touchmove', e => {
          if (autopilotActive || fpcMode) return;
          e.preventDefault();
          if (e.touches.length === 1) {
            const deltaX = e.touches[0].clientX - previousMousePosition.x;
            const deltaY = e.touches[0].clientY - previousMousePosition.y;
            updateRotation(deltaX, deltaY);
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const newPinchDistance = Math.sqrt(dx * dx + dy * dy);
            targetZoom *= pinchDistance / newPinchDistance;
            targetZoom = Math.max(100, Math.min(1000, targetZoom));
            pinchDistance = newPinchDistance;
          }
        });

        renderer.domElement.addEventListener('dblclick', () => {
          if (selectedAgent) {
            targetZoom = 100;
          } else {
            targetZoom = 400;
          }
        });

        // Joystick controls
        const maxJoystickDist = isMobile ? Math.min(window.innerWidth, window.innerHeight) * 0.1 : 40;
        joystick.addEventListener('touchstart', e => {
          e.preventDefault();
          joystickActive = true;
          joystickOrigin = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        joystick.addEventListener('touchmove', e => {
          if (!joystickActive) return;
          e.preventDefault();
          const x = e.touches[0].clientX - joystickOrigin.x;
          const y = e.touches[0].clientY - joystickOrigin.y;
          const dist = Math.sqrt(x * x + y * y);
          if (dist > maxJoystickDist) {
            const scale = maxJoystickDist / dist;
            joystickDelta.x = x * scale;
            joystickDelta.y = y * scale;
          } else {
            joystickDelta.x = x;
            joystickDelta.y = y;
          }
          joystickKnob.style.transform = `translate(${joystickDelta.x}px, ${-joystickDelta.y}px)`;
          if (selectedAgent && selectedAgent.userData.mode === 'manual') {
            selectedAgent.userData.velocity.x = THREE.MathUtils.lerp(selectedAgent.userData.velocity.x, joystickDelta.x * 0.1, 0.1);
            selectedAgent.userData.velocity.z = THREE.MathUtils.lerp(selectedAgent.userData.velocity.z, -joystickDelta.y * 0.1, 0.1);
          }
        });

        joystick.addEventListener('touchend', () => {
          joystickActive = false;
          joystickDelta = { x: 0, y: 0 };
          joystickKnob.style.transform = 'translate(-50%, -50%)';
          if (selectedAgent) {
            selectedAgent.userData.velocity.x = 0;
            selectedAgent.userData.velocity.z = 0;
          }
        });

        // Rotation zone controls (mobile)
        rotationZone.addEventListener('touchstart', e => {
          e.preventDefault();
          rotationActive = true;
          rotationOrigin = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        rotationZone.addEventListener('touchmove', e => {
          if (!rotationActive) return;
          e.preventDefault();
          const x = e.touches[0].clientX - rotationOrigin.x;
          const y = e.touches[0].clientY - rotationOrigin.y;
          const dist = Math.sqrt(x * x + y * y);
          if (dist > maxJoystickDist) {
            const scale = maxJoystickDist / dist;
            rotationDelta.x = x * scale;
            rotationDelta.y = y * scale;
          } else {
            rotationDelta.x = x;
            rotationDelta.y = y;
          }
          rotationKnob.style.transform = `translate(${rotationDelta.x}px, ${-rotationDelta.y}px)`;
        });

        rotationZone.addEventListener('touchend', () => {
          rotationActive = false;
          rotationDelta = { x: 0, y: 0 };
          rotationKnob.style.transform = 'translate(-50%, -50%)';
        });

        // Keyboard controls for FPC
        document.addEventListener('keydown', e => {
          if (!fpcMode || !selectedAgent || selectedAgent.userData.mode !== 'manual') return;
          switch (e.key) {
            case 'ArrowUp':
            case 'w':
              keyboardState.up = true;
              break;
            case 'ArrowDown':
            case 's':
              keyboardState.down = true;
              break;
            case 'ArrowLeft':
            case 'a':
              keyboardState.left = true;
              break;
            case 'ArrowRight':
            case 'd':
              keyboardState.right = true;
              break;
            case 'q':
              keyboardState.yawLeft = true;
              break;
            case 'e':
              keyboardState.yawRight = true;
              break;
            case 'r':
              keyboardState.pitchUp = true;
              break;
            case 'f':
              keyboardState.pitchDown = true;
              break;
          }
        });

        document.addEventListener('keyup', e => {
          if (!fpcMode || !selectedAgent || selectedAgent.userData.mode !== 'manual') return;
          switch (e.key) {
            case 'ArrowUp':
            case 'w':
              keyboardState.up = false;
              break;
            case 'ArrowDown':
            case 's':
              keyboardState.down = false;
              break;
            case 'ArrowLeft':
            case 'a':
              keyboardState.left = false;
              break;
            case 'ArrowRight':
            case 'd':
              keyboardState.right = false;
              break;
            case 'q':
              keyboardState.yawLeft = false;
              break;
            case 'e':
              keyboardState.yawRight = false;
              break;
            case 'r':
              keyboardState.pitchUp = false;
              break;
            case 'f':
              keyboardState.pitchDown = false;
              break;
          }
        });

        // Console commands
        function handleCommand(input) {
          const cmd = input.trim().toLowerCase();
          if (!cmd.startsWith('/')) {
            addConsoleMessage('Commands must start with "/". Type /help for commands.');
            return;
          }
          const parts = cmd.slice(1).split(' ');
          const command = parts[0];
          const args = parts.slice(1);

          switch (command) {
            case 'help':
              addConsoleMessage('Commands: /add, /control <id>, /fpc, /reset, /throttle, /autopilot, /mode <simulation|live>, /showall');
              break;
            case 'add':
              openAgentPopup();
              break;
            case 'control':
              if (args[0]) {
                openAgentControlPopup(args[0]);
              } else {
                addConsoleMessage('Specify agent ID: /control <id>');
              }
              break;
            case 'fpc':
              toggleFPC();
              break;
            case 'reset':
              reset();
              break;
            case 'throttle':
              if (autopilotActive || fpcMode) {
                addConsoleMessage('Cannot toggle throttle during autopilot or FPC.');
              } else {
                toggleThrottle();
              }
              break;
            case 'autopilot':
              toggleAutopilot();
              break;
            case 'mode':
              if (args[0] === 'simulation' || args[0] === 'live') {
                mode = args[0];
                ws = new MockWebSocket(); // Replace with real WebSocket for live mode
                addConsoleMessage(`Mode set to ${mode}.`);
                updateStatusOverlay();
              } else {
                addConsoleMessage('Invalid mode. Use: simulation, live');
              }
              break;
            case 'showall':
              showAllAgents();
              break;
            default:
              addConsoleMessage('Unknown command. Type /help for commands.');
          }
        }

        consoleInput.addEventListener('keydown', e => {
          if (e.key === 'Enter') {
            const input = consoleInput.value;
            if (input) {
              addConsoleMessage(`> ${input}`);
              handleCommand(input);
              consoleInput.value = '';
            }
          }
        });

        // Agent popup controls
        document.getElementById('saveAgentBtn').addEventListener('click', () => {
          const role = document.getElementById('agentType').value;
          const id = document.getElementById('agentId').value;
          const apiKey = document.getElementById('apiKey').value;
          const iotEndpoint = document.getElementById('iotEndpoint').value;
          const maxSpeed = document.getElementById('maxSpeed').value;
          const altitude = document.getElementById('altitude').value;
          if (!id || agents.some(a => a.userData.id === id)) {
            addConsoleMessage('Agent ID is required and must be unique.');
            return;
          }
          addAgent(role, id, apiKey, iotEndpoint, maxSpeed, altitude);
          closeAgentPopup();
        });

        document.getElementById('cancelAgentBtn').addEventListener('click', closeAgentPopup);

        // Agent control popup
        document.getElementById('saveControlBtn').addEventListener('click', () => {
          if (selectedAgent) {
            selectedAgent.userData.maxSpeed = parseFloat(document.getElementById('controlMaxSpeed').value) || 100;
            selectedAgent.userData.altitude = parseFloat(document.getElementById('controlAltitude').value) || 100;
            selectedAgent.userData.mode = document.getElementById('controlMode').value;
            addConsoleMessage(`Settings updated for ${selectedAgent.userData.id}.`);
            closeAgentControlPopup();
          }
        });

        document.getElementById('closeControlBtn').addEventListener('click', closeAgentControlPopup);

        document.getElementById('firstPersonBtn').addEventListener('click', () => {
          if (selectedAgent) {
            toggleFPC();
            closeAgentControlPopup();
          }
        });

        // Animation loop
        function animate() {
          requestAnimationFrame(animate);

          const now = performance.now();
          if (now - lastFrameTime < targetFrameTime) return;
          const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
          lastTime = now;
          lastFrameTime = now;

          // Update keyboard/rotation controls for FPC
          if (fpcMode && selectedAgent && selectedAgent.userData.mode === 'manual') {
            joystickDelta.x = (keyboardState.right ? maxJoystickDist : 0) - (keyboardState.left ? maxJoystickDist : 0);
            joystickDelta.y = (keyboardState.up ? maxJoystickDist : 0) - (keyboardState.down ? maxJoystickDist : 0);
            fpcYaw += ((keyboardState.yawRight ? 1 : 0) - (keyboardState.yawLeft ? 1 : 0)) * 0.5 * deltaTime;
            fpcPitch += ((keyboardState.pitchUp ? 1 : 0) - (keyboardState.pitchDown ? 1 : 0)) * 0.5 * deltaTime;
            fpcPitch = THREE.MathUtils.clamp(fpcPitch, -Math.PI / 4, Math.PI / 4);
            if (isMobile) {
              fpcYaw += rotationDelta.x * 0.005;
              fpcPitch += -rotationDelta.y * 0.005;
              fpcPitch = THREE.MathUtils.clamp(fpcPitch, -Math.PI / 4, Math.PI / 4);
            }
            joystickKnob.style.transform = `translate(${joystickDelta.x}px, ${-joystickDelta.y}px)`;
            selectedAgent.userData.velocity.x = THREE.MathUtils.lerp(selectedAgent.userData.velocity.x, joystickDelta.x * 0.1, 0.2);
            selectedAgent.userData.velocity.z = THREE.MathUtils.lerp(selectedAgent.userData.velocity.z, -joystickDelta.y * 0.1, 0.2);
          }

          if (!autopilotActive && !fpcMode) {
            rotation.pitch += rotationVelocity.pitch * deltaTime;
            rotation.yaw += rotationVelocity.yaw * deltaTime;
            rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.pitch));
            rotationVelocity.pitch *= 0.95;
            rotationVelocity.yaw *= 0.95;
            camera.quaternion.setFromEuler(new THREE.Euler(rotation.pitch, rotation.yaw, 0, 'YXZ'));

            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            velocity.copy(forward.multiplyScalar(throttle));
            camera.position.add(velocity.clone().multiplyScalar(deltaTime));
          } else if (autopilotActive) {
            if (nodes.length === 0) return;
            const targetNode = nodes[currentNodeIndex];
            const direction = targetNode.position.clone().sub(camera.position);
            const distance = direction.length();
            if (distance < 50) {
              currentNodeIndex = (currentNodeIndex + 1) % nodes.length;
              addConsoleMessage(`Reached node ${currentNodeIndex + 1}.`);
            }
            direction.normalize();
            const speed = 150;
            velocity.copy(direction.multiplyScalar(speed));
            camera.position.add(velocity.clone().multiplyScalar(deltaTime));
            camera.lookAt(targetNode.position);
          } else if (fpcMode && selectedAgent) {
            camera.position.copy(selectedAgent.position);
            camera.quaternion.setFromEuler(new THREE.Euler(fpcPitch, fpcYaw, 0, 'YXZ'));
            fpcOverlay.textContent = `Agent: ${selectedAgent.userData.id} | Role: ${selectedAgent.userData.role} | Alt: ${Math.round(selectedAgent.position.length() - 200)}m | Yaw: ${fpcYaw.toFixed(2)} | Pitch: ${fpcPitch.toFixed(2)}`;
          }

          // Smooth zoom
          currentZoom = THREE.MathUtils.lerp(currentZoom, targetZoom, 0.1);
          camera.position.setLength(currentZoom);

          // Update agents
          cameraMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          frustum.setFromProjectionMatrix(cameraMatrix);
          const matrix = new THREE.Matrix4();
          agents.forEach((agent, i) => {
            if (!frustum.containsPoint(agent.position)) {
              agent.visible = false;
              return;
            }
            agent.visible = true;
            if (agent.userData.mode === 'autonomous' && mode === 'live') {
              agent.userData.velocity.set(
                (Math.random() - 0.5) * agent.userData.maxSpeed * 0.01,
                0,
                (Math.random() - 0.5) * agent.userData.maxSpeed * 0.01
              );
            }
            const velocity = agent.userData.velocity.clone();
            velocity.multiplyScalar(Math.min(1, agent.userData.maxSpeed / (velocity.length() || 1)));
            agent.position.add(velocity.multiplyScalar(deltaTime));
            const radius = 200 + agent.userData.altitude / 100;
            agent.position.setLength(radius);
            matrix.setPosition(agent.position);
            if (agentInstances) agentInstances.setMatrixAt(i, matrix);
          });
          if (agentInstances) agentInstances.instanceMatrix.needsUpdate = true;

          // Update node lines
          nodeLines.forEach((line, i) => {
            if (i < nodes.length - 1) {
              const geometry = new THREE.BufferGeometry().setFromPoints([
                nodes[i].position,
                nodes[i + 1].position
              ]);
              line.geometry.dispose();
              line.geometry = geometry;
            }
          });

          updateAgentCoordinates();
          renderer.render(scene, camera);
        }

        // Controls
        try {
          const throttleBtn = document.getElementById('throttleBtn');
          const addAgentBtn = document.getElementById('addAgentBtn');
          const showAllBtn = document.getElementById('showAllBtn');
          const autopilotBtn = document.getElementById('autopilotBtn');
          const shootBtn = document.getElementById('shootBtn');
          const resetBtn = document.getElementById('resetBtn');

          if (!throttleBtn || !addAgentBtn || !showAllBtn || !autopilotBtn || !shootBtn || !resetBtn) {
            throw new Error('One or more control elements not found');
          }

          throttleBtn.addEventListener('click', toggleThrottle);
          addAgentBtn.addEventListener('click', openAgentPopup);
          showAllBtn.addEventListener('click', showAllAgents);
          autopilotBtn.addEventListener('click', toggleAutopilot);
          shootBtn.addEventListener('click', toggleFPC);
          resetBtn.addEventListener('click', reset);

          const prompts = [
            "Throttle engaged!",
            "Agent added.",
            "Rocket added.",
            "Satellite added.",
            "Node deployed.",
            "FPC mode toggled.",
            "System reset.",
            "Select an agent for FPC mode!",
            "Warning: Maximum 4 agents reached!",
            "Autopilot engaged!"
          ];

          function showPrompt(index) {
            prompt.textContent = prompts[index];
            prompt.classList.add('active');
            setTimeout(() => prompt.classList.remove('active'), 2000);
          }
        } catch (e) {
          console.error('Control setup error:', e);
          addConsoleMessage(`Error: ${e.message}`);
        }

        // Initialize
        try {
          addConsoleMessage('Launch Sequence initialized. Type /help for commands.');
          updateStatusOverlay();
          setTimeout(() => loading.classList.remove('active'), 500);
          animate();
        } catch (e) {
          console.error('Initialization error:', e);
          addConsoleMessage(`Error: ${e.message}`);
          loading.classList.remove('active');
        }

        // Resize
        window.addEventListener('resize', () => {
          try {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          } catch (e) {
            console.error('Resize error:', e);
            addConsoleMessage(`Error: ${e.message}`);
          }
        });
      } catch (e) {
        console.error('Main script error:', e);
        addConsoleMessage(`Error: ${e.message}`);
        document.getElementById('loading').classList.remove('active');
      }
    };
  </script>
</body>
</html>
