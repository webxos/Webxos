<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebX Universe 3D - Offline</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: monospace, -apple-system, BlinkMacSystemFont, sans-serif;
        }
        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            touch-action: none;
        }
        #gameCanvas {
            flex: 1;
            width: 100%;
            position: relative;
        }
        #glCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .controls {
            position: fixed;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 15px;
            z-index: 10;
        }
        .joystick-container {
            width: 120px;
            height: 120px;
            background: linear-gradient(135deg, #333, #666);
            border: 2px solid #00ffcc;
            border-radius: 50%;
            position: relative;
            touch-action: none;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
        }
        .joystick {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #ff4444, #cc0000);
            border-radius: 50%;
            position: absolute;
            top: 30px;
            left: 30px;
            transform: translate(0, 0);
            box-shadow: 0 0 8px rgba(255, 68, 68, 0.8);
        }
        .action-buttons {
            display: flex;
            gap: 15px;
        }
        button {
            background: linear-gradient(45deg, #1a3c34, #00ffcc);
            border: 2px solid #00ffcc;
            padding: 20px;
            color: #fff;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 70px;
            height: 70px;
            text-align: center;
            box-shadow: 0 0 12px rgba(0, 255, 204, 0.5);
        }
        button:active {
            transform: scale(0.85);
            box-shadow: 0 0 20px rgba(0, 255, 204, 1);
        }
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            color: #00ffcc;
            font-size: 16px;
            z-index: 5;
        }
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #00ffcc;
            text-shadow: 0 0 5px rgba(0, 255, 204, 0.8);
        }
        .status {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border: 1px solid #00ffcc;
            border-radius: 5px;
        }
        .quest-log {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            max-width: 250px;
            border: 1px solid #00ffcc;
            border-radius: 5px;
        }
        .minimap {
            position: absolute;
            bottom: 150px;
            right: 15px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffcc;
            border-radius: 10px;
            overflow: hidden;
        }
        .minimap canvas {
            width: 100%;
            height: 100%;
        }
        .footer {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            font-size: 10px;
            color: #00ffcc;
            z-index: 5;
            text-shadow: 0 0 5px rgba(0, 255, 204, 0.5);
        }
    </style>
</head>
<body>
    <div id="gameCanvas">
        <canvas id="glCanvas"></canvas>
        <div class="hud">
            <div class="crosshair">✛</div>
            <div class="status" id="status">Health: 100 | Cooldown: 0%</div>
            <div class="quest-log" id="questLog">Quest: Explore the Ancient Temple</div>
            <div class="minimap"><canvas id="minimapCanvas"></canvas></div>
        </div>
    </div>
    <div class="controls">
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick" id="joystick"></div>
        </div>
        <div class="action-buttons">
            <button id="shootBtn">A</button>
            <button id="sprintBtn">B</button>
        </div>
    </div>
    <div class="footer">© 2025 WebXOS - WebX Universe 3D</div>

    <script>
        window.onload = () => {
            try {
                console.log("Initializing WebX Universe 3D...");

                // WebGL setup
                const canvas = document.getElementById('glCanvas');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                const gl = canvas.getContext('webgl');
                if (!gl) {
                    throw new Error("WebGL not supported. Use a modern browser like Chrome, Firefox, or Safari.");
                }
                console.log("WebGL context initialized.");

                // Shaders
                const vsSource = `
                    attribute vec3 aPosition;
                    attribute vec3 aColor;
                    uniform mat4 uModelViewMatrix;
                    uniform mat4 uProjectionMatrix;
                    varying vec3 vColor;
                    void main() {
                        gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                        vColor = aColor;
                    }
                `;
                const fsSource = `
                    precision mediump float;
                    varying vec3 vColor;
                    void main() {
                        gl_FragColor = vec4(vColor, 1.0);
                    }
                `;

                // Compile shaders
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, vsSource);
                gl.compileShader(vertexShader);
                if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                    throw new Error("Vertex shader compilation failed: " + gl.getShaderInfoLog(vertexShader));
                }

                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, fsSource);
                gl.compileShader(fragmentShader);
                if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                    throw new Error("Fragment shader compilation failed: " + gl.getShaderInfoLog(fragmentShader));
                }

                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error("Program linking failed: " + gl.getProgramInfoLog(program));
                }
                gl.useProgram(program);
                console.log("Shaders compiled and linked.");

                // Matrices
                const projectionMatrix = new Float32Array(16);
                const modelViewMatrix = new Float32Array(16);
                const fov = 75 * Math.PI / 180;
                const aspect = canvas.width / canvas.height;
                const near = 0.1;
                const far = 1000;
                // Perspective projection
                const f = 1 / Math.tan(fov / 2);
                projectionMatrix.set([
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (far + near) / (near - far), -1,
                    0, 0, (2 * far * near) / (near - far), 0
                ]);

                // Camera
                let cameraPos = [0, 5, 10];
                let cameraPitch = 0;
                let cameraYaw = 0;
                let cameraRotVel = { pitch: 0, yaw: 0 };

                function updateModelViewMatrix() {
                    const cosPitch = Math.cos(cameraPitch);
                    const sinPitch = Math.sin(cameraPitch);
                    const cosYaw = Math.cos(cameraYaw);
                    const sinYaw = Math.sin(cameraYaw);
                    const lookAt = [
                        cosPitch * cosYaw,
                        sinPitch,
                        cosPitch * sinYaw
                    ];
                    const up = [0, 1, 0];
                    const right = [
                        sinYaw,
                        0,
                        -cosYaw
                    ];
                    modelViewMatrix.set([
                        right[0], up[0], -lookAt[0], 0,
                        right[1], up[1], -lookAt[1], 0,
                        right[2], up[2], -lookAt[2], 0,
                        -cameraPos[0], -cameraPos[1], -cameraPos[2], 1
                    ]);
                }
                updateModelViewMatrix();

                // Terrain (simplified, static)
                const terrainSize = 500;
                const terrainSegments = 16;
                const terrainVertices = [];
                const terrainColors = [];
                const terrainIndices = [];
                const scale = terrainSize / terrainSegments;
                for (let z = 0; z <= terrainSegments; z++) {
                    for (let x = 0; x <= terrainSegments; x++) {
                        const px = (x / terrainSegments - 0.5) * terrainSize;
                        const pz = (z / terrainSegments - 0.5) * terrainSize;
                        const height = Math.sin(px / 100) * Math.cos(pz / 100) * 5; // Reduced height variation
                        terrainVertices.push(px, height, pz);
                        terrainColors.push(0.8, 0.2, 0.2); // Red terrain
                    }
                }
                for (let z = 0; z < terrainSegments; z++) {
                    for (let x = 0; x < terrainSegments; x++) {
                        const i = z * (terrainSegments + 1) + x;
                        terrainIndices.push(i, i + 1, i + terrainSegments + 1);
                        terrainIndices.push(i + 1, i + terrainSegments + 2, i + terrainSegments + 1);
                    }
                }

                const terrainBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, terrainBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(terrainVertices), gl.STATIC_DRAW);

                const terrainColorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, terrainColorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(terrainColors), gl.STATIC_DRAW);

                const terrainIndexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, terrainIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(terrainIndices), gl.STATIC_DRAW);
                console.log("Static terrain generated.");

                // Debug cube
                const cubeVertices = [
                    -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, 0.5, -0.5,  -0.5, 0.5, -0.5,
                    -0.5, -0.5, 0.5,   0.5, -0.5, 0.5,   0.5, 0.5, 0.5,   -0.5, 0.5, 0.5
                ];
                const cubeColors = new Array(24).fill(1).map((_, i) => i % 3 === 0 ? 1 : 0); // Red
                const cubeIndices = [
                    0, 1, 2,  0, 2, 3,  4, 5, 6,  4, 6, 7,
                    0, 4, 7,  0, 7, 3,  1, 5, 6,  1, 6, 2,
                    0, 1, 5,  0, 5, 4,  2, 3, 7,  2, 7, 6
                ];

                const cubeBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertices), gl.STATIC_DRAW);

                const cubeColorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, cubeColorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeColors), gl.STATIC_DRAW);

                const cubeIndexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeIndices), gl.STATIC_DRAW);
                console.log("Debug cube added.");

                // Objects (caves, temples, enemies, projectiles)
                const objects = [
                    // Caves
                    { type: 'cave', pos: [-50, -4, 50], scale: 8, color: [0.4, 0.4, 0.4] },
                    { type: 'cave', pos: [50, -4, -50], scale: 8, color: [0.4, 0.4, 0.4] },
                    // Temples
                    { type: 'temple', pos: [30, 4, 30], scale: 6, color: [0.7, 0.7, 0.7] },
                    { type: 'temple', pos: [-30, 4, -30], scale: 6, color: [0.7, 0.7, 0.7] }
                ];
                const enemies = [];
                const projectiles = [];

                function spawnEnemy() {
                    const type = Math.random() < 0.5 ? 'melee' : 'ranged';
                    enemies.push({
                        pos: [(Math.random() - 0.5) * terrainSize * 0.9, 1, (Math.random() - 0.5) * terrainSize * 0.9],
                        type: type,
                        health: type === 'melee' ? 50 : 75,
                        speed: type === 'melee' ? 2 : 1.5,
                        color: type === 'melee' ? [0, 1, 0] : [1, 0, 0]
                    });
                    console.log("Enemy spawned:", enemies[enemies.length - 1].pos);
                }
                for (let i = 0; i < 5; i++) spawnEnemy(); // Reduced initial enemies
                setInterval(spawnEnemy, 5000);

                // Player
                const player = {
                    health: 100,
                    shootCooldown: 0,
                    speed: 6,
                    sprintSpeed: 12,
                    velocity: [0, 0, 0],
                    bobTime: 0,
                    isSprinting: false
                };

                // Uniforms and attributes
                const uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');
                const uModelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
                const aPosition = gl.getAttribLocation(program, 'aPosition');
                const aColor = gl.getAttribLocation(program, 'aColor');

                // Joystick
                const joystickContainer = document.getElementById('joystickContainer');
                const joystick = document.getElementById('joystick');
                let joystickActive = false;
                let joystickOrigin = { x: 0, y: 0 };
                let joystickDelta = { x: 0, y: 0 };

                joystickContainer.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    joystickActive = true;
                    joystickOrigin = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    console.log("Joystick touch started.");
                });

                joystickContainer.addEventListener('touchmove', (e) => {
                    if (!joystickActive) return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    const dx = touch.clientX - joystickOrigin.x;
                    const dy = touch.clientY - joystickOrigin.y;
                    const maxRadius = 60;
                    const magnitude = Math.sqrt(dx * dx + dy * dy);
                    if (magnitude > maxRadius) {
                        const scale = maxRadius / magnitude;
                        joystickDelta.x = dx * scale;
                        joystickDelta.y = dy * scale;
                    } else {
                        joystickDelta.x = dx;
                        joystickDelta.y = dy;
                    }
                    joystick.style.transform = `translate(${joystickDelta.x}px, ${joystickDelta.y}px)`;
                });

                joystickContainer.addEventListener('touchend', () => {
                    joystickActive = false;
                    joystickDelta = { x: 0, y: 0 };
                    joystick.style.transform = `translate(0, 0)`;
                    console.log("Joystick touch ended.");
                });

                // Action buttons
                const shootBtn = document.getElementById('shootBtn');
                const sprintBtn = document.getElementById('sprintBtn');
                shootBtn.addEventListener('click', () => {
                    if (player.shootCooldown <= 0) {
                        shoot();
                        player.shootCooldown = 0.5;
                        console.log("Shoot fired.");
                    }
                });
                sprintBtn.addEventListener('touchstart', () => {
                    player.isSprinting = true;
                    console.log("Sprint started.");
                });
                sprintBtn.addEventListener('touchend', () => {
                    player.isSprinting = false;
                    console.log("Sprint ended.");
                });

                // Desktop controls
                const keys = {};
                document.addEventListener('keydown', (e) => {
                    keys[e.code] = true;
                    console.log("Key down:", e.code); // Debug key presses
                });
                document.addEventListener('keyup', (e) => {
                    keys[e.code] = false;
                    console.log("Key up:", e.code);
                });
                let mouseDown = false;
                document.addEventListener('mousedown', () => {
                    mouseDown = true;
                    console.log("Mouse down.");
                });
                document.addEventListener('mouseup', () => {
                    mouseDown = false;
                    console.log("Mouse up.");
                });
                document.addEventListener('mousemove', (e) => {
                    cameraRotVel.yaw -= e.movementX * 0.002;
                    cameraRotVel.pitch -= e.movementY * 0.002;
                });

                // Touch look
                let isLooking = false;
                let previousTouch = { x: 0, y: 0 };
                document.getElementById('gameCanvas').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    isLooking = true;
                    previousTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                });

                document.getElementById('gameCanvas').addEventListener('touchmove', (e) => {
                    if (!isLooking) return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - previousTouch.x;
                    const deltaY = touch.clientY - previousTouch.y;
                    cameraRotVel.yaw -= deltaX * 0.003;
                    cameraRotVel.pitch -= deltaY * 0.003;
                    previousTouch = { x: touch.clientX, y: touch.clientY };
                });

                document.getElementById('gameCanvas').addEventListener('touchend', () => {
                    isLooking = false;
                });

                // Shooting
                function shoot() {
                    const cosPitch = Math.cos(cameraPitch);
                    const sinPitch = Math.sin(cameraPitch);
                    const cosYaw = Math.cos(cameraYaw);
                    const sinYaw = Math.sin(cameraYaw);
                    const forward = [cosPitch * cosYaw, sinPitch, cosPitch * sinYaw];
                    const pos = [cameraPos[0] + forward[0] * 0.5, cameraPos[1] + forward[1] * 0.5, cameraPos[2] + forward[2] * 0.5];
                    projectiles.push({
                        pos: pos,
                        vel: [forward[0] * 30, forward[1] * 30, forward[2] * 30],
                        color: [0, 1, 1]
                    });
                }

                // Quests
                const quests = [
                    { id: 1, text: "Explore the Ancient Temple", target: [30, 4, 30] },
                    { id: 2, text: "Defeat 10 Enemies", kills: 0, targetKills: 10 }
                ];
                let currentQuest = quests[0];

                // Minimap
                const minimapCanvas = document.getElementById('minimapCanvas');
                const minimapCtx = minimapCanvas.getContext('2d');
                minimapCanvas.width = 150;
                minimapCanvas.height = 150;

                function updateMinimap() {
                    minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    minimapCtx.fillRect(0, 0, 150, 150);
                    minimapCtx.fillStyle = '#00ffcc';
                    minimapCtx.fillRect(75 - 2, 75 - 2, 4, 4);
                    enemies.forEach(enemy => {
                        const dx = enemy.pos[0] - cameraPos[0];
                        const dz = enemy.pos[2] - cameraPos[2];
                        const mx = 75 + (dx / terrainSize) * 150;
                        const my = 75 + (dz / terrainSize) * 150;
                        if (mx >= 0 && mx <= 150 && my >= 0 && my <= 150) {
                            minimapCtx.fillStyle = enemy.type === 'melee' ? '#00ff00' : '#ff0000';
                            minimapCtx.fillRect(mx - 2, my - 2, 4, 4);
                        }
                    });
                    if (currentQuest.target) {
                        const dx = currentQuest.target[0] - cameraPos[0];
                        const dz = currentQuest.target[2] - cameraPos[2];
                        const mx = 75 + (dx / terrainSize) * 150;
                        const my = 75 + (dz / terrainSize) * 150;
                        if (mx >= 0 && mx <= 150 && my >= 0 && my <= 150) {
                            minimapCtx.fillStyle = '#ffff00';
                            minimapCtx.fillRect(mx - 3, my - 3, 6, 6);
                        }
                    }
                }

                function updateHUD() {
                    document.getElementById('status').textContent = `Health: ${player.health} | Cooldown: ${Math.max(0, Math.floor(player.shootCooldown * 100))}%`;
                    document.getElementById('questLog').textContent = `Quest: ${currentQuest.text}`;
                }

                // Physics
                const gravity = -9.8;
                function getTerrainHeight(x, z) {
                    return Math.sin(x / 100) * Math.cos(z / 100) * 5;
                }

                // Animation loop
                let lastTime = performance.now();
                function animate() {
                    requestAnimationFrame(animate);
                    const now = performance.now();
                    const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
                    lastTime = now;

                    // Clear canvas
                    gl.clearColor(0.07, 0.07, 0.07, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    gl.enable(gl.DEPTH_TEST);

                    // Camera rotation
                    cameraPitch += cameraRotVel.pitch * deltaTime;
                    cameraYaw += cameraRotVel.yaw * deltaTime;
                    cameraPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch));
                    cameraRotVel.pitch *= 0.9;
                    cameraRotVel.yaw *= 0.9;
                    updateModelViewMatrix();

                    // Camera bob
                    if (Math.abs(player.velocity[0]) > 0 || Math.abs(player.velocity[2]) > 0) {
                        player.bobTime += deltaTime * (player.isSprinting ? 10 : 5);
                        cameraPos[1] += Math.sin(player.bobTime) * 0.05;
                    }

                    // Player movement
                    const speed = player.isSprinting ? player.sprintSpeed : player.speed;
                    const cosYaw = Math.cos(cameraYaw);
                    const sinYaw = Math.sin(cameraYaw);
                    const forward = [cosYaw, 0, sinYaw];
                    const right = [sinYaw, 0, -cosYaw];
                    player.velocity[0] = 0;
                    player.velocity[2] = 0;
                    if (joystickActive) {
                        const moveX = joystickDelta.x / 60;
                        const moveZ = joystickDelta.y / 60;
                        player.velocity[0] += right[0] * moveX * speed - forward[0] * moveZ * speed;
                        player.velocity[2] += right[2] * moveX * speed - forward[2] * moveZ * speed;
                    }
                    if (keys['KeyW']) {
                        player.velocity[0] -= forward[0] * speed;
                        player.velocity[2] -= forward[2] * speed;
                    }
                    if (keys['KeyS']) {
                        player.velocity[0] += forward[0] * speed;
                        player.velocity[2] += forward[2] * speed;
                    }
                    if (keys['KeyA']) {
                        player.velocity[0] -= right[0] * speed;
                        player.velocity[2] -= right[2] * speed;
                    }
                    if (keys['KeyD']) {
                        player.velocity[0] += right[0] * speed;
                        player.velocity[2] += right[2] * speed;
                    }
                    if (keys['Space']) {
                        player.isSprinting = true;
                    } else if (!sprintBtn.ontouchstart) {
                        player.isSprinting = false;
                    }
                    if (mouseDown && player.shootCooldown <= 0) {
                        shoot();
                        player.shootCooldown = 0.5;
                    }

                    // Gravity and terrain
                    player.velocity[1] += gravity * deltaTime;
                    cameraPos[0] += player.velocity[0] * deltaTime;
                    cameraPos[1] += player.velocity[1] * deltaTime;
                    cameraPos[2] += player.velocity[2] * deltaTime;
                    const terrainHeight = getTerrainHeight(cameraPos[0], cameraPos[2]) + 2;
                    if (cameraPos[1] < terrainHeight) {
                        cameraPos[1] = terrainHeight;
                        player.velocity[1] = 0;
                    }

                    // Enemy AI
                    enemies.forEach((enemy, i) => {
                        const dx = cameraPos[0] - enemy.pos[0];
                        const dz = cameraPos[2] - enemy.pos[2];
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        const dir = [dx / dist, 0, dz / dist];
                        if (enemy.type === 'melee') {
                            enemy.pos[0] += dir[0] * enemy.speed * deltaTime;
                            enemy.pos[2] += dir[2] * enemy.speed * deltaTime;
                            enemy.pos[1] = getTerrainHeight(enemy.pos[0], enemy.pos[2]) + 1;
                            if (dist < 1.5) {
                                player.health -= 10 * deltaTime;
                                updateHUD();
                            }
                        } else {
                            if (Math.random() < 0.01) {
                                projectiles.push({
                                    pos: [enemy.pos[0], enemy.pos[1], enemy.pos[2]],
                                    vel: [dir[0] * 15, 0, dir[2] * 15],
                                    color: [1, 0, 0]
                                });
                            }
                        }
                    });

                    // Projectiles
                    const projectilesToRemove = [];
                    projectiles.forEach((projectile, i) => {
                        projectile.pos[0] += projectile.vel[0] * deltaTime;
                        projectile.pos[1] += projectile.vel[1] * deltaTime;
                        projectile.pos[2] += projectile.vel[2] * deltaTime;
                        if (Math.abs(projectile.pos[0]) > terrainSize || Math.abs(projectile.pos[2]) > terrainSize) {
                            projectilesToRemove.push(i);
                        }
                        enemies.forEach((enemy, j) => {
                            const dx = projectile.pos[0] - enemy.pos[0];
                            const dy = projectile.pos[1] - enemy.pos[1];
                            const dz = projectile.pos[2] - enemy.pos[2];
                            if (Math.sqrt(dx * dx + dy * dy + dz * dz) < 1) {
                                enemy.health -= 25;
                                projectilesToRemove.push(i);
                                if (enemy.health <= 0) {
                                    enemies.splice(j, 1);
                                    if (currentQuest.id === 2) {
                                        currentQuest.kills++;
                                        if (currentQuest.kills >= currentQuest.targetKills) {
                                            currentQuest = quests[0];
                                        }
                                        updateHUD();
                                    }
                                }
                            }
                        });
                        const pdx = projectile.pos[0] - cameraPos[0];
                        const pdy = projectile.pos[1] - cameraPos[1];
                        const pdz = projectile.pos[2] - cameraPos[2];
                        if (projectile.vel[1] === 0 && Math.sqrt(pdx * pdx + pdy * pdy + pdz * pdz) < 1) {
                            player.health -= 20;
                            projectilesToRemove.push(i);
                            updateHUD();
                        }
                    });
                    projectilesToRemove.sort((a, b) => b - a).forEach(i => projectiles.splice(i, 1));

                    // Quest progress
                    if (currentQuest.target) {
                        const dx = currentQuest.target[0] - cameraPos[0];
                        const dz = currentQuest.target[2] - cameraPos[2];
                        if (Math.sqrt(dx * dx + dz * dz) < 5) {
                            currentQuest = quests[Math.min(currentQuest.id, quests.length - 1)];
                            updateHUD();
                        }
                    }

                    // Cooldown
                    player.shootCooldown = Math.max(0, player.shootCooldown - deltaTime);

                    // Render terrain
                    gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
                    gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);
                    gl.bindBuffer(gl.ARRAY_BUFFER, terrainBuffer);
                    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(aPosition);
                    gl.bindBuffer(gl.ARRAY_BUFFER, terrainColorBuffer);
                    gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(aColor);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, terrainIndexBuffer);
                    gl.drawElements(gl.TRIANGLES, terrainIndices.length, gl.UNSIGNED_SHORT, 0);

                    // Render debug cube
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer);
                    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeColorBuffer);
                    gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIndexBuffer);
                    gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_SHORT, 0);

                    // Render objects
                    objects.concat(enemies, projectiles).forEach(obj => {
                        const tempMatrix = modelViewMatrix.slice();
                        const scale = obj.scale || 1;
                        const translate = [
                            1, 0, 0, 0,
                            0, 1, 0, 0,
                            0, 0, 1, 0,
                            obj.pos[0], obj.pos[1], obj.pos[2], 1
                        ];
                        const scaledMatrix = [
                            tempMatrix[0] * scale, tempMatrix[1] * scale, tempMatrix[2] * scale, tempMatrix[3],
                            tempMatrix[4] * scale, tempMatrix[5] * scale, tempMatrix[6] * scale, tempMatrix[7],
                            tempMatrix[8] * scale, tempMatrix[9] * scale, tempMatrix[10] * scale, tempMatrix[11],
                            tempMatrix[12] + translate[12], tempMatrix[13] + translate[13], tempMatrix[14] + translate[14], tempMatrix[15]
                        ];
                        gl.uniformMatrix4fv(uModelViewMatrix, false, scaledMatrix);
                        gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer);
                        gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
                        gl.bindBuffer(gl.ARRAY_BUFFER, cubeColorBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(new Array(24).fill(0).map((_, i) => obj.color[i % 3])), gl.STATIC_DRAW);
                        gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIndexBuffer);
                        gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_SHORT, 0);
                    });

                    // Update minimap
                    updateMinimap();
                }

                // Resize
                window.addEventListener('resize', () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    gl.viewport(0, 0, canvas.width, canvas.height);
                    const aspect = canvas.width / canvas.height;
                    projectionMatrix[0] = (1 / Math.tan(fov / 2)) / aspect;
                    minimapCanvas.width = 150;
                    minimapCanvas.height = 150;
                    console.log("Window resized.");
                });

                // Initialize
                updateHUD();
                console.log("Starting animation loop...");
                animate();
            } catch (e) {
                console.error('Game initialization error:', e);
                alert(`Failed to initialize game: ${e.message}\n\nEnsure WebGL is enabled in your browser (Chrome, Firefox, Safari).`);
            }
        };
    </script>
</body>
</html>
