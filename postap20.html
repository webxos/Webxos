<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Post API</title>
    <style>
        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            width: 100%;
        }
        h1 {
            text-align: center;
            font-size: 2em;
            text-shadow: 0 0 10px #0f0;
        }
        .wizard, .board {
            background: #111;
            padding: 20px;
            border: 2px solid #0f0;
            border-radius: 5px;
            box-shadow: 0 0 15px #0f0;
            margin-bottom: 20px;
        }
        .wizard { display: block; }
        .board { display: none; }
        input, button, textarea {
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            margin: 5px 0;
            font-family: 'Courier New', monospace;
            width: 100%;
            box-sizing: border-box;
        }
        button {
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover { background: #0f0; color: #000; }
        .post { margin: 10px 0; padding: 10px; border: 1px solid #0f0; border-radius: 5px; }
        .api-key, .serial {
            word-break: break-all;
            font-size: 0.9em;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #0f0;
            color: #000;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        @media (max-width: 600px) {
            input, button, textarea { font-size: 0.9em; }
            .container { padding: 10px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Post API</h1>
        <div class="wizard" id="wizard">
            <h2>Setup Wizard</h2>
            <div id="createForm">
                <h3>Create API</h3>
                <input id="apiName" placeholder="API Name (e.g., API-MyBoard)" pattern="API-[A-Za-z0-9]+" required>
                <input id="password" type="password" placeholder="Password (optional)">
                <button onclick="createBulletin()">Create</button>
            </div>
            <div id="joinForm">
                <h3>Join API</h3>
                <input id="joinApiKey" placeholder="API Key">
                <input id="joinApiName" placeholder="API Name (e.g., API-MyBoard)" pattern="API-[A-Za-z0-9]+" required>
                <input id="joinSerial" placeholder="Serial">
                <input id="joinPassword" type="password" placeholder="Password (if required)">
                <button onclick="joinBulletin()">Join</button>
            </div>
            <button onclick="checkSetup()">Check Setup</button>
        </div>
        <div class="board" id="board">
            <h2 id="boardTitle"></h2>
            <div>API Key: <span id="apiKeyDisplay" class="api-key"></span> <button onclick="copyText('apiKeyDisplay')">Copy</button></div>
            <div>Serial: <span id="serialDisplay" class="serial"></span> <button onclick="copyText('serialDisplay')">Copy</button></div>
            <textarea id="postContent" placeholder="Enter post content"></textarea>
            <input id="fileInput" type="file">
            <button onclick="submitPost()">Post</button>
            <button onclick="showHistory()">Show History</button>
            <button onclick="diagnose()">Diagnose</button>
            <div id="posts"></div>
            <div id="history" style="display: none;"></div>
        </div>
        <div class="toast" id="toast"></div>
    </div>
    <script>
        const DB_NAME = 'post-api';
        const DB_VERSION = 3;
        const SALT = 'post-api-salt-v3';
        let db, virtualWorker, channel, peerConnection, dataChannel;
        let currentApiName = '', currentSerial = '', currentBoardId = '';
        const signalingStore = new Map();

        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (e) => {
                    db = e.target.result;
                    db.createObjectStore('bulletins', { keyPath: 'boardId' });
                    db.createObjectStore('posts', { autoIncrement: true });
                    db.createObjectStore('files', { autoIncrement: true });
                    db.createObjectStore('history', { autoIncrement: true });
                    db.createObjectStore('apiKeys', { keyPath: 'apiName' });
                    db.createObjectStore('signaling', { keyPath: 'boardId' });
                };
                request.onsuccess = () => { db = request.result; resolve(); };
                request.onerror = () => reject('IndexedDB failed');
            });
        }

        async function initVirtualWorker() {
            channel = new MessageChannel();
            virtualWorker = {
                postMessage: (msg) => channel.port1.postMessage(msg),
                onmessage: null
            };
            channel.port2.onmessage = (e) => virtualWorker.onmessage?.(e);
            virtualWorker.onmessage = async ({ data }) => {
                if (data.type === 'fetch') {
                    const [boardId, token] = data.url.split('/').slice(2);
                    const response = await handleApiRequest(boardId, token);
                    channel.port1.postMessage({ id: data.id, response });
                } else if (data.type === 'signaling') {
                    await handleSignalingMessage(data.message);
                }
            };
        }

        async function handleApiRequest(boardId, token) {
            const tx = db.transaction(['bulletins', 'posts', 'files'], 'readonly');
            const bulletinStore = tx.objectStore('bulletins');
            const bulletin = await new Promise(r => {
                bulletinStore.get(boardId).onsuccess = (e) => r(e.target.result);
            });
            if (!bulletin || bulletin.token !== token) return { status: 401, data: 'Unauthorized' };
            const postStore = tx.objectStore('posts');
            const posts = await new Promise(r => {
                postStore.getAll().onsuccess = (e) => r(e.target.result);
            });
            return { status: 200, data: posts };
        }

        async function handleSignalingMessage({ boardId, type, sdp, candidate }) {
            if (type === 'offer') {
                signalingStore.set(boardId, { sdp, type, candidates: [] });
                await saveSignalingMessage(boardId, { sdp, type });
            } else if (type === 'answer') {
                const offer = signalingStore.get(boardId);
                if (offer) {
                    await peerConnection.setRemoteDescription({ sdp, type });
                    offer.candidates.forEach(c => peerConnection.addIceCandidate(new RTCIceCandidate(c)));
                }
            } else if (type === 'candidate') {
                const offer = signalingStore.get(boardId);
                if (offer) offer.candidates.push(candidate);
                if (peerConnection.remoteDescription) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                }
                await saveSignalingMessage(boardId, { candidate });
            }
        }

        async function saveSignalingMessage(boardId, message) {
            const tx = db.transaction(['signaling'], 'readwrite');
            const store = tx.objectStore('signaling');
            await new Promise(r => { store.put({ boardId, ...message }).onsuccess = r; });
        }

        async function generateSerial() {
            return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
        }

        async function deriveKeyFromApiName(apiName) {
            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw', encoder.encode(apiName + SALT), { name: 'PBKDF2' }, false, ['deriveKey']
            );
            return crypto.subtle.deriveKey(
                { name: 'PBKDF2', salt: encoder.encode(SALT), iterations: 100000, hash: 'SHA-256' },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
        }

        async function generateApiKey(boardId, token, serial) {
            const key = await deriveKeyFromApiName(currentApiName);
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encoder = new TextEncoder();
            const data = encoder.encode(`${boardId}:${token}:${serial}:${Date.now()}`);
            const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, data);
            const encryptedBase64 = btoa(String.fromCharCode(...new Uint8Array(encrypted)));
            const ivBase64 = btoa(String.fromCharCode(...iv));
            return `API-${encryptedBase64}.${ivBase64}`;
        }

        async function decryptApiKey(apiKey, apiName, serial) {
            const [encryptedBase64, ivBase64] = apiKey.replace('API-', '').split('.');
            const key = await deriveKeyFromApiName(apiName);
            const iv = Uint8Array.from(atob(ivBase64), c => c.charCodeAt(0));
            const encrypted = Uint8Array.from(atob(encryptedBase64), c => c.charCodeAt(0));
            const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encrypted);
            const decoder = new TextDecoder();
            const [boardId, token, decryptedSerial, timestamp] = decoder.decode(decrypted).split(':');
            if (decryptedSerial !== serial) throw new Error('Invalid serial');
            return { boardId, token, timestamp };
        }

        async function createBulletin() {
            const apiName = document.getElementById('apiName').value;
            const password = document.getElementById('password').value;
            if (!apiName.match(/^API-[A-Za-z0-9]+$/)) {
                showToast('API Name must be API-xxxxxx');
                return;
            }
            currentApiName = apiName;
            currentSerial = await generateSerial();
            currentBoardId = crypto.randomUUID();
            const token = crypto.randomUUID();
            const apiKey = await generateApiKey(currentBoardId, token, currentSerial);
            const tx = db.transaction(['bulletins', 'apiKeys'], 'readwrite');
            const bulletinStore = tx.objectStore('bulletins');
            const apiKeysStore = tx.objectStore('apiKeys');
            await new Promise(r => {
                bulletinStore.put({ boardId: currentBoardId, token, password, apiName });
                apiKeysStore.put({ apiName, apiKey, serial: currentSerial });
                tx.oncomplete = r;
            });
            await startSignalingServer();
            document.getElementById('wizard').style.display = 'none';
            document.getElementById('board').style.display = 'block';
            document.getElementById('boardTitle').textContent = apiName;
            document.getElementById('apiKeyDisplay').textContent = apiKey;
            document.getElementById('serialDisplay').textContent = currentSerial;
            initWebRTC(true);
        }

        async function joinBulletin() {
            const apiKey = document.getElementById('joinApiKey').value;
            const apiName = document.getElementById('joinApiName').value;
            const serial = document.getElementById('joinSerial').value;
            const password = document.getElementById('joinPassword').value;
            if (!apiName.match(/^API-[A-Za-z0-9]+$/)) {
                showToast('API Name must be API-xxxxxx');
                return;
            }
            try {
                const { boardId, token } = await decryptApiKey(apiKey, apiName, serial);
                const tx = db.transaction(['bulletins'], 'readonly');
                const bulletinStore = tx.objectStore('bulletins');
                const bulletin = await new Promise(r => {
                    bulletinStore.get(boardId).onsuccess = (e) => r(e.target.result);
                });
                if (!bulletin || (bulletin.password && bulletin.password !== password)) {
                    showToast('Invalid credentials');
                    return;
                }
                currentApiName = apiName;
                currentSerial = serial;
                currentBoardId = boardId;
                await initWebRTC(false);
                document.getElementById('wizard').style.display = 'none';
                document.getElementById('board').style.display = 'block';
                document.getElementById('boardTitle').textContent = apiName;
                document.getElementById('apiKeyDisplay').textContent = apiKey;
                document.getElementById('serialDisplay').textContent = serial;
                await loadPosts();
            } catch (e) {
                showToast('Failed to join: ' + e.message);
            }
        }

        async function startSignalingServer() {
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            await handleSignalingMessage({ boardId: currentBoardId, type: 'offer', sdp: offer.sdp });
            peerConnection.onicecandidate = ({ candidate }) => {
                if (candidate) {
                    handleSignalingMessage({ boardId: currentBoardId, type: 'candidate', candidate });
                }
            };
        }

        async function initWebRTC(isCreator) {
            peerConnection = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });
            dataChannel = isCreator ? peerConnection.createDataChannel('dataChannel') : null;
            peerConnection.ondatachannel = (e) => {
                dataChannel = e.channel;
                setupDataChannel();
            };
            peerConnection.onconnectionstatechange = () => {
                if (peerConnection.connectionState === 'connected') {
                    showToast('Connected to peers');
                    loadPosts();
                }
            };
            if (!isCreator) {
                const tx = db.transaction(['signaling'], 'readonly');
                const store = tx.objectStore('signaling');
                const message = await new Promise(r => {
                    store.get(currentBoardId).onsuccess = (e) => r(e.target.result);
                });
                if (message && message.sdp) {
                    await peerConnection.setRemoteDescription({ sdp: message.sdp, type: message.type });
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    await handleSignalingMessage({ boardId: currentBoardId, type: 'answer', sdp: answer.sdp });
                    if (message.candidate) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
                    }
                }
            }
            setupDataChannel();
        }

        function setupDataChannel() {
            if (!dataChannel) return;
            dataChannel.onopen = () => {
                dataChannel.send(JSON.stringify({ type: 'syncApiKey', apiKey: document.getElementById('apiKeyDisplay').textContent, apiName: currentApiName, serial: currentSerial }));
            };
            dataChannel.onmessage = async (e) => {
                const msg = JSON.parse(e.data);
                if (msg.type === 'post') {
                    await savePost(msg.data);
                    loadPosts();
                } else if (msg.type === 'syncApiKey') {
                    document.getElementById('apiKeyDisplay').textContent = msg.apiKey;
                    document.getElementById('serialDisplay').textContent = msg.serial;
                    currentApiName = msg.apiName;
                    const tx = db.transaction(['apiKeys'], 'readwrite');
                    const store = tx.objectStore('apiKeys');
                    await new Promise(r => { store.put({ apiName: msg.apiName, apiKey: msg.apiKey, serial: msg.serial }).onsuccess = r; });
                }
            };
        }

        async function submitPost() {
            const content = document.getElementById('postContent').value;
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            let postData = { content, timestamp: Date.now() };
            if (file) {
                const fileData = await file.arrayBuffer();
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const key = await deriveKeyFromApiName(currentApiName);
                const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, fileData);
                postData.file = { name: file.name, data: btoa(String.fromCharCode(...new Uint8Array(encrypted))), iv: btoa(String.fromCharCode(...iv)) };
            }
            await savePost(postData);
            if (dataChannel?.readyState === 'open') {
                dataChannel.send(JSON.stringify({ type: 'post', data: postData }));
            }
            const token = crypto.randomUUID();
            const newApiKey = await generateApiKey(currentBoardId, token, currentSerial);
            document.getElementById('apiKeyDisplay').textContent = newApiKey;
            const tx = db.transaction(['bulletins', 'apiKeys'], 'readwrite');
            const bulletinStore = tx.objectStore('bulletins');
            const apiKeysStore = tx.objectStore('apiKeys');
            await new Promise(r => {
                bulletinStore.put({ boardId: currentBoardId, token, apiName: currentApiName, password: (await bulletinStore.get(currentBoardId)).password });
                apiKeysStore.put({ apiName: currentApiName, apiKey: newApiKey, serial: currentSerial });
                tx.oncomplete = r;
            });
            if (dataChannel?.readyState === 'open') {
                dataChannel.send(JSON.stringify({ type: 'syncApiKey', apiKey: newApiKey, apiName: currentApiName, serial: currentSerial }));
            }
            loadPosts();
            document.getElementById('postContent').value = '';
            fileInput.value = '';
        }

        async function savePost(postData) {
            const tx = db.transaction(['posts', 'history'], 'readwrite');
            const postStore = tx.objectStore('posts');
            const historyStore = tx.objectStore('history');
            await new Promise(r => {
                postStore.add(postData).onsuccess = () => {
                    historyStore.add({ action: 'post', data: postData, timestamp: Date.now() }).onsuccess = r;
                };
            });
        }

        async function loadPosts() {
            const tx = db.transaction(['posts'], 'readonly');
            const store = tx.objectStore('posts');
            const posts = await new Promise(r => {
                store.getAll().onsuccess = (e) => r(e.target.result);
            });
            const postsDiv = document.getElementById('posts');
            postsDiv.innerHTML = '';
            for (const post of posts) {
                const postDiv = document.createElement('div');
                postDiv.className = 'post';
                postDiv.textContent = post.content || 'File: ' + post.file?.name;
                if (post.file) {
                    const link = document.createElement('a');
                    link.href = '#';
                    link.textContent = 'Download';
                    link.onclick = () => downloadFile(post.file);
                    postDiv.appendChild(link);
                }
                postsDiv.appendChild(postDiv);
            }
        }

        async function downloadFile(file) {
            const key = await deriveKeyFromApiName(currentApiName);
            const iv = Uint8Array.from(atob(file.iv), c => c.charCodeAt(0));
            const encrypted = Uint8Array.from(atob(file.data), c => c.charCodeAt(0));
            const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encrypted);
            const blob = new Blob([decrypted]);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = file.name;
            a.click();
            URL.revokeObjectURL(url);
        }

        async function showHistory() {
            const tx = db.transaction(['history'], 'readonly');
            const store = tx.objectStore('history');
            const history = await new Promise(r => {
                store.getAll().onsuccess = (e) => r(e.target.result);
            });
            const historyDiv = document.getElementById('history');
            historyDiv.innerHTML = history.map(h => `<div>${new Date(h.timestamp).toLocaleString()}: ${h.action} - ${JSON.stringify(h.data)}</div>`).join('');
            historyDiv.style.display = 'block';
        }

        async function diagnose() {
            const tx = db.transaction(['history'], 'readonly');
            const store = tx.objectStore('history');
            const history = await new Promise(r => {
                store.getAll().onsuccess = (e) => r(e.target.result);
            });
            showToast('Diagnostic: ' + history.length + ' actions logged');
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.style.display = 'block';
            setTimeout(() => { toast.style.display = 'none'; }, 3000);
        }

        function copyText(id) {
            const text = document.getElementById(id).textContent;
            navigator.clipboard.writeText(text).then(() => showToast('Copied to clipboard'));
        }

        function checkSetup() {
            if (!window.isSecureContext) {
                showToast('Please serve over HTTPS or localhost');
                return;
            }
            showToast('Setup OK: Running in secure context');
        }

        window.onunload = () => {
            if (peerConnection) peerConnection.close();
            indexedDB.deleteDatabase(DB_NAME);
        };

        (async () => {
            await initDB();
            await initVirtualWorker();
            checkSetup();
        })();
    </script>
</body>
</html>
