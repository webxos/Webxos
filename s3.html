<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sacred</title>
    <style>
        body { background: #000; color: #00FF00; font-family: 'Courier New', monospace; margin: 0; padding: 10px; overflow: hidden }
        h1.glow-text { font-size: 18px; margin: 0; padding: 0; text-shadow: 0 0 20px #00FF00, 0 0 30px #00FF00, 0 0 40px #00FF00; animation: glow 1s infinite alternate }
        @keyframes glow { from { text-shadow: 0 0 10px #00FF00, 0 0 20px #00FF00, 0 0 30px #00FF00 } to { text-shadow: 0 0 20px #00FF00, 0 0 30px #00FF00, 0 0 40px #00FF00 } }
        .symbol-container { position: relative; width: 100%; height: 70vh; margin: 10px 0; overflow: hidden }
        .symbol { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; border: 1px solid #00FF00; border-radius: 5px; box-shadow: 0 0 20px #00FF00, 0 0 30px #00FF00, 0 0 40px #00FF00; background: #000 }
        .hologram {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            transform-style: preserve-3d;
            animation: rotateHologram 60s infinite linear;
        }
        .grid-shape {
            position: absolute;
            background: transparent;
            border: 3px solid #00FF00;
            box-shadow: 0 0 15px #00FF00, 0 0 30px #00FF00;
            animation: pulseShape 4s infinite;
        }
        .grid-shape.pyramid { clip-path: polygon(50% 0%, 0% 100%, 100% 100%); }
        .draw-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .draw-canvas.active {
            pointer-events: auto;
        }
        button { display: inline-block; margin: 2px; padding: 5px 10px; font-size: 12px; background: #000; color: #00FF00; border: 1px solid #00FF00; border-radius: 3px; transition: all 0.3s ease; box-shadow: 0 0 15px #00FF00, 0 0 25px #00FF00 }
        button:hover { background: #00FF00; color: #000; box-shadow: 0 0 25px #00FF00, 0 0 35px #00FF00, 0 0 45px #00FF00 }
        .button-container { display: flex; flex-wrap: wrap; justify-content: center }
        .copyright { position: fixed; bottom: 10px; width: 100%; font-size: 10px; color: #FFFFFF; text-shadow: 0 0 15px #FFFFFF }
        .confirmation { font-family: 'Impact', sans-serif; position: fixed; bottom: 25px; width: 100%; text-align: center; color: #00FF00; text-shadow: 0 0 15px #00FF00, 0 0 25px #00FF00; font-size: 14px; display: block }
        .wallet-popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #000; border: 2px solid #00FF00; padding: 20px; box-shadow: 0 0 20px #00FF00; z-index: 1000; color: #00FF00; font-family: 'Courier New', monospace }
        .wallet-popup input { background: #000; color: #00FF00; border: 1px solid #00FF00; padding: 5px; margin: 5px; font-family: 'Courier New', monospace; width: 250px }
        .wallet-popup button { margin: 5px }
        .wallet-popup canvas { border: 1px solid #00FF00; margin-top: 10px; width: 200px; height: 200px }
        .wallet-popup h2 { color: #00FF00; text-shadow: 0 0 10px #00FF00 }
        .close-btn { position: absolute; top: 10px; right: 10px; cursor: pointer; color: #00FF00; text-shadow: 0 0 10px #00FF00 }
        @media (max-width: 600px) {
            h1.glow-text { font-size: 16px; }
            button { font-size: 10px; padding: 4px 8px; }
            .confirmation { font-size: 12px; }
            .copyright { font-size: 8px; }
            .wallet-popup { padding: 15px; width: 90%; }
            .wallet-popup input { width: 100%; font-size: 10px; }
            .wallet-popup canvas { width: 150px; height: 150px; }
            .grid-shape { box-shadow: 0 0 10px #00FF00, 0 0 20px #00FF00; }
        }
        @keyframes rotateHologram {
            0% { transform: rotateY(0deg) rotateX(15deg); }
            100% { transform: rotateY(360deg) rotateX(15deg); }
        }
        @keyframes pulseShape {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <h1 class="glow-text">Sacred AI (beta)</h1>
    <div class="symbol-container">
        <div id="dynamic-shape" class="symbol"></div>
        <canvas id="draw-canvas" class="draw-canvas"></canvas>
    </div>
    <div class="button-container">
        <button onclick="generateShape()">Generate Shape</button>
        <button id="autoGenerateBtn" onclick="toggleAutoGenerate()">Auto Generate: Off</button>
        <button onclick="zoomIn()">Zoom In</button>
        <button onclick="zoomOut()">Zoom Out</button>
        <button onclick="rotateShape()">Rotate</button>
        <button onclick="changeUIColor()">Change UI Color</button>
        <button onclick="toggleDraw()">Draw</button>
        <button onclick="toggleLine()">Line</button>
        <button onclick="clearDrawing()">Clear Drawing</button>
        <button onclick="toggle3DMode()">3D Mode</button>
        <button onclick="openWallet()">Wallet</button>
    </div>
    <div class="confirmation" id="confirmationText"></div>
    <div class="copyright">© 2025 WebXOS</div>
    <div class="wallet-popup" id="walletPopup">
        <span class="close-btn" onclick="closeWallet()">X</span>
        <h2>Wallet</h2>
        <input type="text" id="nftSerialInput" placeholder="Enter Serial (e.g., HOLO-000001-ABC)">
        <input type="text" id="nftCodeInput" placeholder="Enter Code (e.g., Ω-CODE: ---111---)">
        <button onclick="loadNFTImage()">Load Image</button>
        <button onclick="copyCurrentNFTCode()">Copy Current NFT Serial & Code</button>
        <canvas id="walletCanvas"></canvas>
    </div>
    <script>
        // UI Colors
        const uiColors = ['#00FF00', '#FF00FF', '#FF0000', '#00FFFF', '#FFFF00', '#FFFFFF', '#AAAAAA'];
        let currentColorIndex = 0;
        let autoGenerateInterval = null;
        let isAutoGenerating = false;
        let currentSerial = '';
        let currentCode = '';
        let currentScale = 1;
        let currentRotation = 0;
        let currentShapePattern = null;
        let isDrawing = false;
        let isLineMode = false;
        let strokes = [];
        let currentStroke = [];
        let lineStart = null;
        let serialCounter = 1;
        let serialMap = new Map();
        let is3DMode = false;
        let current3DGrid = null;

        // Drawing Canvas Setup
        const drawCanvas = document.getElementById('draw-canvas');
        const drawCtx = drawCanvas.getContext('2d');
        let canvasWidth, canvasHeight;

        function resizeCanvas() {
            try {
                const container = document.querySelector('.symbol-container');
                if (!container) throw new Error('Symbol container not found');
                canvasWidth = container.offsetWidth;
                canvasHeight = container.offsetHeight;
                drawCanvas.width = canvasWidth;
                drawCanvas.height = canvasHeight;
                drawCtx.lineWidth = 3;
                drawCtx.lineCap = 'round';
                drawCtx.lineJoin = 'round';
                drawCtx.strokeStyle = uiColors[currentColorIndex];
                redrawStrokes();
                console.log('Canvas resized:', canvasWidth, canvasHeight);
            } catch (error) {
                showConfirmation(`ERROR: Canvas resize failed - ${error.message}`);
                console.error('Canvas resize error:', error);
            }
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Exoskeleton AI Serial/Code Functions
        function hashCode(str, salt = '') {
            try {
                let hash = 2166136261;
                const saltedStr = str + salt;
                for (let i = 0; i < saltedStr.length; i++) {
                    hash ^= saltedStr.charCodeAt(i);
                    hash *= 16777619;
                }
                return Math.abs(hash);
            } catch (error) {
                showConfirmation(`ERROR: Hash code failed - ${error.message}`);
                return 0;
            }
        }

        function seededRandom(seed) {
            try {
                let x = Math.sin(seed++) * 10000;
                return x - Math.floor(x);
            } catch (error) {
                showConfirmation(`ERROR: Seeded random failed - ${error.message}`);
                return Math.random();
            }
        }

        function saveState() {
            try {
                localStorage.setItem('sacredAISerialMap', JSON.stringify([...serialMap]));
                localStorage.setItem('sacredAISerialCounter', serialCounter);
            } catch (error) {
                showConfirmation(`ERROR: Failed to save state - ${error.message}`);
            }
        }

        function loadState() {
            try {
                const savedMap = localStorage.getItem('sacredAISerialMap');
                const savedCounter = localStorage.getItem('sacredAISerialCounter');
                if (savedMap) {
                    serialMap = new Map(JSON.parse(savedMap));
                }
                serialCounter = parseInt(savedCounter) || 1;
                if (serialCounter < 1 || serialCounter > 999999) {
                    serialCounter = 1;
                }
                const maxSerial = Math.max(...Array.from(serialMap.keys())
                    .filter(s => s.startsWith('HOLO-'))
                    .map(s => parseInt(s.split('-')[1]) || 0), 0);
                if (maxSerial >= serialCounter) {
                    serialCounter = maxSerial + 1;
                }
                console.log('State loaded:', serialCounter, serialMap.size);
            } catch (error) {
                showConfirmation(`ERROR: Failed to load state - ${error.message}`);
            }
        }

        function compressDatabase(entries) {
            try {
                return JSON.stringify(entries);
            } catch (error) {
                showConfirmation(`ERROR: Compression failed - ${error.message}`);
                return '';
            }
        }

        function decompressDatabase(compressed, seed) {
            try {
                return JSON.parse(compressed);
            } catch (error) {
                showConfirmation(`ERROR: Decompression failed - ${error.message}`);
                return [];
            }
        }

        function encodeDatabase(entries, serial) {
            try {
                const compressed = compressDatabase(entries);
                const seed = hashCode(serial);
                let encoded = '';
                for (let i = 0; i < compressed.length; i++) {
                    const charCode = compressed.charCodeAt(i);
                    const shift = (seed >> (i % 32)) & 0xFF;
                    encoded += String.fromCharCode((charCode + shift) % 256);
                }
                return btoa(encoded);
            } catch (error) {
                showConfirmation(`ERROR: Encoding failed - ${error.message}`);
                return '';
            }
        }

        function decodeDatabase(encoded, serial) {
            try {
                const seed = hashCode(serial);
                const decoded = atob(encoded);
                let decompressed = '';
                for (let i = 0; i < decoded.length; i++) {
                    const charCode = decoded.charCodeAt(i);
                    const shift = (seed >> (i % 32)) & 0xFF;
                    decompressed += String.fromCharCode((charCode - shift + 256) % 256);
                }
                return decompressDatabase(decompressed, seed);
            } catch (error) {
                showConfirmation(`ERROR: Decoding failed - ${error.message}`);
                return [];
            }
        }

        function generateRandomSuffix() {
            try {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let suffix = '';
                for (let i = 0; i < 3; i++) {
                    suffix += chars.charAt(Math.floor(seededRandom(hashCode(suffix + i)) * chars.length));
                }
                return suffix.toUpperCase();
            } catch (error) {
                showConfirmation(`ERROR: Suffix generation failed - ${error.message}`);
                return 'XYZ';
            }
        }

        function generateSerialNumber(code) {
            try {
                let serial;
                let attempts = 0;
                const maxAttempts = 1000;
                do {
                    if (serialCounter > 999999) {
                        serialCounter = 1;
                    }
                    const paddedNumber = String(serialCounter++).padStart(6, '0');
                    const suffix = generateRandomSuffix();
                    serial = `HOLO-${paddedNumber}-${suffix}`;
                    attempts++;
                    if (attempts > maxAttempts) {
                        showConfirmation('ERROR: Failed to generate unique serial');
                        return null;
                    }
                } while (serialMap.has(serial));
                serialMap.set(serial, { code, encryptedDatabase: '', strokes: [] });
                saveState();
                console.log('Serial generated:', serial);
                return serial;
            } catch (error) {
                showConfirmation(`ERROR: Serial generation failed - ${error.message}`);
                return null;
            }
        }

        function generateCrypticCode(serial) {
            try {
                const glyphs = 'ΔΩΨΘΣΦΩΓΛΞΠΩ0123456789#@&%*+-=<>';
                let code = '';
                const seedValue = hashCode(serial + 'CODE');
                for (let i = 0; i < 9; i++) {
                    code += glyphs.charAt(Math.floor(seededRandom(seedValue + i) * glyphs.length));
                }
                return `Ω-CODE: ${code}`;
            } catch (error) {
                showConfirmation(`ERROR: Code generation failed - ${error.message}`);
                return 'Ω-CODE: ERRORCODE';
            }
        }

        // Shape Generation (2D)
        function generateShape() {
            try {
                console.log('Generating 2D shape...');
                const shapeElement = document.getElementById('dynamic-shape');
                if (!shapeElement) throw new Error('Dynamic shape element not found');
                shapeElement.innerHTML = '';
                is3DMode = false;
                const currentColor = uiColors[currentColorIndex];
                const patterns = [
                    () => `repeating-radial-gradient(circle, ${currentColor} ${rand(2,15)}px, #000 ${rand(2,15)}px, #000 ${rand(5,20)}px, ${currentColor} ${rand(5,20)}px)`,
                    () => `repeating-linear-gradient(${rand(0,360)}deg, transparent ${rand(5,15)}px, ${currentColor} ${rand(5,15)}px, ${currentColor} ${rand(10,25)}px, transparent ${rand(10,25)}px)`,
                    () => `repeating-radial-gradient(${currentColor} ${rand(5,20)}px, transparent ${rand(5,20)}px, #000 ${rand(10,30)}px)`,
                    () => `repeating-linear-gradient(${rand(0,360)}deg, ${currentColor} ${rand(5,20)}px, transparent ${rand(5,20)}px, ${currentColor} ${rand(10,30)}px)`,
                    () => `repeating-linear-gradient(${rand(0,360)}deg, transparent ${rand(2,10)}px, ${currentColor} ${rand(2,10)}px), repeating-linear-gradient(${rand(0,360)}deg, transparent ${rand(2,10)}px, ${currentColor} ${rand(2,10)}px)`,
                    () => `repeating-radial-gradient(${currentColor} ${rand(2,15)}px, transparent ${rand(2,15)}px, #000 ${rand(5,20)}px)`,
                    () => `repeating-linear-gradient(${rand(0,360)}deg, ${currentColor} ${rand(2,15)}px, transparent ${rand(2,15)}px, #000 ${rand(5,20)}px)`
                ];
                const patternIndex = Math.floor(Math.random() * patterns.length);
                currentShapePattern = { index: patternIndex, color: currentColor, randValues: [] };
                const patternFunc = patterns[patternIndex];
                const originalRand = Math.random;
                Math.random = () => {
                    const val = Math.random();
                    currentShapePattern.randValues.push(val);
                    return val;
                };
                shapeElement.style.background = patternFunc();
                Math.random = originalRand;
                currentScale = rand(0.8, 1.2);
                currentRotation = rand(0, 360);
                current3DGrid = null;
                updateTransform(shapeElement);
                if (!isAutoGenerating) {
                    generateNFT();
                }
                console.log('2D shape generated:', currentShapePattern);
            } catch (error) {
                showConfirmation(`ERROR: Shape generation failed - ${error.message}`);
                console.error('Shape generation error:', error);
            }
        }

        // 3D Shape Generation
        function generate3DGrid() {
            try {
                console.log('Generating 3D shape...');
                const shapeElement = document.getElementById('dynamic-shape');
                if (!shapeElement) throw new Error('Dynamic shape element not found');
                shapeElement.style.background = 'none';
                shapeElement.innerHTML = '<div class="hologram" id="hologram"></div>';
                const hologram = document.getElementById('hologram');
                const hash = hashCode(currentSerial + JSON.stringify(strokes));
                let seedValue = hash;
                const rand = (min, max) => {
                    seedValue = hashCode(String(seedValue));
                    return min + (seedValue % (max - min + 1));
                };
                const randFloat = (min, max) => {
                    seedValue = hashCode(String(seedValue));
                    return min + ((seedValue % 10000) / 10000) * (max - min);
                };
                const shapeType = rand(0, 1) ? 'pyramid' : 'grid';
                const size = Math.min(canvasWidth, canvasHeight) * 0.6;
                const shape = document.createElement('div');
                shape.className = `grid-shape ${shapeType}`;
                shape.style.width = `${size}px`;
                shape.style.height = `${size}px`;
                shape.style.left = `${(canvasWidth - size) / 2}px`;
                shape.style.top = `${(canvasHeight - size) / 2}px`;
                shape.style.transform = `translateZ(0px) rotateX(45deg) rotateY(45deg)`;
                shape.style.opacity = 0.8;
                shape.style.borderColor = uiColors[currentColorIndex];
                shape.style.boxShadow = `0 0 15px ${uiColors[currentColorIndex]}, 0 0 30px ${uiColors[currentColorIndex]}`;
                if (shapeType === 'grid') {
                    shape.style.background = `repeating-linear-gradient(45deg, ${uiColors[currentColorIndex]} 0px, ${uiColors[currentColorIndex]} 5px, transparent 5px, transparent 20px)`;
                }
                hologram.appendChild(shape);
                current3DGrid = {
                    shape: { type: shapeType, size, left: (canvasWidth - size) / 2, top: (canvasHeight - size) / 2, z: 0, rotateX: 45, rotateY: 45, opacity: 0.8 },
                    color: uiColors[currentColorIndex],
                    seed: hash
                };
                currentScale = 1;
                currentRotation = 0;
                updateTransform(shapeElement);
                if (!isAutoGenerating) {
                    generateNFT();
                }
                console.log('3D shape generated:', current3DGrid);
            } catch (error) {
                showConfirmation(`ERROR: 3D shape generation failed - ${error.message}`);
                console.error('3D shape generation error:', error);
            }
        }

        function regenerate3DGrid(gridData, scale, rotation, strokesData) {
            try {
                console.log('Regenerating 3D shape...');
                const shapeElement = document.getElementById('dynamic-shape');
                shapeElement.style.background = 'none';
                shapeElement.innerHTML = '<div class="hologram" id="hologram"></div>';
                const hologram = document.getElementById('hologram');
                current3DGrid = gridData;
                const shape = document.createElement('div');
                shape.className = `grid-shape ${gridData.shape.type}`;
                shape.style.width = `${gridData.shape.size}px`;
                shape.style.height = `${gridData.shape.size}px`;
                shape.style.left = `${gridData.shape.left}px`;
                shape.style.top = `${gridData.shape.top}px`;
                shape.style.transform = `translateZ(${gridData.shape.z}px) rotateX(${gridData.shape.rotateX}deg) rotateY(${gridData.shape.rotateY}deg)`;
                shape.style.opacity = gridData.shape.opacity;
                shape.style.borderColor = gridData.color;
                shape.style.boxShadow = `0 0 15px ${gridData.color}, 0 0 30px ${gridData.color}`;
                if (gridData.shape.type === 'grid') {
                    shape.style.background = `repeating-linear-gradient(45deg, ${gridData.color} 0px, ${gridData.color} 5px, transparent 5px, transparent 20px)`;
                }
                hologram.appendChild(shape);
                currentScale = scale;
                currentRotation = rotation;
                updateTransform(shapeElement);
                strokes = strokesData || [];
                redrawStrokes();
                console.log('3D shape regenerated');
            } catch (error) {
                showConfirmation(`ERROR: 3D shape regeneration failed - ${error.message}`);
                console.error('3D shape regeneration error:', error);
            }
        }

        function toggle3DMode() {
            try {
                console.log('Toggling 3D mode...');
                is3DMode = !is3DMode;
                const modeBtn = document.querySelector('button[onclick="toggle3DMode()"]');
                modeBtn.innerText = is3DMode ? '3D Mode: On' : '3D Mode';
                if (is3DMode) {
                    generate3DGrid();
                } else {
                    generateShape();
                }
            } catch (error) {
                showConfirmation(`ERROR: Toggling 3D mode failed - ${error.message}`);
                console.error('3D mode toggle error:', error);
            }
        }

        function regenerateShape(patternData, scale, rotation, strokesData) {
            try {
                console.log('Regenerating 2D shape...');
                const shapeElement = document.getElementById('dynamic-shape');
                shapeElement.innerHTML = '';
                const patterns = [
                    () => `repeating-radial-gradient(circle, ${patternData.color} ${patternData.randValues[0]*13+2}px, #000 ${patternData.randValues[1]*13+2}px, #000 ${patternData.randValues[2]*15+5}px, ${patternData.color} ${patternData.randValues[3]*15+5}px)`,
                    () => `repeating-linear-gradient(${patternData.randValues[0]*360}deg, transparent ${patternData.randValues[1]*10+5}px, ${patternData.color} ${patternData.randValues[2]*10+5}px, ${patternData.color} ${patternData.randValues[3]*15+10}px, transparent ${patternData.randValues[4]*15+10}px)`,
                    () => `repeating-radial-gradient(${patternData.color} ${patternData.randValues[0]*15+5}px, transparent ${patternData.randValues[1]*15+5}px, #000 ${patternData.randValues[2]*20+10}px)`,
                    () => `repeating-linear-gradient(${patternData.randValues[0]*360}deg, ${patternData.color} ${patternData.randValues[1]*15+5}px, transparent ${patternData.randValues[2]*15+5}px, ${patternData.color} ${patternData.randValues[3]*20+10}px)`,
                    () => `repeating-linear-gradient(${patternData.randValues[0]*360}deg, transparent ${patternData.randValues[1]*8+2}px, ${patternData.color} ${patternData.randValues[2]*8+2}px), repeating-linear-gradient(${patternData.randValues[3]*360}deg, transparent ${patternData.randValues[4]*8+2}px, ${patternData.color} ${patternData.randValues[5]*8+2}px)`,
                    () => `repeating-radial-gradient(${patternData.color} ${patternData.randValues[0]*13+2}px, transparent ${patternData.randValues[1]*13+2}px, #000 ${patternData.randValues[2]*15+5}px)`,
                    () => `repeating-linear-gradient(${patternData.randValues[0]*360}deg, ${patternData.color} ${patternData.randValues[1]*13+2}px, transparent ${patternData.randValues[2]*13+2}px, #000 ${patternData.randValues[3]*15+5}px)`
                ];
                shapeElement.style.background = patterns[patternData.index]();
                currentShapePattern = patternData;
                currentScale = scale;
                currentRotation = rotation;
                updateTransform(shapeElement);
                strokes = strokesData || [];
                redrawStrokes();
                console.log('2D shape regenerated');
            } catch (error) {
                showConfirmation(`ERROR: Shape regeneration failed - ${error.message}`);
                console.error('Shape regeneration error:', error);
            }
        }

        function generateNFT() {
            try {
                console.log('Generating NFT...');
                const shapeData = {
                    is3DMode,
                    pattern: is3DMode ? null : currentShapePattern,
                    grid: is3DMode ? current3DGrid : null,
                    scale: currentScale,
                    rotation: currentRotation,
                    colorIndex: currentColorIndex,
                    strokes
                };
                let newCode;
                do {
                    newCode = generateCrypticCode('NFT' + serialCounter + JSON.stringify(shapeData));
                } while (Array.from(serialMap.values()).some(data => data.code === newCode));
                const serial = generateSerialNumber(newCode);
                if (!serial) return;
                const encodedData = encodeDatabase([shapeData], serial);
                if (!encodedData) return;
                serialMap.set(serial, { code: newCode, encryptedDatabase: encodedData, strokes });
                saveState();
                currentSerial = serial;
                currentCode = newCode;
                if (!isAutoGenerating) {
                    showConfirmation(`New Shape Generated! ${serial} | ${newCode}`);
                    navigator.clipboard.writeText(`${serial}\n${newCode}`).then(() => {
                        showConfirmation('Serial and code copied to clipboard');
                    }).catch(() => {
                        showConfirmation('ERROR: Failed to copy serial and code');
                    });
                }
                console.log('NFT generated:', serial, newCode);
            } catch (error) {
                showConfirmation(`ERROR: NFT generation failed - ${error.message}`);
                console.error('NFT generation error:', error);
            }
        }

        function updateTransform(shapeElement) {
            try {
                shapeElement.style.transform = `rotate(${currentRotation}deg) scale(${currentScale})`;
                drawCanvas.style.transform = `rotate(${currentRotation}deg) scale(${currentScale})`;
            } catch (error) {
                showConfirmation(`ERROR: Transform update failed - ${error.message}`);
                console.error('Transform update error:', error);
            }
        }

        function zoomIn() {
            try {
                const shapeElement = document.getElementById('dynamic-shape');
                currentScale = Math.min(currentScale + 0.1, 2.0);
                updateTransform(shapeElement);
                console.log('Zoomed in:', currentScale);
            } catch (error) {
                showConfirmation(`ERROR: Zoom in failed - ${error.message}`);
                console.error('Zoom in error:', error);
            }
        }

        function zoomOut() {
            try {
                const shapeElement = document.getElementById('dynamic-shape');
                currentScale = Math.max(currentScale - 0.1, 0.5);
                updateTransform(shapeElement);
                console.log('Zoomed out:', currentScale);
            } catch (error) {
                showConfirmation(`ERROR: Zoom out failed - ${error.message}`);
                console.error('Zoom out error:', error);
            }
        }

        function rotateShape() {
            try {
                const shapeElement = document.getElementById('dynamic-shape');
                currentRotation = (currentRotation + 90) % 360;
                updateTransform(shapeElement);
                console.log('Rotated:', currentRotation);
            } catch (error) {
                showConfirmation(`ERROR: Rotate failed - ${error.message}`);
                console.error('Rotate error:', error);
            }
        }

        function rand(min, max) {
            return Math.random() * (max - min) + min;
        }

        function showConfirmation(message) {
            try {
                const confirmation = document.getElementById('confirmationText');
                confirmation.innerText = message;
                confirmation.style.display = 'block';
                setTimeout(() => { confirmation.style.display = 'none'; }, 3000);
            } catch (error) {
                console.error(`Confirmation display failed: ${error.message}`);
            }
        }

        function toggleAutoGenerate() {
            try {
                console.log('Toggling auto generate...');
                const autoBtn = document.getElementById('autoGenerateBtn');
                isAutoGenerating = !isAutoGenerating;
                if (isAutoGenerating) {
                    autoBtn.innerText = 'Auto Generate: On';
                    autoGenerateInterval = setInterval(() => {
                        if (is3DMode) generate3DGrid();
                        else generateShape();
                    }, 300);
                } else {
                    autoBtn.innerText = 'Auto Generate: Off';
                    if (autoGenerateInterval) {
                        clearInterval(autoGenerateInterval);
                        autoGenerateInterval = null;
                    }
                }
                console.log('Auto generate:', isAutoGenerating ? 'On' : 'Off');
            } catch (error) {
                showConfirmation(`ERROR: Auto generate toggle failed - ${error.message}`);
                console.error('Auto generate toggle error:', error);
            }
        }

        function changeUIColor() {
            try {
                console.log('Changing UI color...');
                currentColorIndex = (currentColorIndex + 1) % uiColors.length;
                const newColor = uiColors[currentColorIndex];
                document.body.style.color = newColor;
                const header = document.querySelector('h1.glow-text');
                header.style.textShadow = `0 0 20px ${newColor}, 0 0 30px ${newColor}, 0 0 40px ${newColor}`;
                document.querySelector('style').innerHTML = document.querySelector('style').innerHTML.replace(
                    /@keyframes glow{from{text-shadow:0 0 10px #[\da-fA-F]{3,6}.*?}to{text-shadow:0 0 20px #[\da-fA-F]{3,6}.*?}}/,
                    `@keyframes glow{from{text-shadow:0 0 10px ${newColor}, 0 0 20px ${newColor}, 0 0 30px ${newColor}}to{text-shadow:0 0 20px ${newColor}, 0 0 30px ${newColor}, 0 0 40px ${newColor}}}`
                );
                const shape = document.getElementById('dynamic-shape');
                shape.style.borderColor = newColor;
                shape.style.boxShadow = `0 0 20px ${newColor}, 0 0 30px ${newColor}, 0 0 40px ${newColor}`;
                const buttons = document.querySelectorAll('button');
                buttons.forEach(btn => {
                    btn.style.color = newColor;
                    btn.style.borderColor = newColor;
                    btn.style.boxShadow = `0 0 15px ${newColor}, 0 0 25px ${newColor}`;
                    btn.onmouseover = () => {
                        btn.style.background = newColor;
                        btn.style.color = '#000';
                        btn.style.boxShadow = `0 0 25px ${newColor}, 0 0 35px ${newColor}, 0 0 45px ${newColor}`;
                    };
                    btn.onmouseout = () => {
                        btn.style.background = '#000';
                        btn.style.color = newColor;
                        btn.style.boxShadow = `0 0 15px ${newColor}, 0 0 25px ${newColor}`;
                    };
                });
                const confirmation = document.getElementById('confirmationText');
                confirmation.style.color = newColor;
                confirmation.style.textShadow = `0 0 15px ${newColor}, 0 0 25px ${newColor}`;
                document.querySelector('.copyright').style.color = '#FFFFFF';
                document.querySelector('.copyright').style.textShadow = `0 0 15px #FFFFFF`;
                drawCtx.strokeStyle = newColor;
                if (is3DMode && current3DGrid) {
                    current3DGrid.color = newColor;
                    const shape = document.querySelector('.grid-shape');
                    if (shape) {
                        shape.style.borderColor = newColor;
                        shape.style.boxShadow = `0 0 15px ${newColor}, 0 0 30px ${newColor}`;
                        if (current3DGrid.shape.type === 'grid') {
                            shape.style.background = `repeating-linear-gradient(45deg, ${newColor} 0px, ${newColor} 5px, transparent 5px, transparent 20px)`;
                        }
                    }
                }
                const walletPopup = document.getElementById('walletPopup');
                walletPopup.style.borderColor = newColor;
                walletPopup.style.boxShadow = `0 0 20px ${newColor}`;
                walletPopup.style.color = newColor;
                const walletInputs = walletPopup.querySelectorAll('input');
                walletInputs.forEach(input => {
                    input.style.color = newColor;
                    input.style.borderColor = newColor;
                });
                const walletButtons = walletPopup.querySelectorAll('button');
                walletButtons.forEach(btn => {
                    btn.style.color = newColor;
                    btn.style.borderColor = newColor;
                    btn.style.boxShadow = `0 0 15px ${newColor}, 0 0 25px ${newColor}`;
                    btn.onmouseover = () => {
                        btn.style.background = newColor;
                        btn.style.color = '#000';
                        btn.style.boxShadow = `0 0 25px ${newColor}, 0 0 35px ${newColor}, 0 0 45px ${newColor}`;
                    };
                    btn.onmouseout = () => {
                        btn.style.background = '#000';
                        btn.style.color = newColor;
                        btn.style.boxShadow = `0 0 15px ${newColor}, 0 0 25px ${newColor}`;
                    };
                });
                const walletCanvas = document.getElementById('walletCanvas');
                walletCanvas.style.borderColor = newColor;
                const walletHeader = walletPopup.querySelector('h2');
                walletHeader.style.color = newColor;
                walletHeader.style.textShadow = `0 0 10px ${newColor}`;
                const closeBtn = walletPopup.querySelector('.close-btn');
                closeBtn.style.color = newColor;
                closeBtn.style.textShadow = `0 0 10px ${newColor}`;
                redrawStrokes();
                console.log('UI color changed:', newColor);
            } catch (error) {
                showConfirmation(`ERROR: Color change failed - ${error.message}`);
                console.error('Color change error:', error);
            }
        }

        // Drawing Functions
        function getCanvasCoordinates(e) {
            try {
                const rect = drawCanvas.getBoundingClientRect();
                const scaleX = canvasWidth / rect.width;
                const scaleY = canvasHeight / rect.height;
                let x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
                let y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
                x *= scaleX;
                y *= scaleY;
                return { x, y };
            } catch (error) {
                console.error('Coordinate calculation error:', error);
                return { x: 0, y: 0 };
            }
        }

        function startDrawing(e) {
            try {
                if (!isDrawing && !isLineMode) return;
                e.preventDefault();
                const { x, y } = getCanvasCoordinates(e);
                if (isLineMode) {
                    if (!lineStart) {
                        lineStart = { x, y };
                        console.log('Line start:', x, y);
                    } else {
                        currentStroke = [lineStart, { x, y }];
                        drawCtx.beginPath();
                        drawCtx.moveTo(lineStart.x, lineStart.y);
                        drawCtx.lineTo(x, y);
                        drawCtx.stroke();
                        strokes.push([...currentStroke]);
                        lineStart = null;
                        currentStroke = [];
                        if (!isAutoGenerating) {
                            generateNFT();
                        }
                        console.log('Line drawn:', lineStart, { x, y });
                    }
                } else {
                    currentStroke = [{ x, y }];
                    drawCtx.beginPath();
                    drawCtx.moveTo(x, y);
                    console.log('Drawing started:', x, y);
                }
            } catch (error) {
                showConfirmation(`ERROR: Drawing start failed - ${error.message}`);
                console.error('Drawing start error:', error);
            }
        }

        function stopDrawing() {
            try {
                if (isDrawing && currentStroke.length > 1) {
                    strokes.push([...currentStroke]);
                    currentStroke = [];
                    drawCtx.beginPath();
                    if (!isAutoGenerating) {
                        generateNFT();
                    }
                    console.log('Drawing stopped, strokes saved:', strokes.length);
                }
            } catch (error) {
                showConfirmation(`ERROR: Drawing stop failed - ${error.message}`);
                console.error('Drawing stop error:', error);
            }
        }

        function draw(e) {
            try {
                if (!isDrawing || isLineMode) return;
                e.preventDefault();
                const { x, y } = getCanvasCoordinates(e);
                currentStroke.push({ x, y });
                drawCtx.lineTo(x, y);
                drawCtx.stroke();
                drawCtx.beginPath();
                drawCtx.moveTo(x, y);
            } catch (error) {
                showConfirmation(`ERROR: Drawing failed - ${error.message}`);
                console.error('Drawing error:', error);
            }
        }

        function redrawStrokes() {
            try {
                drawCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                drawCtx.strokeStyle = uiColors[currentColorIndex];
                strokes.forEach(stroke => {
                    if (stroke.length < 2) return;
                    drawCtx.beginPath();
                    stroke.forEach((point, idx) => {
                        if (idx === 0) drawCtx.moveTo(point.x, point.y);
                        else drawCtx.lineTo(point.x, point.y);
                    });
                    drawCtx.stroke();
                });
                console.log('Strokes redrawn:', strokes.length);
            } catch (error) {
                showConfirmation(`ERROR: Redraw strokes failed - ${error.message}`);
                console.error('Redraw strokes error:', error);
            }
        }

        function setupDrawingEvents() {
            try {
                drawCanvas.addEventListener('mousedown', startDrawing);
                drawCanvas.addEventListener('mouseup', stopDrawing);
                drawCanvas.addEventListener('mousemove', draw);
                drawCanvas.addEventListener('touchstart', startDrawing);
                drawCanvas.addEventListener('touchend', stopDrawing);
                drawCanvas.addEventListener('touchmove', draw);
                drawCanvas.addEventListener('mouseleave', stopDrawing);
                console.log('Drawing events set up');
            } catch (error) {
                showConfirmation(`ERROR: Setting up drawing events failed - ${error.message}`);
                console.error('Drawing events setup error:', error);
            }
        }

        setupDrawingEvents();

        function toggleDraw() {
            try {
                console.log('Toggling draw mode...');
                isDrawing = !isDrawing;
                if (isDrawing) {
                    isLineMode = false;
                    drawCanvas.classList.add('active');
                    const lineBtn = document.querySelector('button[onclick="toggleLine()"]');
                    lineBtn.innerText = 'Line';
                } else {
                    drawCanvas.classList.remove('active');
                }
                const drawBtn = document.querySelector('button[onclick="toggleDraw()"]');
                drawBtn.innerText = isDrawing ? 'Draw: On' : 'Draw';
                console.log('Draw mode:', isDrawing ? 'On' : 'Off');
            } catch (error) {
                showConfirmation(`ERROR: Draw toggle failed - ${error.message}`);
                console.error('Draw toggle error:', error);
            }
        }

        function toggleLine() {
            try {
                console.log('Toggling line mode...');
                isLineMode = !isLineMode;
                if (isLineMode) {
                    isDrawing = false;
                    lineStart = null;
                    drawCanvas.classList.add('active');
                    const drawBtn = document.querySelector('button[onclick="toggleDraw()"]');
                    drawBtn.innerText = 'Draw';
                } else {
                    drawCanvas.classList.remove('active');
                }
                const lineBtn = document.querySelector('button[onclick="toggleLine()"]');
                lineBtn.innerText = isLineMode ? 'Line: On' : 'Line';
                console.log('Line mode:', isLineMode ? 'On' : 'Off');
            } catch (error) {
                showConfirmation(`ERROR: Line toggle failed - ${error.message}`);
                console.error('Line toggle error:', error);
            }
        }

        function clearDrawing() {
            try {
                console.log('Clearing drawing...');
                strokes = [];
                currentStroke = [];
                lineStart = null;
                drawCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                if (!isAutoGenerating) {
                    generateNFT();
                }
                console.log('Drawing cleared');
            } catch (error) {
                showConfirmation(`ERROR: Clear drawing failed - ${error.message}`);
                console.error('Clear drawing error:', error);
            }
        }

        // Wallet Functions
        function openWallet() {
            try {
                console.log('Opening wallet...');
                document.getElementById('walletPopup').style.display = 'block';
                const walletCanvas = document.getElementById('walletCanvas');
                walletCanvas.width = 200;
                walletCanvas.height = 200;
                console.log('Wallet opened');
            } catch (error) {
                showConfirmation(`ERROR: Open wallet failed - ${error.message}`);
                console.error('Open wallet error:', error);
            }
        }

        function closeWallet() {
            try {
                console.log('Closing wallet...');
                document.getElementById('walletPopup').style.display = 'none';
                console.log('Wallet closed');
            } catch (error) {
                showConfirmation(`ERROR: Close wallet failed - ${error.message}`);
                console.error('Close wallet error:', error);
            }
        }

        function copyCurrentNFTCode() {
            try {
                console.log('Copying NFT code...');
                if (currentSerial && currentCode) {
                    navigator.clipboard.writeText(`${currentSerial}\n${currentCode}`).then(() => {
                        showConfirmation('Serial and code copied to clipboard');
                        console.log('NFT code copied');
                    }).catch(() => {
                        showConfirmation('ERROR: Failed to copy serial and code');
                        console.error('NFT code copy failed');
                    });
                } else {
                    showConfirmation('ERROR: No serial or code to copy');
                    console.error('No serial or code available');
                }
            } catch (error) {
                showConfirmation(`ERROR: Copy NFT code failed - ${error.message}`);
                console.error('Copy NFT code error:', error);
            }
        }

        function loadNFTImage() {
            try {
                console.log('Loading NFT image...');
                const serialInput = document.getElementById('nftSerialInput').value.trim();
                const codeInput = document.getElementById('nftCodeInput').value.trim();
                if (!serialInput || !codeInput) {
                    showConfirmation('ERROR: Serial and code required');
                    console.error('Serial or code missing');
                    return;
                }
                const serialMatch = serialInput.match(/^HOLO-\d{6}-[A-Z0-9]{3}$/);
                const validSerial = serialMatch ? serialMatch[0] : null;
                if (!validSerial) {
                    showConfirmation('ERROR: Invalid serial format. Use HOLO-XXXXXX-XXX');
                    console.error('Invalid serial format:', serialInput);
                    return;
                }
                const codeMatch = codeInput.match(/^Ω-CODE: [ΔΩΨΘΣΦΩΓΛΞΠΩ0123456789#@&%*+=\-<>]{9}$/);
                const validCode = codeMatch ? codeMatch[0] : null;
                if (!validCode) {
                    showConfirmation('ERROR: Invalid code format. Use Ω-CODE: followed by 9 glyphs');
                    console.error('Invalid code format:', codeInput);
                    return;
                }
                if (serialMap.has(validSerial)) {
                    const { code, encryptedDatabase, strokes: storedStrokes } = serialMap.get(validSerial);
                    if (code !== validCode) {
                        showConfirmation(`ERROR: Invalid code for serial ${validSerial}`);
                        console.error('Code mismatch:', validCode, code);
                        return;
                    }
                    const shapeData = decodeDatabase(encryptedDatabase, validSerial)[0];
                    if (!shapeData) {
                        showConfirmation('ERROR: Failed to decode shape data');
                        console.error('Decode failed');
                        return;
                    }
                    currentSerial = validSerial;
                    currentCode = validCode;
                    currentColorIndex = shapeData.colorIndex;
                    changeUIColor();
                    is3DMode = shapeData.is3DMode;
                    if (is3DMode) {
                        regenerate3DGrid(shapeData.grid, shapeData.scale, shapeData.rotation, shapeData.strokes);
                    } else {
                        regenerateShape(shapeData.pattern, shapeData.scale, shapeData.rotation, shapeData.strokes);
                    }
                    const walletCanvas = document.getElementById('walletCanvas');
                    const walletCtx = walletCanvas.getContext('2d');
                    walletCtx.clearRect(0, 0, walletCanvas.width, walletCanvas.height);
                    walletCtx.fillStyle = '#000';
                    walletCtx.fillRect(0, 0, walletCanvas.width, walletCanvas.height);
                    walletCtx.strokeStyle = uiColors[currentColorIndex];
                    walletCtx.lineWidth = 2;
                    walletCtx.lineCap = 'round';
                    walletCtx.lineJoin = 'round';
                    shapeData.strokes.forEach(stroke => {
                        if (stroke.length < 2) return;
                        walletCtx.beginPath();
                        stroke.forEach((point, idx) => {
                            const x = (point.x / canvasWidth) * walletCanvas.width;
                            const y = (point.y / canvasHeight) * walletCanvas.height;
                            if (idx === 0) walletCtx.moveTo(x, y);
                            else walletCtx.lineTo(x, y);
                        });
                        walletCtx.stroke();
                    });
                    showConfirmation(`Loaded: ${validSerial} | ${validCode}`);
                    console.log('NFT image loaded:', validSerial);
                } else {
                    showConfirmation(`ERROR: Serial ${validSerial} not found`);
                    console.error('Serial not found:', validSerial);
                }
            } catch (error) {
                showConfirmation(`ERROR: Load NFT image failed - ${error.message}`);
                console.error('Load NFT image error:', error);
            }
        }

        // Initialize
        try {
            console.log('Initializing...');
            loadState();
            generateShape();
            console.log('Initialization complete');
        } catch (error) {
            showConfirmation(`ERROR: Initialization failed - ${error.message}`);
            console.error('Initialization error:', error);
        }
    </script>
</body>
</html>
