<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Skulptor3D: Concept and Launch Overview Guide</title>
    <style>
        body {
            font-family: monospace;
            background: #000;
            color: #0f0;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        h1, h2, h3 {
            color: #0f0;
            margin: 20px 0 10px;
        }
        p, li {
            font-size: 16px;
            margin: 10px 0;
        }
        ul {
            padding-left: 20px;
        }
        a {
            color: #0c0;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .section {
            background: #111;
            padding: 20px;
            border: 1px solid #0f0;
            border-radius: 5px;
        }
        #console {
            width: 100%;
            height: 200px;
            overflow-y: auto;
            border: 1px solid #0f0;
            padding: 10px;
            background: #000;
            font-size: 14px;
            box-sizing: border-box;
        }
        #input-area {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }
        #command-input {
            padding: 10px;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            font-size: 16px;
            width: 100%;
            box-sizing: border-box;
            font-family: monospace;
        }
        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 12px;
            font-size: 16px;
            cursor: pointer;
            width: 100%;
            box-sizing: border-box;
        }
        button:hover {
            background: #0c0;
        }
        #skulptor3d-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 2px solid #0f0;
            padding: 15px;
            z-index: 1000;
        }
        #close-3d-popup {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #f00;
            color: #fff;
            font-weight: bold;
            padding: 8px;
            font-size: 14px;
        }
        #close-3d-popup:hover {
            background: #c00;
        }
        canvas {
            border: 1px solid #0f0;
            background: #000;
            width: 100%;
            max-width: 800px;
            box-sizing: border-box;
        }
        @media (min-width: 768px) {
            #input-area {
                flex-direction: row;
            }
            #command-input {
                width: 70%;
            }
            button {
                width: auto;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.28.0/full/pyodide.js"></script>
</head>
<body>
    <div class="container">
        <div class="section">
            <h1>Skulptor3D: Concept and Launch Overview Guide</h1>
            <p>Welcome to the open-source guide for Skulptor3D, a web-based application leveraging WebGPU and Pyodide for 3D visualization and interactive gaming. This guide is designed for GitHub contributors to understand, run, and enhance the project.</p>
        </div>
        <div class="section">
            <h2>Project Overview</h2>
            <p>Skulptor3D integrates WebGPU for 3D rendering with Pyodide for Python execution in the browser. Key features include:</p>
            <ul>
                <li><strong>WebGPU Rendering</strong>: Displays 3D graphics (e.g., rotating triangle) using WebGPU shaders.</li>
                <li><strong>Mars Trails Game</strong>: A text-based adventure managing resources to reach Mars.</li>
                <li><strong>Console Interface</strong>: Allows Python script execution and command input (e.g., <code>/test</code>).</li>
                <li><strong>PDF Support (Planned)</strong>: Aims to render PDF pages as 3D textures (currently disabled due to Pyodide limitations).</li>
            </ul>
            <p>The project is contained in a single <code>skulptor3d.html</code> file, making it easy to deploy and contribute to.</p>
        </div>
        <div class="section">
            <h2>Architecture</h2>
            <p>Skulptor3D uses the following technologies:</p>
            <ul>
                <li><strong>Pyodide</strong>: Runs Python in the browser, enabling dynamic script execution.</li>
                <li><strong>WebGPU</strong>: Provides high-performance 3D rendering via WGSL shaders.</li>
                <li><strong>JavaScript</strong>: Handles UI interactions and bridges Pyodide with WebGPU.</li>
                <li><strong>HTML/CSS</strong>: Monochrome interface (black background, neon green text) for consistency.</li>
            </ul>
            <p>The core <code>Skulptor3D</code> class in Python manages rendering, logging, and game logic, integrated into Margotinto HTML via Pyodide.</p>
        </div>
        <div class="section">
            <h2>Running Skulptor3D</h2>
            <p>To run Skulptor3D, open <code>skulptor3d.html</code> in a WebGPU-enabled browser (e.g., Chrome Canary, Edge). Use the console below to test WebGPU rendering or run commands like <code>/test</code>.</p>
            <p><strong>Note</strong>: PDF rendering is not currently supported due to Pyodide's inability to handle <code>pdf2image</code>. Future enhancements may explore alternative solutions.</p>
            <h3>Test WebGPU Rendering</h3>
            <p>Enter the following Python code in the console below and click "Run" to test WebGPU rendering (requires WebGPU-enabled browser):</p>
            <pre style="background: #111; padding: 10px; border: 1px solid #0f0;">
from __main__ import Skulptor3D
await Skulptor3D().render_3d()
            </pre>
            <div id="console"></div>
            <div id="input-area">
                <input id="command-input" type="text" placeholder="Enter Python code">
                <button onclick="executeCommand()">Run</button>
            </div>
        </div>
        <div id="skulptor3d-popup">
            <button id="close-3d-popup" onclick="close3DPopup()">X</button>
            <canvas id="skulptor3d-canvas"></canvas>
        </div>
        <div class="section">
            <h2>Contributing to Skulptor3D</h2>
            <p>Skulptor3D is open-source on GitHub. To contribute:</p>
            <ul>
                <li><strong>Repository</strong>: Fork the <a href="https://github.com/your-repo/skulptor3d">Skulptor3D repository</a> (replace with actual repo link).</li>
                <li><strong>Issues</strong>: Check open issues or create new ones for bugs/features.</li>
                <li><strong>Pull Requests</strong>: Submit PRs with clear descriptions and tests.</li>
                <li><strong>Guidelines</strong>:
                    <ul>
                        <li>Use Python 3.13 syntax for Pyodide compatibility.</li>
                        <li>Ensure WebGPU code works in Chrome Canary/utterstockEdge.</li>
                        <li>Maintain monochrome styling (#000, #0f0).</li>
                        <li>Test responsiveness on mobile and desktop.</li>
                    </ul>
                </li>
            </ul>
            <p><strong>Key Areas for Contribution</strong>:</p>
            <ul>
                <li>Enhance WebGPU shaders (e.g., Phong lighting, model loading).</li>
                <li>Add Mars Trails features (narrative events, scoring).</li>
                <li>Improve UI (theme toggle, resizable canvas).</li>
                <li>Optimize performance for low-end devices.</li>
            </ul>
        </div>
        <div class="section">
            <h2>Future Plans</h2>
            <ul>
                <li><strong>Advanced Rendering</strong>: Support complex 3D models (OBJ/GLTF) and shaders.</li>
                <li><strong>PDF Rendering</strong>: Explore WebAssembly-based PDF processing.</li>
                <li><strong>Multiplayer</strong>: Add WebRTC for Mars Trails multiplayer.</li>
                <li><strong>Mobile Optimization</strong>: Enhance touch controls and scaling.</li>
                <li><strong>Testing</strong>: Implement pytest for Pyodide-compatible unit tests.</li>
            </ul>
        </div>
    </div>
    <script type="text/pyodide">
import asyncio
import platform
import json
from datetime import datetime
import numpy as np

class Skulptor3D:
    def __init__(self, config=None):
        self.config = config or {
            'canvas_width': 800, 'canvas_height': 600, 'target_fps': 60,
            'canvas_id': 'skulptor3d-canvas', 'popup_id': 'skulptor3d-popup',
            'log_format': 'json'
        }
        self.canvas = None
        self.error_log = []
        self.rotation = 0.0
        self._check_js_module()

    def _check_js_module(self):
        try:
            import js
            self.js_available = True
            self.log("JavaScript bridge loaded", "INFO")
        except ModuleNotFoundError:
            self.js_available = False
            self.log("JavaScript bridge unavailable", "ERROR")
            self.error_log.append({'error': 'No js module', 'fix': 'Ensure Pyodide initialized'})

    def log(self, message, level="INFO"):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        if self.config['log_format'] == 'json':
            print(json.dumps({'timestamp': timestamp, 'level': level, 'message': message}))
            if level in ("ERROR", "WARNING"):
                self.error_log.append({'timestamp': timestamp, 'level': level, 'message': message})
        else:
            print(f"[{timestamp}] [{level}] {message}")
            if level in ("ERROR", "WARNING"):
                self.error_log.append(f"{timestamp}: {message}")

    async def initialize_webgpu(self):
        if not self.js_available:
            self.log("WebGPU initialization skipped: JS bridge unavailable", "ERROR")
            return False
        try:
            import js
            if not hasattr(js.navigator, 'gpu'):
                self.log("WebGPU not supported in this browser", "ERROR")
                return False
            adapter = await js.navigator.gpu.requestAdapter()
            if not adapter:
                self.log("No GPU adapter found", "ERROR")
                return False
            self.device = await adapter.requestDevice()
            canvas = js.document.getElementById(self.config['canvas_id'])
            if not canvas:
                self.log("Canvas not found", "ERROR")
                return False
            self.canvas = canvas
            self.canvas.width = self.config['canvas_width']
            self.canvas.height = self.config['canvas_height']
            self.context = canvas.getContext('webgpu')
            if not self.context:
                self.log("Failed to get WebGPU context", "ERROR")
                return False
            self.context.configure({
                'device': self.device,
                'format': js.navigator.gpu.getPreferredCanvasFormat(),
                'alphaMode': 'premultiplied'
            })
            self.log("WebGPU initialized", "INFO")
            return True
        except Exception as e:
            self.log(f"WebGPU init failed: {str(e)}", "ERROR")
            return False

    def show_3d_popup(self):
        if not self.js_available:
            self.log("Popup creation skipped: JS bridge unavailable", "ERROR")
            return False
        try:
            import js
            popup = js.document.getElementById(self.config['popup_id'])
            if not popup:
                popup = js.document.createElement('div')
                popup.id = self.config['popup_id']
                popup.style.cssText = 'background:#000;border:2px solid #0f0;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:1000;padding:10px'
                js.document.body.appendChild(popup)
            popup.style.display = 'block'
            return True
        except Exception as e:
            self.log(f"Popup failed: {str(e)}", "ERROR")
            return False

    def create_canvas(self):
        if not self.js_available:
            self.log("Canvas creation skipped: JS bridge unavailable", "ERROR")
            return False
        try:
            import js
            if not self.show_3d_popup():
                return False
            self.canvas = js.document.getElementById(self.config['canvas_id'])
            if not self.canvas:
                self.canvas = js.document.createElement('canvas')
                self.canvas.id = self.config['canvas_id']
                self.canvas.width = self.config['canvas_width']
                self.canvas.height = self.config['canvas_height']
                self.canvas.style.cssText = 'border:1px solid #0f0;background:#000'
                js.document.getElementById(self.config['popup_id']).appendChild(self.canvas)
            return True
        except Exception as e:
            self.log(f"Canvas creation failed: {str(e)}", "ERROR")
            return False

    async def render_3d(self):
        if not await self.initialize_webgpu():
            return False
        try:
            import js
            shader_module = self.device.createShaderModule({
                'code': f"""
                    @vertex
                    fn vertex_main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {{
                        let m = mat4x4<f32>(
                            cos({self.rotation}), -sin({self.rotation}), 0.0, 0.0,
                            sin({self.rotation}), cos({self.rotation}), 0.0, 0.0,
                            0.0, 0.0, 1.0, 0.0,
                            0.0, 0.0, 0.0, 1.0
                        );
                        let p = mat4x4<f32>(
                            2.0/{self.config['canvas_width']}, 0.0, 0.0, 0.0,
                            0.0, -2.0/{self.config['canvas_height']}, 0.0, 0.0,
                            0.0, 0.0, -1.0, 0.0,
                            -1.0, 1.0, 0.0, 1.0
                        );
                        return p * m * vec4<f32>(pos, 1.0);
                    }}
                    @fragment
                    fn fragment_main() -> @location(0) vec4<f32> {{
                        return vec4<f32>(0.0, 1.0, 0.0, 1.0);
                    }}
                """
            })
            pipeline = self.device.createRenderPipeline({
                'layout': 'auto',
                'vertex': {
                    'module': shader_module,
                    'entryPoint': 'vertex_main',
                    'buffers': [{
                        'arrayStride': 12,
                        'attributes': [{
                            'shaderLocation': 0,
                            'offset': 0,
                            'format': 'float32x3'
                        }]
                    }]
                },
                'fragment': {
                    'module': shader_module,
                    'entryPoint': 'fragment_main',
                    'targets': [{
                        'format': js.navigator.gpu.getPreferredCanvasFormat()
                    }]
                },
                'primitive': {'topology': 'triangle-list'}
            })
            vertices = js.Float32Array.new([
                -0.5, -0.5, 0.0,
                 0.5, -0.5, 0.0,
                 0.0,  0.5, 0.0
            ])
            vertex_buffer = self.device.createBuffer({
                'size': vertices.length * 4,
                'usage': js.GPUBufferUsage.VERTEX | js.GPUBufferUsage.COPY_DST
            })
            self.device.queue.writeBuffer(vertex_buffer, 0, vertices)

            async def render_loop():
                for _ in range(50):
                    self.rotation += 0.01
                    encoder = self.device.createCommandEncoder()
                    pass_encoder = encoder.beginRenderPass({
                        'colorAttachments': [{
                            'view': self.context.getCurrentTexture().createView(),
                            'clearValue': [0.0, 0.0, 0.0, 1.0],
                            'loadOp': 'clear',
                            'storeOp': 'store'
                        }]
                    })
                    pass_encoder.setPipeline(pipeline)
                    pass_encoder.setVertexBuffer(0, vertex_buffer)
                    pass_encoder.draw(3)
                    pass_encoder.end()
                    self.device.queue.submit([encoder.finish()])
                    await asyncio.sleep(1.0 / self.config['target_fps'])
                self.log("Rendering completed", "INFO")

            await self.create_canvas()
            asyncio.ensure_future(render_loop())
            self.log("Rendering started", "INFO")
            return True
        except Exception as e:
            self.log(f"Render failed: {str(e)}", "ERROR")
            return False

if platform.system() == "Emscripten":
    asyncio.ensure_future(Skulptor3D().render_3d())
    </script>
    <script>
        let pyodide;
        async function initPyodide() {
            try {
                document.getElementById('console').innerHTML += '[INFO] Initializing Pyodide...<br>';
                pyodide = await loadPyodide({ indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.28.0/full/' });
                await pyodide.loadPackage(['micropip']);
                await pyodide.runPythonAsync(`
                    import micropip
                    await micropip.install(['numpy'])
                    print("[INFO] Packages loaded successfully")
                `);
                document.getElementById('console').innerHTML += '[INFO] Pyodide initialized<br>';
                await pyodide.runPythonAsync(document.querySelector('script[type="text/pyodide"]').textContent);
            } catch (e) {
                document.getElementById('console').innerHTML += `[ERROR] Pyodide init failed: ${e}<br>`;
            }
        }

        function show3DPopup() { document.getElementById('skulptor3d-popup').style.display = 'block'; }
        function close3DPopup() { document.getElementById('skulptor3d-popup').style.display = 'none'; }

        async function executeCommand() {
            if (!pyodide) return;
            const cmd = document.getElementById('command-input').value.trim();
            try {
                await pyodide.runPythonAsync(cmd);
            } catch (err) {
                document.getElementById('console').innerHTML += `[ERROR] ${err}<br>`;
            }
            document.getElementById('command-input').value = '';
            document.getElementById('console').scrollTop = document.getElementById('console').scrollHeight;
        }

        document.getElementById('command-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') executeCommand();
        });
        initPyodide();
    </script>
</body>
</html>
