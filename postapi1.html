<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Post API</title>
    <style>
        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            flex: 1;
        }
        h1 {
            text-align: center;
            text-shadow: 0 0 10px #0f0;
        }
        .setup-wizard, .bulletin-ui, .diagnose-ui {
            display: none;
            background: #111;
            padding: 20px;
            border: 2px solid #0f0;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .setup-wizard.active, .bulletin-ui.active, .diagnose-ui.active {
            display: block;
        }
        input, button {
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            margin: 5px;
            font-family: 'Courier New', monospace;
        }
        button:hover {
            background: #0f0;
            color: #000;
            cursor: pointer;
        }
        .post-card {
            background: #111;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #0f0;
            border-radius: 5px;
        }
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #f00;
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        .toast.active {
            display: block;
        }
        footer {
            text-align: center;
            padding: 10px;
            color: #0f0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Post API</h1>
        <div class="setup-wizard active">
            <h2>Setup Wizard</h2>
            <p>Welcome to Post API! Create or join a bulletin to start.</p>
            <div>
                <input type="text" id="bulletinName" placeholder="Bulletin Name">
                <label><input type="checkbox" id="isPrivate"> Private Bulletin</label>
                <input type="password" id="bulletinPassword" placeholder="Password (for private)" disabled>
                <button onclick="createBulletin()">Create Bulletin</button>
            </div>
            <div>
                <input type="text" id="joinBulletinId" placeholder="Bulletin ID">
                <input type="text" id="joinToken" placeholder="Access Token">
                <input type="password" id="joinPassword" placeholder="Password (if private)">
                <button onclick="joinBulletin()">Join Bulletin</button>
            </div>
            <button onclick="showDiagnose()">Diagnose</button>
        </div>
        <div class="bulletin-ui">
            <h2 id="bulletinTitle"></h2>
            <p>Board ID: <span id="boardId"></span></p>
            <p>Access Token: <span id="accessToken"></span></p>
            <p>API Endpoint: <span id="apiEndpoint"></span></p>
            <div>
                <input type="text" id="postContent" placeholder="Write a post...">
                <input type="file" id="postFile">
                <button onclick="createPost()">Post</button>
            </div>
            <div id="posts"></div>
        </div>
        <div class="diagnose-ui">
            <h2>Diagnostics</h2>
            <div id="errorLog"></div>
            <button onclick="hideDiagnose()">Close</button>
        </div>
        <div class="toast" id="toast"></div>
    </div>
    <footer>&copy; 2025 Webxos</footer>

    <script>
        // IndexedDB Setup
        let db;
        const dbRequest = indexedDB.open('post-api', 1);
        dbRequest.onupgradeneeded = (event) => {
            db = event.target.result;
            db.createObjectStore('bulletins', { keyPath: 'id' });
            db.createObjectStore('posts', { keyPath: 'id', autoIncrement: true });
            db.createObjectStore('files', { keyPath: 'id', autoIncrement: true });
            db.createObjectStore('tokens', { keyPath: 'id' });
            db.createObjectStore('errors', { keyPath: 'id', autoIncrement: true });
        };
        dbRequest.onsuccess = (event) => {
            db = event.target.result;
            initializeApp();
        };
        dbRequest.onerror = (event) => {
            logError('IndexedDB initialization failed: ' + event.target.error);
        };

        // Virtual Worker Emulation
        const channel = new MessageChannel();
        const virtualWorker = channel.port1;
        let currentBulletin = null;
        let peerConnection = null;

        // Virtual Worker Logic
        const workerCode = () => {
            const handlers = {
                'fetch': async (event) => {
                    const url = event.url;
                    if (url.includes('/api/public-bulletins')) {
                        return await getPublicBulletins();
                    } else if (url.includes('/api/')) {
                        const [_, __, boardId, token] = url.split('/');
                        return await handleApiRequest(boardId, token);
                    }
                    return { status: 404, message: 'Not Found' };
                },
                'post': async (data) => {
                    return await storePost(data);
                }
            };

            self.onmessage = async (event) => {
                const { type, data } = event.data;
                const response = await handlers[type]?.(data) || { status: 404, message: 'Invalid request' };
                self.postMessage({ id: data.id, response });
            };

            async function getPublicBulletins() {
                const tx = db.transaction(['bulletins'], 'readonly');
                const store = tx.objectStore('bulletins');
                const bulletins = await new Promise(resolve => {
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result.filter(b => !b.isPrivate));
                    request.onerror = () => resolve([]);
                });
                return { status: 200, data: bulletins };
            }

            async function handleApiRequest(boardId, token) {
                const tx = db.transaction(['tokens', 'bulletins', 'posts'], 'readonly');
                const tokenStore = tx.objectStore('tokens');
                const bulletinStore = tx.objectStore('bulletins');
                const postStore = tx.objectStore('posts');

                const tokenData = await new Promise(resolve => {
                    const request = tokenStore.get(boardId);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => resolve(null);
                });

                if (!tokenData || tokenData.token !== token) {
                    return { status: 403, message: 'Invalid token' };
                }

                const bulletin = await new Promise(resolve => {
                    const request = bulletinStore.get(boardId);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => resolve(null);
                });

                if (!bulletin) {
                    return { status: 404, message: 'Bulletin not found' };
                }

                const posts = await new Promise(resolve => {
                    const request = postStore.getAll();
                    request.onsuccess = () => resolve(request.result.filter(p => p.boardId === boardId));
                    request.onerror = () => resolve([]);
                });

                return { status: 200, data: { bulletin, posts } };
            }

            async function storePost(data) {
                const tx = db.transaction(['posts', 'bulletins'], 'readwrite');
                const postStore = tx.objectStore('posts');
                const bulletinStore = tx.objectStore('bulletins');
                const bulletin = await new Promise(resolve => {
                    const request = bulletinStore.get(data.boardId);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => resolve(null);
                });

                if (!bulletin || (bulletin.isPrivate && data.password !== bulletin.password)) {
                    return { status: 403, message: 'Access denied' };
                }

                const post = { boardId: data.boardId, content: data.content, timestamp: Date.now() };
                const postId = await new Promise(resolve => {
                    const request = postStore.add(post);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => resolve(null);
                });

                if (postId) {
                    syncPostToPeers(post);
                    return { status: 200, data: post };
                }
                return { status: 500, message: 'Failed to store post' };
            }
        };

        // Initialize Virtual Worker
        const workerScript = `(${workerCode.toString()})();`;
        const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);
        const virtualWorkerInstance = new Worker(workerUrl);
        virtualWorkerInstance.onmessage = (event) => {
            const { id, response } = event.data;
            pendingRequests[id]?.(response);
        };

        let requestId = 0;
        const pendingRequests = {};
        function sendToVirtualWorker(type, data) {
            return new Promise(resolve => {
                const id = requestId++;
                pendingRequests[id] = resolve;
                virtualWorkerInstance.postMessage({ type, data: { id, ...data } });
            });
        }

        // WebRTC Setup
        function setupWebRTC(boardId, isCreator) {
            const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
            peerConnection = new RTCPeerConnection(configuration);
            const dataChannel = peerConnection.createDataChannel('post-api');
            dataChannel.onmessage = (event) => {
                const post = JSON.parse(event.data);
                storePost(post);
                renderPosts();
            };
            dataChannel.onopen = () => console.log('Data channel open');
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    // Manual signaling (in production, use a signaling server)
                    console.log('Share this ICE candidate:', JSON.stringify(peerConnection.localDescription));
                }
            };

            if (isCreator) {
                peerConnection.createOffer().then(offer => {
                    peerConnection.setLocalDescription(offer);
                    // Share offer via UI or signaling server
                    showToast('Share this offer: ' + JSON.stringify(offer));
                });
            }
        }

        function syncPostToPeers(post) {
            if (peerConnection?.getDataChannels()[0]?.readyState === 'open') {
                peerConnection.getDataChannels()[0].send(JSON.stringify(post));
            }
        }

        // UI Functions
        function initializeApp() {
            const isSecure = location.protocol === 'https:' || location.hostname === 'localhost';
            if (!isSecure) {
                showToast('Please serve over HTTPS or localhost for full functionality.');
            }
            document.getElementById('isPrivate').addEventListener('change', (e) => {
                document.getElementById('bulletinPassword').disabled = !e.target.checked;
            });
        }

        async function createBulletin() {
            const name = document.getElementById('bulletinName').value;
            const isPrivate = document.getElementById('isPrivate').checked;
            const password = document.getElementById('bulletinPassword').value;
            if (!name) {
                showToast('Bulletin name is required');
                return;
            }
            if (isPrivate && !password) {
                showToast('Password is required for private bulletins');
                return;
            }

            const boardId = Math.random().toString(36).slice(2);
            const token = Math.random().toString(36).slice(2);
            const bulletin = { id: boardId, name, isPrivate, password: isPrivate ? password : null };

            const tx = db.transaction(['bulletins', 'tokens'], 'readwrite');
            tx.objectStore('bulletins').add(bulletin);
            tx.objectStore('tokens').add({ id: boardId, token });
            await new Promise(resolve => tx.oncomplete = resolve);

            currentBulletin = bulletin;
            setupWebRTC(boardId, true);
            showBulletinUI(boardId, token);
        }

        async function joinBulletin() {
            const boardId = document.getElementById('joinBulletinId').value;
            const token = document.getElementById('joinToken').value;
            const password = document.getElementById('joinPassword').value;

            const response = await sendToVirtualWorker('fetch', { url: `/api/${boardId}/${token}` });
            if (response.status !== 200) {
                showToast(response.message);
                return;
            }

            if (response.data.bulletin.isPrivate && response.data.bulletin.password !== password) {
                showToast('Invalid password');
                return;
            }

            currentBulletin = response.data.bulletin;
            setupWebRTC(boardId, false);
            showBulletinUI(boardId, token);
        }

        async function createPost() {
            const content = document.getElementById('postContent').value;
            const file = document.getElementById('postFile').files[0];
            if (!content && !file) {
                showToast('Post content or file required');
                return;
            }

            const post = { boardId: currentBulletin.id, content };
            if (file) {
                post.fileId = await storeFile(file);
            }

            const response = await sendToVirtualWorker('post', post);
            if (response.status === 200) {
                renderPosts();
                document.getElementById('postContent').value = '';
                document.getElementById('postFile').value = '';
            } else {
                showToast(response.message);
            }
        }

        async function storeFile(file) {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            return new Promise(resolve => {
                reader.onload = () => {
                    const tx = db.transaction(['files'], 'readwrite');
                    const store = tx.objectStore('files');
                    const request = store.add({ data: reader.result, name: file.name });
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => resolve(null);
                };
            });
        }

        async function renderPosts() {
            const tx = db.transaction(['posts', 'files'], 'readonly');
            const postStore = tx.objectStore('posts');
            const fileStore = tx.objectStore('files');
            const posts = await new Promise(resolve => {
                const request = postStore.getAll();
                request.onsuccess = () => resolve(request.result.filter(p => p.boardId === currentBulletin.id));
                request.onerror = () => resolve([]);
            });

            const postsDiv = document.getElementById('posts');
            postsDiv.innerHTML = '';
            for (const post of posts) {
                const postDiv = document.createElement('div');
                postDiv.className = 'post-card';
                postDiv.innerHTML = `<p>${post.content}</p><small>${new Date(post.timestamp).toLocaleString()}</small>`;
                if (post.fileId) {
                    const file = await new Promise(resolve => {
                        const request = fileStore.get(post.fileId);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => resolve(null);
                    });
                    if (file) {
                        postDiv.innerHTML += `<p><a href="${file.data}" download="${file.name}">${file.name}</a></p>`;
                    }
                }
                postsDiv.appendChild(postDiv);
            }
        }

        function showBulletinUI(boardId, token) {
            document.getElementById('bulletinTitle').textContent = currentBulletin.name;
            document.getElementById('boardId').textContent = boardId;
            document.getElementById('accessToken').textContent = token;
            document.getElementById('apiEndpoint').textContent = `/api/${boardId}/${token}`;
            document.querySelector('.setup-wizard').classList.remove('active');
            document.querySelector('.bulletin-ui').classList.add('active');
            renderPosts();
        }

        function showDiagnose() {
            document.querySelector('.diagnose-ui').classList.add('active');
            renderErrorLog();
        }

        function hideDiagnose() {
            document.querySelector('.diagnose-ui').classList.remove('active');
        }

        async function renderErrorLog() {
            const tx = db.transaction(['errors'], 'readonly');
            const store = tx.objectStore('errors');
            const errors = await new Promise(resolve => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => resolve([]);
            });

            const errorLog = document.getElementById('errorLog');
            errorLog.innerHTML = errors.map(e => `<p>${e.message} (${new Date(e.timestamp).toLocaleString()})</p>`).join('');
        }

        function logError(message) {
            const tx = db.transaction(['errors'], 'readwrite');
            const store = tx.objectStore('errors');
            store.add({ message, timestamp: Date.now() });
            showToast(message);
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('active');
            setTimeout(() => toast.classList.remove('active'), 3000);
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (currentBulletin) {
                const tx = db.transaction(['bulletins', 'posts', 'files', 'tokens'], 'readwrite');
                tx.objectStore('bulletins').delete(currentBulletin.id);
                tx.objectStore('tokens').delete(currentBulletin.id);
                const postStore = tx.objectStore('posts');
                postStore.getAll().onsuccess = (event) => {
                    event.target.result.filter(p => p.boardId === currentBulletin.id).forEach(p => postStore.delete(p.id));
                };
                const file_gcc = tx.objectStore('files');
                fileStore.getAll().onsuccess = (event) => {
                    event.target.result.forEach(f => fileStore.delete(f.id));
                };
            }
            if (peerConnection) {
                peerConnection.close();
            }
            URL.revokeObjectURL(workerUrl);
        });
    </script>
</body>
</html>
